/* SPDX-FileCopyrightText: 2011-2022 Blender Foundation
 *
 * SPDX-License-Identifier: Apache-2.0 */

#include "node_color.h"
#include "stdcycles.h"

vector sky_spherical_coordinates(vector dir)
{
  return vector(acos(dir[2]), atan2(dir[0], dir[1]), 0);
}

vector spherical_to_direction(float lat, float lon)
{
  return vector(cos(lat) * cos(lon), cos(lat) * sin(lon), sin(lat));
}

float precise_angle(vector a, vector b)
{
  return 2.0 * atan2(length(a - b), length(a + b));
}

float signx(float x)
{
  if (x < 0.0) {
    return -1.0;
  }
  else if (x > 0.0) {
    return 1.0;
  }
  else {
    return 0.0;
  }
}

color sky_radiance(vector dir, float sky_data[11], string filename, int sky_type)
{
  /* Get 2 pixels data */
  color pixel_bottom = color(sky_data[0], sky_data[1], sky_data[2]);
  color pixel_top = color(sky_data[3], sky_data[4], sky_data[5]);
  float sun_elevation = sky_data[6];
  float sun_rotation = sky_data[7];
  float angular_diameter = sky_data[8];
  float sun_intensity = sky_data[9];
  float earth_intersection_angle = sky_data[10];
  int sun_disc = angular_diameter > 0;
  vector sun_dir = spherical_to_direction(sun_elevation, sun_rotation + M_PI_2);
  float sun_dir_angle = precise_angle(dir, sun_dir);
  float half_angular = angular_diameter * 0.5;
  float alpha = 1.0;
  color rgb_sun = color(0.0, 0.0, 0.0);
  vector direction = sky_spherical_coordinates(dir);
  float dir_elevation = M_PI_2 - direction[0];

  /* If the ray is inside the Sun disc and is not occluded by Earth's surface, render it, otherwise
   * render the sky. Alternatively, ignore the Sun if we're evaluating the background texture. */
  if (sun_dir_angle < half_angular && sun_disc == 1 && raytype("importance_bake") != 1 &&
      dir_elevation > earth_intersection_angle)
  {
    float y = ((dir_elevation - sun_elevation) / angular_diameter) + 0.5;
    color xyz = mix(pixel_bottom, pixel_top, y);
    /* Limb darkening, coefficient is 0.6 */
    float angle_fraction = sun_dir_angle / half_angular;
    float limb_darkening = (1.0 - 0.6 * (1.0 - sqrt(1.0 - angle_fraction * angle_fraction)));
    rgb_sun = xyz_to_rgb(xyz[0], xyz[1], xyz[2]) * limb_darkening;
  }
  float x = (direction[1] + M_PI + sun_rotation) / M_2PI;
  if (x > 1.0) {
    x = x - 1.0;
  }
  color rgb_sky;
  if (sky_type == 0 && dir[2] < 0.0) {
    /* Fade ground to black for Single Scattering model and disable Sun disc below horizon */
    rgb_sun = color(0.0, 0.0, 0.0);
    if (dir[2] < -0.4) {
      rgb_sky = color(0.0, 0.0, 0.0);
    }
    else {
      float fade = pow(1.0 + dir[2] * 2.5, 3.0);
      color xyz = (color)texture(
          filename, x, 0.492, "wrap", "periodic", "interp", "linear", "alpha", alpha);
      rgb_sky = xyz_to_rgb(xyz[0], xyz[1], xyz[2]) * fade;
    }
  }
  else {
    /* Undo the non-linear transformation from the sky LUT */
    float dir_elevation_abs = (dir_elevation < 0.0) ? -dir_elevation : dir_elevation;
    float y = 1.0 - (sqrt(dir_elevation_abs / M_PI_2) * signx(dir_elevation) * 0.5 + 0.5);
    color xyz = (color)texture(
        filename, x, y, "wrap", "clamp", "interp", "linear", "alpha", alpha);
    rgb_sky = xyz_to_rgb(xyz[0], xyz[1], xyz[2]);
  }

  return rgb_sun * sun_intensity + rgb_sky;
}

shader node_sky_texture(
    int use_mapping = 0,
    matrix mapping = matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    vector Vector = P,
    int sky_type = 1,
    string filename = "",
    float sky_data[11] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    output color Color = color(0.0, 0.0, 0.0))
{
  vector p = Vector;

  if (use_mapping)
    p = transform(mapping, p);

  Color = sky_radiance(p, sky_data, filename, sky_type);
}
