diff --git a/pxr/imaging/hdSt/indirectDrawBatch.cpp b/pxr/imaging/hdSt/indirectDrawBatch.cpp
index 2b88b2f0f..0b036ffa2 100644
--- a/pxr/imaging/hdSt/indirectDrawBatch.cpp
+++ b/pxr/imaging/hdSt/indirectDrawBatch.cpp
@@ -94,11 +94,17 @@ HdSt_IndirectDrawBatch::HdSt_IndirectDrawBatch(
     , _instanceCountOffset(0)
     , _cullInstanceCountOffset(0)
     , _needsTextureResourceRebinding(false)
+    , _vao(0)
 {
     _Init(drawItemInstance);
 }
 
-HdSt_IndirectDrawBatch::~HdSt_IndirectDrawBatch() = default;
+HdSt_IndirectDrawBatch::~HdSt_IndirectDrawBatch()
+{
+    if (_vao) {
+        glDeleteVertexArrays(1, &_vao);
+    }
+}
 
 /*virtual*/
 void
@@ -1182,6 +1188,14 @@ HdSt_IndirectDrawBatch::_ExecuteDraw(
                                state.instancePrimvarBars);
     }
 
+    // OpenGL core profile requries a VAO for binding buffers.
+    if (capabilities->GetCoreProfile()) {
+        if (!_vao) {
+            glCreateVertexArrays(1, &_vao);
+        }
+        glBindVertexArray(_vao);
+    }
+
     state.BindResourcesForDrawing(renderPassState, *capabilities);
 
     HdSt_GeometricShaderSharedPtr geometricShader = state.geometricShader;
@@ -1438,6 +1452,15 @@ HdSt_IndirectDrawBatch::_ExecuteFrustumCull(
             cullingProgram.GetGeometricShader());
 
     Hgi * hgi = resourceRegistry->GetHgi();
+    HgiCapabilities const *capabilities = hgi->GetCapabilities();
+
+    // OpenGL core profile requries a VAO for binding buffers.
+    if (capabilities->GetCoreProfile()) {
+        if (!_vao) {
+            glCreateVertexArrays(1, &_vao);
+        }
+        glBindVertexArray(_vao);
+    }
 
     HgiGraphicsPipelineSharedPtr const & pso =
         _GetCullPipeline(resourceRegistry,
diff --git a/pxr/imaging/hdSt/indirectDrawBatch.h b/pxr/imaging/hdSt/indirectDrawBatch.h
index 2b4c9dafb..aad43302a 100644
--- a/pxr/imaging/hdSt/indirectDrawBatch.h
+++ b/pxr/imaging/hdSt/indirectDrawBatch.h
@@ -184,6 +184,8 @@ private:
     int _cullInstanceCountOffset;
 
     bool _needsTextureResourceRebinding;
+
+    uint32_t _vao;
 };
 
 
diff --git a/pxr/imaging/hdSt/renderPassState.cpp b/pxr/imaging/hdSt/renderPassState.cpp
index 76c44980d..730502a22 100644
--- a/pxr/imaging/hdSt/renderPassState.cpp
+++ b/pxr/imaging/hdSt/renderPassState.cpp
@@ -776,7 +776,9 @@ HdStRenderPassState::Bind(HgiCapabilities const &hgiCapabilities)
         // If not using GL_MULTISAMPLE, use GL_POINT_SMOOTH to render points as 
         // circles instead of square.
         // XXX Switch points rendering to emit quad with FS that draws circle.
-        glEnable(GL_POINT_SMOOTH);
+        if (!hgiCapabilities.GetCoreProfile()) {
+            glEnable(GL_POINT_SMOOTH);
+        }
     }
 }
 
@@ -820,8 +822,10 @@ HdStRenderPassState::Unbind(HgiCapabilities const &hgiCapabilities)
     }
 
     glEnable(GL_MULTISAMPLE);
-    glDisable(GL_POINT_SMOOTH);
-    glDisable(GL_POINT_SPRITE);
+    if (!hgiCapabilities.GetCoreProfile()) {
+        glDisable(GL_POINT_SMOOTH);
+        glDisable(GL_POINT_SPRITE);
+    }
 }
 
 void
diff --git a/pxr/imaging/hgi/capabilities.h b/pxr/imaging/hgi/capabilities.h
index b53197566..605e4d7ca 100644
--- a/pxr/imaging/hgi/capabilities.h
+++ b/pxr/imaging/hgi/capabilities.h
@@ -35,6 +35,11 @@ public:
     HGI_API
     virtual int GetShaderVersion() const = 0;
 
+    HGI_API
+    virtual bool GetCoreProfile() const {
+        return false;
+    }
+
     HGI_API
     size_t GetMaxUniformBlockSize() const {
         return _maxUniformBlockSize;
diff --git a/pxr/imaging/hgiGL/blitCmds.cpp b/pxr/imaging/hgiGL/blitCmds.cpp
index 46b2aa0fd..38e5fd4b1 100644
--- a/pxr/imaging/hgiGL/blitCmds.cpp
+++ b/pxr/imaging/hgiGL/blitCmds.cpp
@@ -119,7 +119,7 @@ HgiGLBlitCmds::_Submit(Hgi* hgi, HgiSubmitWaitType wait)
     // Capture OpenGL state before executing the 'ops' and restore it when this
     // function ends. We do this defensively because parts of our pipeline may
     // not set and restore all relevant gl state.
-    HgiGL_ScopedStateHolder openglStateGuard;
+    HgiGL_ScopedStateHolder openglStateGuard(*hgi->GetCapabilities());
 
     HgiGL* hgiGL = static_cast<HgiGL*>(hgi);
     HgiGLDevice* device = hgiGL->GetPrimaryDevice();
diff --git a/pxr/imaging/hgiGL/capabilities.cpp b/pxr/imaging/hgiGL/capabilities.cpp
index eaf70a477..dfd44f5fb 100644
--- a/pxr/imaging/hgiGL/capabilities.cpp
+++ b/pxr/imaging/hgiGL/capabilities.cpp
@@ -42,6 +42,7 @@ static const int _DefaultMaxClipDistances             = 8;
 HgiGLCapabilities::HgiGLCapabilities()
     : _glVersion(0)
     , _glslVersion(_DefaultGLSLVersion)
+    , _coreProfile(false)
 {
     _LoadCapabilities();
 }
@@ -117,6 +118,11 @@ HgiGLCapabilities::_LoadCapabilities()
                       &uniformBufferOffsetAlignment);
         _uniformBufferOffsetAlignment = uniformBufferOffsetAlignment;
     }
+    if (_glVersion >= 320) {
+        GLint profileMask = 0;
+        glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &profileMask);
+        _coreProfile = (profileMask & GL_CONTEXT_CORE_PROFILE_BIT);
+    }
     if (_glVersion >= 430) {
         GLint maxShaderStorageBlockSize = 0;
         glGetIntegerv(GL_MAX_SHADER_STORAGE_BLOCK_SIZE,
@@ -250,4 +256,9 @@ HgiGLCapabilities::GetShaderVersion() const {
     return _glslVersion;
 }
 
+bool
+HgiGLCapabilities::GetCoreProfile() const {
+    return _coreProfile;
+}
+
 PXR_NAMESPACE_CLOSE_SCOPE
diff --git a/pxr/imaging/hgiGL/capabilities.h b/pxr/imaging/hgiGL/capabilities.h
index 2ba137e95..64821ad27 100644
--- a/pxr/imaging/hgiGL/capabilities.h
+++ b/pxr/imaging/hgiGL/capabilities.h
@@ -35,6 +35,9 @@ public:
     HGIGL_API
     int GetShaderVersion() const override;
 
+    HGIGL_API
+    bool GetCoreProfile() const override;
+
 private:
     void _LoadCapabilities();
 
@@ -43,6 +46,9 @@ private:
     
     // GLSL version 
     int _glslVersion; // 400, 410, ...
+
+    // Core Profile
+    bool _coreProfile;
 };
 
 PXR_NAMESPACE_CLOSE_SCOPE
diff --git a/pxr/imaging/hgiGL/graphicsCmds.cpp b/pxr/imaging/hgiGL/graphicsCmds.cpp
index c22f2d75e..f6b724bb5 100644
--- a/pxr/imaging/hgiGL/graphicsCmds.cpp
+++ b/pxr/imaging/hgiGL/graphicsCmds.cpp
@@ -232,7 +232,7 @@ HgiGLGraphicsCmds::_Submit(Hgi* hgi, HgiSubmitWaitType wait)
     // Capture OpenGL state before executing the 'ops' and restore it when this
     // function ends. We do this defensively because parts of our pipeline may
     // not set and restore all relevant gl state.
-    HgiGL_ScopedStateHolder openglStateGuard;
+    HgiGL_ScopedStateHolder openglStateGuard(*hgi->GetCapabilities());
 
     // Resolve multisample textures
     HgiGL* hgiGL = static_cast<HgiGL*>(hgi);
diff --git a/pxr/imaging/hgiGL/graphicsPipeline.cpp b/pxr/imaging/hgiGL/graphicsPipeline.cpp
index 9704c6e11..6d864f398 100644
--- a/pxr/imaging/hgiGL/graphicsPipeline.cpp
+++ b/pxr/imaging/hgiGL/graphicsPipeline.cpp
@@ -25,7 +25,12 @@ HgiGLGraphicsPipeline::HgiGLGraphicsPipeline(
 {
 }
 
-HgiGLGraphicsPipeline::~HgiGLGraphicsPipeline() = default;
+HgiGLGraphicsPipeline::~HgiGLGraphicsPipeline()
+{
+    if (_vao) {
+        glDeleteVertexArrays(1, &_vao);
+    }
+}
 
 void
 HgiGLGraphicsPipeline::BindPipeline()
@@ -33,6 +38,7 @@ HgiGLGraphicsPipeline::BindPipeline()
     if (_vao) {
         glBindVertexArray(0);
         glDeleteVertexArrays(1, &_vao);
+        _vao = 0;
     }
 
     if (!_descriptor.vertexBuffers.empty()) {
@@ -91,6 +97,8 @@ HgiGLGraphicsPipeline::BindPipeline()
         glBindVertexArray(_vao);
     }
 
+    const bool coreProfile = _hgi->GetCapabilities()->GetCoreProfile();
+
     //
     // Depth Stencil State
     //
@@ -160,7 +168,9 @@ HgiGLGraphicsPipeline::BindPipeline()
         // If not using GL_MULTISAMPLE, use GL_POINT_SMOOTH to render points as 
         // circles instead of square.
         // XXX Switch points rendering to emit quad with FS that draws circle.
-        glEnable(GL_POINT_SMOOTH);
+        if (!coreProfile) {
+            glEnable(GL_POINT_SMOOTH);
+        }
     }
     if (_descriptor.multiSampleState.alphaToCoverageEnable) {
         glEnable(GL_SAMPLE_ALPHA_TO_COVERAGE);
@@ -195,7 +205,7 @@ HgiGLGraphicsPipeline::BindPipeline()
         glFrontFace(GL_CCW);
     }
 
-    if (_descriptor.rasterizationState.lineWidth != 1.0f) {
+    if (!coreProfile && _descriptor.rasterizationState.lineWidth != 1.0f) {
         glLineWidth(_descriptor.rasterizationState.lineWidth);
     }
 
diff --git a/pxr/imaging/hgiGL/scopedStateHolder.cpp b/pxr/imaging/hgiGL/scopedStateHolder.cpp
index 28e31b12e..737a75dad 100644
--- a/pxr/imaging/hgiGL/scopedStateHolder.cpp
+++ b/pxr/imaging/hgiGL/scopedStateHolder.cpp
@@ -9,6 +9,7 @@
 #include "pxr/imaging/hgiGL/scopedStateHolder.h"
 #include "pxr/imaging/hgiGL/conversions.h"
 #include "pxr/imaging/hgiGL/diagnostic.h"
+#include "pxr/imaging/hgiGL/hgi.h"
 
 #include "pxr/base/trace/trace.h"
 #include "pxr/base/tf/diagnostic.h"
@@ -16,8 +17,10 @@
 
 PXR_NAMESPACE_OPEN_SCOPE
 
-HgiGL_ScopedStateHolder::HgiGL_ScopedStateHolder()
-    : _restoreRenderBuffer(0)
+HgiGL_ScopedStateHolder::HgiGL_ScopedStateHolder(
+    HgiCapabilities const& capabilities)
+    : _coreProfile(capabilities.GetCoreProfile())
+    , _restoreRenderBuffer(0)
     , _restoreVao(0)
     , _restoreDepthTest(false)
     , _restoreDepthWriteMask(false)
@@ -101,7 +104,9 @@ HgiGL_ScopedStateHolder::HgiGL_ScopedStateHolder()
     glGetBooleanv(
         GL_SAMPLE_ALPHA_TO_ONE,
         (GLboolean*)&_restoreSampleAlphaToOne);
-    glGetFloatv(GL_LINE_WIDTH, &_lineWidth);
+    if (!_coreProfile) {
+        glGetFloatv(GL_LINE_WIDTH, &_lineWidth);
+    }
     glGetBooleanv(GL_CULL_FACE, (GLboolean*)&_cullFace);
     glGetIntegerv(GL_CULL_FACE_MODE, &_cullMode);
     glGetIntegerv(GL_FRONT_FACE, &_frontFace);
@@ -125,8 +130,10 @@ HgiGL_ScopedStateHolder::HgiGL_ScopedStateHolder()
     }
 
     glGetBooleanv(GL_MULTISAMPLE, (GLboolean*)&_restoreMultiSample);
-    glGetBooleanv(GL_POINT_SMOOTH, (GLboolean*)&_restorePointSmooth);
-    glGetBooleanv(GL_POINT_SPRITE, (GLboolean*)&_restorePointSprite);
+    if (!_coreProfile) {
+        glGetBooleanv(GL_POINT_SMOOTH, (GLboolean*)&_restorePointSmooth);
+        glGetBooleanv(GL_POINT_SPRITE, (GLboolean*)&_restorePointSprite);
+    }
 
     glGetIntegerv(GL_UNPACK_ALIGNMENT, &_restoreUnpackAlignment);
     glGetIntegerv(GL_PACK_ALIGNMENT, &_restorePackAlignment);
@@ -225,7 +232,9 @@ HgiGL_ScopedStateHolder::~HgiGL_ScopedStateHolder()
                _restoreViewport[2], _restoreViewport[3]);
     glBindVertexArray(_restoreVao);
     glBindRenderbuffer(GL_RENDERBUFFER, _restoreRenderBuffer);
-    glLineWidth(_lineWidth);
+    if (!_coreProfile) {
+        glLineWidth(_lineWidth);
+    }
     if (_cullFace) {
         glEnable(GL_CULL_FACE);
     } else {
@@ -275,10 +284,12 @@ HgiGL_ScopedStateHolder::~HgiGL_ScopedStateHolder()
         glDisable(GL_MULTISAMPLE);
     }
 
-    if (_restorePointSmooth) {
-        glEnable(GL_POINT_SMOOTH);
-    } else {
-        glDisable(GL_POINT_SMOOTH);
+    if (!_coreProfile) {
+        if (_restorePointSmooth) {
+            glEnable(GL_POINT_SMOOTH);
+        } else {
+            glDisable(GL_POINT_SMOOTH);
+        }
     }
 
     if (_restorePointSprite) {
diff --git a/pxr/imaging/hgiGL/scopedStateHolder.h b/pxr/imaging/hgiGL/scopedStateHolder.h
index 4e76d5426..39de06111 100644
--- a/pxr/imaging/hgiGL/scopedStateHolder.h
+++ b/pxr/imaging/hgiGL/scopedStateHolder.h
@@ -15,6 +15,7 @@
 
 PXR_NAMESPACE_OPEN_SCOPE
 
+class HgiCapabilities;
 
 /// \class HgiGLScopedStateHolder
 ///
@@ -33,7 +34,7 @@ class HgiGL_ScopedStateHolder final
 {
 public:
     HGIGL_API
-    HgiGL_ScopedStateHolder();
+    HgiGL_ScopedStateHolder(HgiCapabilities const& capabilities);
 
     HGIGL_API
     ~HgiGL_ScopedStateHolder();
@@ -42,6 +43,8 @@ private:
     HgiGL_ScopedStateHolder& operator=(const HgiGL_ScopedStateHolder&) = delete;
     HgiGL_ScopedStateHolder(const HgiGL_ScopedStateHolder&) = delete;
 
+    bool _coreProfile;
+
     int32_t _restoreRenderBuffer;
     int32_t _restoreVao;
 
diff --git a/pxr/imaging/hgiInterop/opengl.cpp b/pxr/imaging/hgiInterop/opengl.cpp
index 36bc59bdf..672b9b044 100644
--- a/pxr/imaging/hgiInterop/opengl.cpp
+++ b/pxr/imaging/hgiInterop/opengl.cpp
@@ -93,6 +93,7 @@ HgiInteropOpenGL::HgiInteropOpenGL()
     , _fsDepth(0)
     , _prgNoDepth(0)
     , _prgDepth(0)
+    , _vao(0)
     , _vertexBuffer(0)
 {
     _vs = _CompileShader(_vertexFullscreen120, GL_VERTEX_SHADER);
@@ -100,6 +101,7 @@ HgiInteropOpenGL::HgiInteropOpenGL()
     _fsDepth = _CompileShader(_fragmentDepthFullscreen120, GL_FRAGMENT_SHADER);
     _prgNoDepth = _LinkProgram(_vs, _fsNoDepth);
     _prgDepth = _LinkProgram(_vs, _fsDepth);
+    glCreateVertexArrays(1, &_vao);
     _vertexBuffer = _CreateVertexBuffer();
     TF_VERIFY(glGetError() == GL_NO_ERROR);
 }
@@ -112,6 +114,7 @@ HgiInteropOpenGL::~HgiInteropOpenGL()
     glDeleteProgram(_prgNoDepth);
     glDeleteProgram(_prgDepth);
     glDeleteBuffers(1, &_vertexBuffer);
+    glDeleteVertexArrays(1, &_vao);
     TF_VERIFY(glGetError() == GL_NO_ERROR);
 }
 
@@ -185,10 +188,13 @@ HgiInteropOpenGL::CompositeToInterop(
     }
 
     // Get the current array buffer binding state
+    GLint restoreVao = 0;
+    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &restoreVao);
     GLint restoreArrayBuffer = 0;
     glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &restoreArrayBuffer);
 
     // Vertex attributes
+    glBindVertexArray(_vao);
     const GLint locPosition = glGetAttribLocation(prg, "position");
     glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);
     glVertexAttribPointer(locPosition, 4, GL_FLOAT, GL_FALSE,
@@ -254,6 +260,7 @@ HgiInteropOpenGL::CompositeToInterop(
     glDisableVertexAttribArray(locPosition);
     glDisableVertexAttribArray(locUv);
     glBindBuffer(GL_ARRAY_BUFFER, restoreArrayBuffer);
+    glBindVertexArray(restoreVao);
     
     if (!blendEnabled) {
         glDisable(GL_BLEND);
diff --git a/pxr/imaging/hgiInterop/opengl.h b/pxr/imaging/hgiInterop/opengl.h
index b0dd64a71..5cd1bad95 100644
--- a/pxr/imaging/hgiInterop/opengl.h
+++ b/pxr/imaging/hgiInterop/opengl.h
@@ -45,6 +45,7 @@ private:
     uint32_t _fsDepth;
     uint32_t _prgNoDepth;
     uint32_t _prgDepth;
+    uint32_t _vao;
     uint32_t _vertexBuffer;
 };
 
