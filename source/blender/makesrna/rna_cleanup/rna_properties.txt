NOTE * CLASS.FROM -> TO:   TYPE  "DESCRIPTION"
+ * ActionGroup.channels -> channels:   collection,  "(read-only)    F-Curves in this group"
+ * ActionGroup.custom_color -> custom_color:   int  "Index of custom color set"
+ * ActionGroup.lock -> lock:   boolean  "Action Group is locked"
+ * ActionGroup.name -> name:   string  "NO DESCRIPTION"
+ * ActionGroup.select -> select:   boolean  "Action Group is selected"
+ * ActionGroup.expanded -> show_expanded:   boolean  "Action Group is expanded"
+ * Actuator.name -> name:   string  "NO DESCRIPTION"
+ * Actuator.pinned -> pin:   boolean  "Display when not linked to a visible states controller"
+ * Actuator.expanded -> show_expanded:   boolean  "Set actuator expanded in the user interface"
+ * Actuator.type -> type:   enum  "NO DESCRIPTION"
+ * Actuator|ActionActuator.action -> action:   pointer  "NO DESCRIPTION"
+ * Actuator|ActionActuator.blendin -> frame_blend_in:   int  "Number of frames of motion blending"
+ * Actuator|ActionActuator.frame_end -> frame_end:   int  "NO DESCRIPTION"
+ * Actuator|ActionActuator.frame_property -> frame_property:   string  "Assign the actions current frame number to this property"
+ * Actuator|ActionActuator.frame_start -> frame_start:   int  "NO DESCRIPTION"
+ * Actuator|ActionActuator.mode -> play_mode:   enum  "Action playback type"
+ * Actuator|ActionActuator.priority -> priority:   int  "Execution priority - lower numbers will override actions with higher numbers. With 2 or more actions at once, the overriding channels must be lower in the stack"
+ * Actuator|ActionActuator.property -> property:   string  "Use this property to define the Action position"
+ * Actuator|ActionActuator.continue_last_frame -> use_continue_last_frame:   boolean  "Restore last frame when switching on/off, otherwise play from the start each time"
+ * Actuator|ArmatureActuator.bone -> bone:   string  "Bone on which the constraint is defined"
+ * Actuator|ArmatureActuator.constraint -> constraint:   string  "Name of the constraint you want to control"
+ * Actuator|ArmatureActuator.mode -> mode:   enum  "NO DESCRIPTION"
+ * Actuator|ArmatureActuator.secondary_target -> secondary_target:   pointer  "Set weight of this constraint"
+ * Actuator|ArmatureActuator.target -> target:   pointer  "Set this object as the target of the constraint"
+ * Actuator|ArmatureActuator.weight -> weight:   float  "Set weight of this constraint"
+ * Actuator|CameraActuator.axis -> axis:   enum  "Specify the axis the Camera will try to get behind"
+ * Actuator|CameraActuator.height -> height:   float  "NO DESCRIPTION"
+ * Actuator|CameraActuator.max -> max:   float  "NO DESCRIPTION"
+ * Actuator|CameraActuator.min -> min:   float  "NO DESCRIPTION"
+ * Actuator|CameraActuator.object -> object:   pointer  "Look at this Object"
+ * Actuator|ConstraintActuator.max_angle -> angle_max:   float  "Maximum angle (in degree) allowed with target direction. No correction is done if angle with target direction is between min and max"
+ * Actuator|ConstraintActuator.min_angle -> angle_min:   float  "Minimum angle (in degree) to maintain with target direction. No correction is done if angle with target direction is between min and max"
+ * Actuator|ConstraintActuator.damping -> damping:   int  "Damping factor: time constant (in frame) of low pass filter"
+ * Actuator|ConstraintActuator.damping_rotation -> damping_rotation:   int  "Use a different damping for orientation"
+ * Actuator|ConstraintActuator.direction -> direction:   enum  "Set the direction of the ray"
+ * Actuator|ConstraintActuator.direction_axis -> direction_axis:   enum  "Select the axis to be aligned along the reference direction"
+ * Actuator|ConstraintActuator.distance -> distance:   float  "Set the maximum length of ray"
+ * Actuator|ConstraintActuator.fh_damping -> fh_damping:   float  "Damping factor of the Fh spring force"
+ * Actuator|ConstraintActuator.fh_height -> fh_height:   float  "Height of the Fh area"
+ * Actuator|ConstraintActuator.limit -> limit:   enum  "NO DESCRIPTION"
+ * Actuator|ConstraintActuator.limit_max -> limit_max:   float  "NO DESCRIPTION"
+ * Actuator|ConstraintActuator.limit_min -> limit_min:   float  "NO DESCRIPTION"
+ * Actuator|ConstraintActuator.material -> material:   string  "Ray detects only Objects with this material"
+ * Actuator|ConstraintActuator.mode -> mode:   enum  "The type of the constraint"
+ * Actuator|ConstraintActuator.property -> property:   string  "Ray detect only Objects with this property"
+ * Actuator|ConstraintActuator.range -> range:   float  "Set the maximum length of ray"
+ * Actuator|ConstraintActuator.max_rotation -> rotation_max:   float[3]  "Reference Direction"
+ * Actuator|ConstraintActuator.spring -> spring:   float  "Spring force within the Fh area"
+ * Actuator|ConstraintActuator.time -> time:   int  "Maximum activation time in frame, 0 for unlimited"
+ * Actuator|ConstraintActuator.fh_normal -> use_fh_normal:   boolean  "Add a horizontal spring force on slopes"
+ * Actuator|ConstraintActuator.fh_paralel_axis -> use_fh_paralel_axis:   boolean  "Keep object axis parallel to normal"
+ * Actuator|ConstraintActuator.force_distance -> use_force_distance:   boolean  "Force distance of object to point of impact of ray"
+ * Actuator|ConstraintActuator.local -> use_local:   boolean  "Set ray along objects axis or global axis"
+ * Actuator|ConstraintActuator.detect_material -> use_material_detect:   boolean  "Detect material instead of property"
+ * Actuator|ConstraintActuator.normal -> use_normal:   boolean  "Set object axis along (local axis) or parallel (global axis) to the normal at hit position"
+ * Actuator|ConstraintActuator.persistent -> use_persistent:   boolean  "Persistent actuator: stays active even if ray does not reach target"
+ * Actuator|EditObjectActuator.angular_velocity -> angular_velocity:   float[3]  "Angular velocity upon creation"
+ * Actuator|EditObjectActuator.dynamic_operation -> dynamic_operation:   enum  "NO DESCRIPTION"
+ * Actuator|EditObjectActuator.linear_velocity -> linear_velocity:   float[3]  "Velocity upon creation"
+ * Actuator|EditObjectActuator.mass -> mass:   float  "The mass of the object"
+ * Actuator|EditObjectActuator.mesh -> mesh:   pointer  "Replace the existing, when left blank Phys will remake the existing physics mesh"
+ * Actuator|EditObjectActuator.mode -> mode:   enum  "The mode of the actuator"
+ * Actuator|EditObjectActuator.object -> object:   pointer  "Add this Object and all its children (cant be on an visible layer)"
+ * Actuator|EditObjectActuator.time -> time:   int  "Duration the new Object lives or the track takes"
+ * Actuator|EditObjectActuator.track_object -> track_object:   pointer  "Track to this Object"
+ * Actuator|EditObjectActuator.enable_3d_tracking -> use_3d_tracking:   boolean  "Enable 3D tracking"
+ * Actuator|EditObjectActuator.local_angular_velocity -> use_local_angular_velocity:   boolean  "Apply the rotation locally"
+ * Actuator|EditObjectActuator.local_linear_velocity -> use_local_linear_velocity:   boolean  "Apply the transformation locally"
+ * Actuator|EditObjectActuator.replace_display_mesh -> use_replace_display_mesh:   boolean  "Replace the display mesh"
+ * Actuator|EditObjectActuator.replace_physics_mesh -> use_replace_physics_mesh:   boolean  "Replace the physics mesh (triangle bounds only - compound shapes not supported)"
+ * Actuator|FcurveActuator.child -> apply_to_children:   boolean  "Update F-Curve on all children Objects as well"
+ * Actuator|FcurveActuator.frame_end -> frame_end:   int  "NO DESCRIPTION"
+ * Actuator|FcurveActuator.frame_property -> frame_property:   string  "Assign the actions current frame number to this property"
+ * Actuator|FcurveActuator.frame_start -> frame_start:   int  "NO DESCRIPTION"
+ * Actuator|FcurveActuator.play_type -> play_type:   enum  "Specify the way you want to play the animation"
+ * Actuator|FcurveActuator.property -> property:   string  "Use this property to define the F-Curve position"
+ * Actuator|FcurveActuator.add -> use_additive:   boolean  "F-Curve is added to the current loc/rot/scale in global or local coordinate according to Local flag"
+ * Actuator|FcurveActuator.force -> use_force:   boolean  "Apply F-Curve as a global or local force depending on the local option (dynamic objects only)"
+ * Actuator|FcurveActuator.local -> use_local:   boolean  "Let the F-Curve act in local coordinates, used in Force and Add mode"
+ * Actuator|Filter2DActuator.filter_pass -> filter_pass:   int  "Set filter order"
+ * Actuator|Filter2DActuator.glsl_shader -> glsl_shader:   pointer  "NO DESCRIPTION"
+ * Actuator|Filter2DActuator.mode -> mode:   enum  "NO DESCRIPTION"
+ * Actuator|Filter2DActuator.motion_blur_factor -> motion_blur_factor:   float  "Set motion blur factor"
+ * Actuator|Filter2DActuator.enable_motion_blur -> use_motion_blur:   boolean  "Enable/Disable Motion Blur"
+ * Actuator|GameActuator.filename -> filename:   string  "Load this blend file, use the // prefix for a path relative to the current blend file"
+ * Actuator|GameActuator.mode -> mode:   enum  "NO DESCRIPTION"
+ * Actuator|MessageActuator.body_message -> body_message:   string  "Optional message body Text"
+ * Actuator|MessageActuator.body_property -> body_property:   string  "The message body will be set by the Property Value"
+ * Actuator|MessageActuator.body_type -> body_type:   enum  "Toggle message type: either Text or a PropertyName"
+ * Actuator|MessageActuator.subject -> subject:   string  "Optional message subject. This is what can be filtered on"
+ * Actuator|MessageActuator.to_property -> to_property:   string  "Optional send message to objects with this name only, or empty to broadcast"
+ * Actuator|ObjectActuator.angular_velocity -> angular_velocity:   float[3]  "Sets the angular velocity"
+ * Actuator|ObjectActuator.damping -> damping:   int  "Number of frames to reach the target velocity"
+ * Actuator|ObjectActuator.derivate_coefficient -> derivate_coefficient:   float  "Not required, high values can cause instability"
+ * Actuator|ObjectActuator.force -> force:   float[3]  "Sets the force"
+ * Actuator|ObjectActuator.force_max_x -> force_max_x:   float  "Set the upper limit for force"
+ * Actuator|ObjectActuator.force_max_y -> force_max_y:   float  "Set the upper limit for force"
+ * Actuator|ObjectActuator.force_max_z -> force_max_z:   float  "Set the upper limit for force"
+ * Actuator|ObjectActuator.force_min_x -> force_min_x:   float  "Set the lower limit for force"
+ * Actuator|ObjectActuator.force_min_y -> force_min_y:   float  "Set the lower limit for force"
+ * Actuator|ObjectActuator.force_min_z -> force_min_z:   float  "Set the lower limit for force"
+ * Actuator|ObjectActuator.integral_coefficient -> integral_coefficient:   float  "Low value (0.01) for slow response, high value (0.5) for fast response"
+ * Actuator|ObjectActuator.linear_velocity -> linear_velocity:   float[3]  "Sets the linear velocity (in Servo mode it sets the target relative linear velocity, it will be achieved by automatic application of force. Null velocity is a valid target)"
+ * Actuator|ObjectActuator.mode -> mode:   enum  "Specify the motion system"
+ * Actuator|ObjectActuator.loc -> offset_location:   float[3]  "Sets the location"
+ * Actuator|ObjectActuator.rot -> offset_rotation:   float[3]  "Sets the rotation"
+ * Actuator|ObjectActuator.proportional_coefficient -> proportional_coefficient:   float  "Typical value is 60x integral coefficient"
+ * Actuator|ObjectActuator.reference_object -> reference_object:   pointer  "Reference object for velocity calculation, leave empty for world reference"
+ * Actuator|ObjectActuator.torque -> torque:   float[3]  "Sets the torque"
+ * Actuator|ObjectActuator.add_linear_velocity -> use_add_linear_velocity:   boolean  "Toggles between ADD and SET linV"
+ * Actuator|ObjectActuator.local_angular_velocity -> use_local_angular_velocity:   boolean  "Angular velocity is defined in local coordinates"
+ * Actuator|ObjectActuator.local_force -> use_local_force:   boolean  "Force is defined in local coordinates"
+ * Actuator|ObjectActuator.local_linear_velocity -> use_local_linear_velocity:   boolean  "Velocity is defined in local coordinates"
+ * Actuator|ObjectActuator.local_location -> use_local_location:   boolean  "Location is defined in local coordinates"
+ * Actuator|ObjectActuator.local_rotation -> use_local_rotation:   boolean  "Rotation is defined in local coordinates"
+ * Actuator|ObjectActuator.local_torque -> use_local_torque:   boolean  "Torque is defined in local coordinates"
+ * Actuator|ObjectActuator.servo_limit_x -> use_servo_limit_x:   boolean  "Set limit to force along the X axis"
+ * Actuator|ObjectActuator.servo_limit_y -> use_servo_limit_y:   boolean  "Set limit to force along the Y axis"
+ * Actuator|ObjectActuator.servo_limit_z -> use_servo_limit_z:   boolean  "Set limit to force along the Z axis"
+ * Actuator|ParentActuator.mode -> mode:   enum  "NO DESCRIPTION"
+ * Actuator|ParentActuator.object -> object:   pointer  "Set this object as parent"
+ * Actuator|ParentActuator.compound -> use_compound:   boolean  "Add this object shape to the parent shape (only if the parent shape is already compound)"
+ * Actuator|ParentActuator.ghost -> use_ghost:   boolean  "Make this object ghost while parented (only if not compound)"
+ * Actuator|PropertyActuator.mode -> mode:   enum  "NO DESCRIPTION"
+ * Actuator|PropertyActuator.object -> object:   pointer  "Copy from this Object"
+ * Actuator|PropertyActuator.object_property -> object_property:   string  "Copy this property"
+ * Actuator|PropertyActuator.property -> property:   string  "The name of the property"
+ * Actuator|PropertyActuator.value -> value:   string  "The value to use, use  around strings"
+ * Actuator|RandomActuator.chance -> chance:   float  "Pick a number between 0 and 1. Success if you stay below this value"
+ * Actuator|RandomActuator.distribution -> distribution:   enum  "Choose the type of distribution"
+ * Actuator|RandomActuator.float_max -> float_max:   float  "Choose a number from a range. Upper boundary of the range"
+ * Actuator|RandomActuator.float_mean -> float_mean:   float  "A normal distribution. Mean of the distribution"
+ * Actuator|RandomActuator.float_min -> float_min:   float  "Choose a number from a range. Lower boundary of the range"
+ * Actuator|RandomActuator.float_value -> float_value:   float  "Always return this number"
+ * Actuator|RandomActuator.half_life_time -> half_life_time:   float  "Negative exponential dropoff"
+ * Actuator|RandomActuator.int_max -> int_max:   int  "Choose a number from a range. Upper boundary of the range"
+ * Actuator|RandomActuator.int_mean -> int_mean:   float  "Expected mean value of the distribution"
+ * Actuator|RandomActuator.int_min -> int_min:   int  "Choose a number from a range. Lower boundary of the range"
+ * Actuator|RandomActuator.int_value -> int_value:   int  "Always return this number"
+ * Actuator|RandomActuator.property -> property:   string  "Assign the random value to this property"
+ * Actuator|RandomActuator.seed -> seed:   int  "Initial seed of the random generator. Use Python for more freedom (choose 0 for not random)"
+ * Actuator|RandomActuator.standard_derivation -> standard_derivation:   float  "A normal distribution. Standard deviation of the distribution"
+ * Actuator|RandomActuator.always_true -> use_always_true:   boolean  "Always false or always true"
+ * Actuator|SceneActuator.camera -> camera:   pointer  "Set this Camera. Leave empty to refer to self object"
+ * Actuator|SceneActuator.mode -> mode:   enum  "NO DESCRIPTION"
+ * Actuator|SceneActuator.scene -> scene:   pointer  "Set the Scene to be added/removed/paused/resumed"
+ * Actuator|ShapeActionActuator.action -> action:   pointer  "NO DESCRIPTION"
+ * Actuator|ShapeActionActuator.blendin -> frame_blend_in:   int  "Number of frames of motion blending"
+ * Actuator|ShapeActionActuator.frame_end -> frame_end:   int  "NO DESCRIPTION"
+ * Actuator|ShapeActionActuator.frame_property -> frame_property:   string  "Assign the actions current frame number to this property"
+ * Actuator|ShapeActionActuator.frame_start -> frame_start:   int  "NO DESCRIPTION"
+ * Actuator|ShapeActionActuator.mode -> mode:   enum  "Action playback type"
+ * Actuator|ShapeActionActuator.priority -> priority:   int  "Execution priority - lower numbers will override actions with higher numbers. With 2 or more actions at once, the overriding channels must be lower in the stack"
+ * Actuator|ShapeActionActuator.property -> property:   string  "Use this property to define the Action position"
+ * Actuator|ShapeActionActuator.continue_last_frame -> use_continue_last_frame:   boolean  "Restore last frame when switching on/off, otherwise play from the start each time"
+ * Actuator|SoundActuator.cone_inner_angle_3d -> cone_inner_angle_3d:   float  "The angle of the inner cone"
+ * Actuator|SoundActuator.cone_outer_angle_3d -> cone_outer_angle_3d:   float  "The angle of the outer cone"
+ * Actuator|SoundActuator.cone_outer_gain_3d -> cone_outer_gain_3d:   float  "The gain outside the outer cone. The gain in the outer cone will be interpolated between this value and the normal gain in the inner cone"
+ * Actuator|SoundActuator.max_distance_3d -> distance_3d_max:   float  "The maximum distance at which you can hear the sound"
+ * Actuator|SoundActuator.reference_distance_3d -> distance_rest_3d:   float  "The distance where the sound has a gain of 1.0"
+ * Actuator|SoundActuator.maximum_gain_3d -> gain_3d_max:   float  "The maximum gain of the sound, no matter how near it is"
+ * Actuator|SoundActuator.minimum_gain_3d -> gain_3d_min:   float  "The minimum gain of the sound, no matter how far it is away"
+ * Actuator|SoundActuator.mode -> mode:   enum  "NO DESCRIPTION"
+ * Actuator|SoundActuator.pitch -> pitch:   float  "Sets the pitch of the sound"
+ * Actuator|SoundActuator.rolloff_factor_3d -> rolloff_factor_3d:   float  "The influence factor on volume depending on distance"
+ * Actuator|SoundActuator.sound -> sound:   pointer  "NO DESCRIPTION"
+ * Actuator|SoundActuator.enable_sound_3d -> use_sound_3d:   boolean  "Enable/Disable 3D Sound"
+ * Actuator|SoundActuator.volume -> volume:   float  "Sets the initial volume of the sound"
+ * Actuator|StateActuator.operation -> operation:   enum  "Select the bit operation on object state mask"
+ * Actuator|StateActuator.state -> states:   boolean[30]  "NO DESCRIPTION"
+ * Actuator|VisibilityActuator.children -> apply_to_children:   boolean  "Set all the children of this object to the same visibility/occlusion recursively"
+ * Actuator|VisibilityActuator.occlusion -> use_occlusion:   boolean  "Set the object to occlude objects behind it. Initialized from the object type in physics button"
+ * Actuator|VisibilityActuator.visible -> use_visible:   boolean  "Set the objects visible. Initialized from the objects render restriction toggle (access in the outliner)"
+ * Addon.module -> module:   string  "Module name"
+ * AnimData.action -> action:   pointer  "Active Action for this datablock"
+ * AnimData.action_blending -> action_blend_type:   enum  "Method used for combining Active Actions result with result of NLA stack"
+ * AnimData.action_extrapolation -> action_extrapolation:   enum  "Action to take for gaps past the Active Actions range (when evaluating with NLA)"
+ * AnimData.action_influence -> action_influence:   float  "Amount the Active Action contributes to the result of the NLA stack"
+ * AnimData.drivers -> drivers:   collection,  "(read-only)    The Drivers/Expressions for this datablock"
+ * AnimData.nla_tracks -> nla_tracks:   collection,  "(read-only)    NLA Tracks (i.e. Animation Layers)"
+ * AnimData.nla_enabled -> use_nla:   boolean  "NLA stack is evaluated when evaluating this block"
+ * AnimViz.motion_paths -> motion_path:   pointer,  "(read-only)    Motion Path settings for visualisation"
+ * AnimViz.onion_skinning -> onion_skin_frames:   pointer,  "(read-only)    Onion Skinning (ghosting) settings for visualisation"
+ * AnimVizMotionPaths.bake_location -> bake_location:   enum  "When calculating Bone Paths, use Head or Tips"
+ * AnimVizMotionPaths.after_current -> frame_after:   int  "Number of frames to show after the current frame (only for Around Current Frame Onion-skinning method)"
+ * AnimVizMotionPaths.before_current -> frame_before:   int  "Number of frames to show before the current frame (only for Around Current Frame Onion-skinning method)"
+ * AnimVizMotionPaths.frame_end -> frame_end:   int  "End frame of range of paths to display/calculate (not for Around Current Frame Onion-skinning method)"
+ * AnimVizMotionPaths.frame_start -> frame_start:   int  "Starting frame of range of paths to display/calculate (not for Around Current Frame Onion-skinning method)"
+ * AnimVizMotionPaths.frame_step -> frame_step:   int  "Number of frames between paths shown (not for On Keyframes Onion-skinning method)"
+ * AnimVizMotionPaths.show_frame_numbers -> show_frame_numbers:   boolean  "Show frame numbers on Motion Paths"
+ * AnimVizMotionPaths.search_all_action_keyframes -> show_keyframe_action_all:   boolean  "For bone motion paths, search whole Action for keyframes instead of in group with matching name only (is slower)"
+ * AnimVizMotionPaths.highlight_keyframes -> show_keyframe_highlight:   boolean  "Emphasize position of keyframes on Motion Paths"
+ * AnimVizMotionPaths.show_keyframe_numbers -> show_keyframe_numbers:   boolean  "Show frame numbers of Keyframes on Motion Paths"
+ * AnimVizMotionPaths.type -> type:   enum  "Type of range to show for Motion Paths"
+ * AnimVizOnionSkinning.after_current -> frame_after:   int  "Number of frames to show after the current frame (only for Around Current Frame Onion-skinning method)"
+ * AnimVizOnionSkinning.before_current -> frame_before:   int  "Number of frames to show before the current frame (only for Around Current Frame Onion-skinning method)"
+ * AnimVizOnionSkinning.frame_end -> frame_end:   int  "End frame of range of Ghosts to display (not for Around Current Frame Onion-skinning method)"
+ * AnimVizOnionSkinning.frame_start -> frame_start:   int  "Starting frame of range of Ghosts to display (not for Around Current Frame Onion-skinning method)"
+ * AnimVizOnionSkinning.frame_step -> frame_step:   int  "Number of frames between ghosts shown (not for On Keyframes Onion-skinning method)"
+ * AnimVizOnionSkinning.only_selected -> show_only_selected:   boolean  "For Pose-Mode drawing, only draw ghosts for selected bones"
+ * AnimVizOnionSkinning.type -> type:   enum  "Method used for determining what ghosts get drawn"
MAKE PROPERTY OF A COLLECTION * Area.active_space -> active_space:   pointer,  "(read-only)    Space currently being displayed in this area"
+ * Area.regions -> regions:   collection,  "(read-only)    Regions this area is subdivided in"
+ * Area.show_menus -> show_menus:   boolean  "Show menus in the header"
+ * Area.spaces -> spaces:   collection,  "(read-only)    Spaces contained in this area, the first space is active"
+ * Area.type -> type:   enum  "Space type"
+ * ArmatureBones.active -> active:   pointer  "Armatures active bone"
+ * ArmatureEditBones.active -> active:   pointer  "Armatures active edit bone"
+ * BackgroundImage.image -> image:   pointer  "Image displayed and edited in this space"
+ * BackgroundImage.image_user -> image_user:   pointer,  "(read-only)    Parameters defining which layer, pass and frame of the image is displayed"
+ * BackgroundImage.offset_x -> offset_x:   float  "Offsets image horizontally from the world origin"
+ * BackgroundImage.offset_y -> offset_y:   float  "Offsets image vertically from the world origin"
+ * BackgroundImage.show_expanded -> show_expanded:   boolean  "Show the expanded in the user interface"
+ * BackgroundImage.size -> size:   float  "Scaling factor for the background image"
+ * BackgroundImage.transparency -> transparency:   float  "Amount to blend the image against the background color"
+ * BackgroundImage.view_axis -> view_axis:   enum  "The axis to display the image on"
+ * BezierSplinePoint.co -> co:   float[3]  "Coordinates of the control point"
+ * BezierSplinePoint.handle1 -> handle_left:   float[3]  "Coordinates of the first handle"
+ * BezierSplinePoint.handle1_type -> handle_left_type:   enum  "Handle types"
+ * BezierSplinePoint.handle2 -> handle_right:   float[3]  "Coordinates of the second handle"
+ * BezierSplinePoint.handle2_type -> handle_right_type:   enum  "Handle types"
+ * BezierSplinePoint.hide -> hide:   boolean  "Visibility status"
+ * BezierSplinePoint.radius -> radius:   float,  "(read-only)    Radius for bevelling"
+ * BezierSplinePoint.select_control_point -> select_control_point:   boolean  "Control point selection status"
+ * BezierSplinePoint.select_left_handle -> select_left_handle:   boolean  "Handle 1 selection status"
+ * BezierSplinePoint.select_right_handle -> select_right_handle:   boolean  "Handle 2 selection status"
+ * BezierSplinePoint.tilt -> tilt:   float  "Tilt in 3D View"
+ * BezierSplinePoint.weight -> weight:   float  "Softbody goal weight"
+ * BlenderRNA.structs -> structs:   collection,  "(read-only)"
+ * BoidRule.name -> name:   string  "Boid rule name"
+ * BoidRule.type -> type:   enum,  "(read-only)"
+ * BoidRule.in_air -> use_in_air:   boolean  "Use rule when boid is flying"
+ * BoidRule.on_land -> use_on_land:   boolean  "Use rule when boid is on land"
+ * BoidRule|BoidRuleAverageSpeed.level -> level:   float  "How much velocitys z-component is kept constant"
+ * BoidRule|BoidRuleAverageSpeed.speed -> speed:   float  "Percentage of maximum speed"
+ * BoidRule|BoidRuleAverageSpeed.wander -> wander:   float  "How fast velocitys direction is randomized"
+ * BoidRule|BoidRuleAvoid.fear_factor -> fear_factor:   float  "Avoid object if danger from it is above this threshold"
+ * BoidRule|BoidRuleAvoid.object -> object:   pointer  "Object to avoid"
+ * BoidRule|BoidRuleAvoid.predict -> use_predict:   boolean  "Predict target movement"
+ * BoidRule|BoidRuleAvoidCollision.look_ahead -> look_ahead:   float  "Time to look ahead in seconds"
+ * BoidRule|BoidRuleAvoidCollision.boids -> use_avoid:   boolean  "Avoid collision with other boids"
+ * BoidRule|BoidRuleAvoidCollision.deflectors -> use_avoid_collision:   boolean  "Avoid collision with deflector objects"
+ * BoidRule|BoidRuleFight.distance -> distance:   float  "Attack boids at max this distance"
+ * BoidRule|BoidRuleFight.flee_distance -> flee_distance:   float  "Flee to this distance"
+ * BoidRule|BoidRuleFollowLeader.distance -> distance:   float  "Distance behind leader to follow"
+ * BoidRule|BoidRuleFollowLeader.object -> object:   pointer  "Follow this object instead of a boid"
+ * BoidRule|BoidRuleFollowLeader.queue_size -> queue_count:   int  "How many boids in a line"
+ * BoidRule|BoidRuleFollowLeader.line -> use_line:   boolean  "Follow leader in a line"
+ * BoidRule|BoidRuleGoal.object -> object:   pointer  "Goal object"
+ * BoidRule|BoidRuleGoal.predict -> use_predict:   boolean  "Predict target movement"
+ * BoidSettings.accuracy -> accuracy:   float  "Accuracy of attack"
+ * BoidSettings.active_boid_state -> active_boid_state:   pointer,  "(read-only)"
+ * BoidSettings.active_boid_state_index -> active_boid_state_index:   int  "NO DESCRIPTION"
+ * BoidSettings.aggression -> aggression:   float  "Boid will fight this times stronger enemy"
+ * BoidSettings.air_max_acc -> air_acc_max:   float  "Maximum acceleration in air (relative to maximum speed)"
+ * BoidSettings.air_max_ave -> air_ave_max:   float  "Maximum angular velocity in air (relative to 180 degrees)"
+ * BoidSettings.air_personal_space -> air_personal_space:   float  "Radius of boids personal space in air (% of particle size)"
+ * BoidSettings.air_max_speed -> air_speed_max:   float  "Maximum speed in air"
+ * BoidSettings.air_min_speed -> air_speed_min:   float  "Minimum speed in air (relative to maximum speed)"
+ * BoidSettings.banking -> bank:   float  "Amount of rotation around velocity vector on turns"
+ * BoidSettings.health -> health:   float  "Initial boid health when born"
+ * BoidSettings.height -> height:   float  "Boid height relative to particle size"
+ * BoidSettings.land_max_acc -> land_acc_max:   float  "Maximum acceleration on land (relative to maximum speed)"
+ * BoidSettings.land_max_ave -> land_ave_max:   float  "Maximum angular velocity on land (relative to 180 degrees)"
+ * BoidSettings.land_jump_speed -> land_jump_speed:   float  "Maximum speed for jumping"
+ * BoidSettings.land_personal_space -> land_personal_space:   float  "Radius of boids personal space on land (% of particle size)"
+ * BoidSettings.landing_smoothness -> land_smooth:   float  "How smoothly the boids land"
+ * BoidSettings.land_max_speed -> land_speed_max:   float  "Maximum speed on land"
+ * BoidSettings.land_stick_force -> land_stick_force:   float  "How strong a force must be to start effecting a boid on land"
+ * BoidSettings.range -> range:   float  "The maximum distance from which a boid can attack"
+ * BoidSettings.states -> states:   collection,  "(read-only)"
+ * BoidSettings.strength -> strength:   float  "Maximum caused damage on attack per second"
+ * BoidSettings.allow_climb -> use_climb:   boolean  "Allow boids to climb goal objects"
+ * BoidSettings.allow_flight -> use_flight:   boolean  "Allow boids to move in air"
+ * BoidSettings.allow_land -> use_land:   boolean  "Allow boids to move on land"
+ * BoidState.active_boid_rule -> active_boid_rule:   pointer,  "(read-only)"
+ * BoidState.active_boid_rule_index -> active_boid_rule_index:   int  "NO DESCRIPTION"
+ * BoidState.falloff -> falloff:   float  "NO DESCRIPTION"
+ * BoidState.name -> name:   string  "Boid state name"
+ * BoidState.rule_fuzziness -> rule_fuzzy:   float  "NO DESCRIPTION"
+ * BoidState.rules -> rules:   collection,  "(read-only)"
+ * BoidState.ruleset_type -> ruleset_type:   enum  "How the rules in the list are evaluated"
+ * BoidState.volume -> volume:   float  "NO DESCRIPTION"
+ * Bone.bbone_in -> bbone_in:   float  "Length of first Bezier Handle (for B-Bones only)"
+ * Bone.bbone_out -> bbone_out:   float  "Length of second Bezier Handle (for B-Bones only)"
+ * Bone.bbone_segments -> bbone_segments:   int  "Number of subdivisions of bone (for B-Bones only)"
+ * Bone.children -> children:   collection,  "(read-only)    Bones which are children of this bone"
+ * Bone.envelope_distance -> envelope_distance:   float  "Bone deformation distance (for Envelope deform only)"
+ * Bone.envelope_weight -> envelope_weight:   float  "Bone deformation weight (for Envelope deform only)"
+ * Bone.head -> head:   float[3]  "Location of head end of the bone relative to its parent"
+ * Bone.head_local -> head_local:   float[3]  "Location of head end of the bone relative to armature"
+ * Bone.head_radius -> head_radius:   float  "Radius of head of bone (for Envelope deform only)"
+ * Bone.hide -> hide:   boolean  "Bone is not visible when it is not in Edit Mode (i.e. in Object or Pose Modes)"
+ * Bone.hide_select -> hide_select:   boolean  "Bone is able to be selected"
+ * Bone.layer -> layers:   boolean[32]  "Layers bone exists in"
+ * Bone.matrix -> matrix:   float[9]  "3x3 bone matrix"
+ * Bone.matrix_local -> matrix_local:   float[16]  "4x4 bone matrix relative to armature"
+ * Bone.name -> name:   string  "NO DESCRIPTION"
+ * Bone.parent -> parent:   pointer,  "(read-only)    Parent bone (in same Armature)"
+ * Bone.select -> select:   boolean  "NO DESCRIPTION"
+ * Bone.draw_wire -> show_wire:   boolean  "Bone is always drawn as Wireframe regardless of viewport draw mode. Useful for non-obstructive custom bone shapes"
+ * Bone.tail -> tail:   float[3]  "Location of tail end of the bone"
+ * Bone.tail_local -> tail_local:   float[3]  "Location of tail end of the bone relative to armature"
+ * Bone.tail_radius -> tail_radius:   float  "Radius of tail of bone (for Envelope deform only)"
+ * Bone.connected -> use_connect:   boolean,  "(read-only)    When bone has a parent, bones head is struck to the parents tail"
+ * Bone.cyclic_offset -> use_cyclic_offset:   boolean  "When bone doesnt have a parent, it receives cyclic offset effects"
+ * Bone.deform -> use_deform:   boolean  "Bone does not deform any geometry"
+ * Bone.multiply_vertexgroup_with_envelope -> use_envelope_multiply:   boolean  "When deforming bone, multiply effects of Vertex Group weights with Envelope influence"
+ * Bone.hinge -> use_hinge:   boolean  "Bone inherits rotation or scale from parent bone"
+ * Bone.inherit_scale -> use_inherit_scale:   boolean  "Bone inherits scaling from parent bone"
+ * Bone.local_location -> use_local_location:   boolean  "Bone location is set in local space"
+ * BoneGroup.color_set -> color_set:   enum  "Custom color set to use"
+ * BoneGroup.colors -> colors:   pointer,  "(read-only)    Copy of the colors associated with the groups color set"
+ * BoneGroup.name -> name:   string  "NO DESCRIPTION"
+ * ClothCollisionSettings.collision_quality -> collision_quality:   int  "How many collision iterations should be done. (higher is better quality but slower)"
+ * ClothCollisionSettings.min_distance -> distance_min:   float  "Minimum distance between collision objects before collision response takes in"
+ * ClothCollisionSettings.friction -> friction:   float  "Friction force if a collision happened. (higher = less movement)"
+ * ClothCollisionSettings.group -> group:   pointer  "Limit colliders to this Group"
+ * ClothCollisionSettings.self_collision_quality -> self_collision_quality:   int  "How many self collision iterations should be done. (higher is better quality but slower)"
+ * ClothCollisionSettings.self_min_distance -> self_distance_min:   float  "0.5 means no distance at all, 1.0 is maximum distance"
+ * ClothCollisionSettings.self_friction -> self_friction:   float  "Friction/damping with self contact"
+ * ClothCollisionSettings.enable_collision -> use_collision:   boolean  "Enable collisions with other objects"
+ * ClothCollisionSettings.enable_self_collision -> use_self_collision:   boolean  "Enable self collisions"
+ * ClothSettings.air_damping -> air_damping:   float  "Air has normally some thickness which slows falling things down"
+ * ClothSettings.bending_stiffness -> bending_stiffness:   float  "Wrinkle coefficient. (higher = less smaller but more big wrinkles)"
+ * ClothSettings.bending_stiffness_max -> bending_stiffness_max:   float  "Maximum bending stiffness value"
+ * ClothSettings.bending_vertex_group -> bending_vertex_group:   string  "Vertex group for fine control over bending stiffness"
+ * ClothSettings.collider_friction -> collider_friction:   float  "NO DESCRIPTION"
+ * ClothSettings.effector_weights -> effector_weights:   pointer,  "(read-only)"
+ * ClothSettings.goal_default -> goal_default:   float  "Default Goal (vertex target position) value, when no Vertex Group used"
+ * ClothSettings.goal_friction -> goal_friction:   float  "Goal (vertex target position) friction"
+ * ClothSettings.goal_max -> goal_max:   float  "Goal maximum, vertex group weights are scaled to match this range"
+ * ClothSettings.goal_min -> goal_min:   float  "Goal minimum, vertex group weights are scaled to match this range"
+ * ClothSettings.goal_spring -> goal_spring:   float  "Goal (vertex target position) spring stiffness"
+ * ClothSettings.gravity -> gravity:   float[3]  "Gravity or external force vector"
+ * ClothSettings.internal_friction -> internal_friction:   float  "NO DESCRIPTION"
+ * ClothSettings.mass -> mass:   float  "Mass of cloth material"
+ * ClothSettings.mass_vertex_group -> mass_vertex_group:   string  "Vertex Group for pinning of vertices"
+ * ClothSettings.pin_stiffness -> pin_stiffness:   float  "Pin (vertex target position) spring stiffness"
+ * ClothSettings.pre_roll -> pre_roll:   int  "Simulation starts on this frame"
+ * ClothSettings.quality -> quality:   int  "Quality of the simulation in steps per frame. (higher is better quality but slower)"
+ * ClothSettings.rest_shape_key -> rest_shape_key:   pointer  "Shape key to use the rest spring lengths from"
+ * ClothSettings.spring_damping -> spring_damping:   float  "Damping of cloth velocity. (higher = more smooth, less jiggling)"
+ * ClothSettings.structural_stiffness -> structural_stiffness:   float  "Overall stiffness of structure"
+ * ClothSettings.structural_stiffness_max -> structural_stiffness_max:   float  "Maximum structural stiffness value"
+ * ClothSettings.structural_stiffness_vertex_group -> structural_stiffness_vertex_group:   string  "Vertex group for fine control over structural stiffness"
+ * ClothSettings.pin_cloth -> use_pin_cloth:   boolean  "Enable pinning of cloth vertices to other objects/positions"
+ * ClothSettings.stiffness_scaling -> use_stiffness_scale:   boolean  "If enabled, stiffness can be scaled along a weight painted vertex group"
+ * CollisionSettings.absorption -> absorption:   float  "How much of effector force gets lost during collision with this object (in percent)"
+ * CollisionSettings.damping -> damping:   float  "Amount of damping during collision"
+ * CollisionSettings.damping_factor -> damping_factor:   float  "Amount of damping during particle collision"
+ * CollisionSettings.random_damping -> damping_random:   float  "Random variation of damping"
+ * CollisionSettings.friction_factor -> friction_factor:   float  "Amount of friction during particle collision"
+ * CollisionSettings.random_friction -> friction_random:   float  "Random variation of friction"
+ * CollisionSettings.permeability -> permeability:   float  "Chance that the particle will pass through the mesh"
+ * CollisionSettings.stickness -> stickness:   float  "Amount of stickness to surface collision"
+ * CollisionSettings.inner_thickness -> thickness_inner:   float  "Inner face thickness"
+ * CollisionSettings.outer_thickness -> thickness_outer:   float  "Outer face thickness"
+ * CollisionSettings.enabled -> use:   boolean  "Enable this objects as a collider for physics systems"
+ * CollisionSettings.kill_particles -> use_particle_kill:   boolean  "Kill collided particles"
+ * ColorRamp.total -> count:   int,  "(read-only)    Total number of elements"
+ * ColorRamp.elements -> elements:   collection,  "(read-only)"
+ * ColorRamp.interpolation -> interpolation:   enum  "NO DESCRIPTION"
+ * ColorRampElement.color -> color:   float[4]  "NO DESCRIPTION"
+ * ColorRampElement.position -> position:   float  "NO DESCRIPTION"
ConsoleLine.body -> body:   string  "Text in the line"
+ * ConsoleLine.current_character -> current_character:   int  "NO DESCRIPTION"
+ * Constraint.active -> active:   boolean  "Constraint is the one being edited"
+ * Constraint.lin_error -> error_location:   float,  "(read-only)    Amount of residual error in Blender space unit for constraints that work on position"
+ * Constraint.rot_error -> error_rotation:   float,  "(read-only)    Amount of residual error in radiant for constraints that work on orientation"
+ * Constraint.influence -> influence:   float  "Amount of influence constraint will have on the final solution"
+ * Constraint.proxy_local -> is_proxy_local:   boolean  "Constraint was added in this proxy instance (i.e. did not belong to source Armature)"
+ * Constraint.disabled -> is_valid:   boolean,  "(read-only)    Constraint has invalid settings and will not be evaluated"
+NEGATE * Constraint.enabled -> mute:   boolean  "Enable/Disable Constraint"
+ * Constraint.name -> name:   string  "Constraint name"
+ * Constraint.owner_space -> owner_space:   enum  "Space that owner is evaluated in"
+ * Constraint.expanded -> show_expanded:   boolean  "Constraints panel is expanded in UI"
+ * Constraint.target_space -> target_space:   enum  "Space that target is evaluated in"
+ * Constraint.type -> type:   enum,  "(read-only)"
+ * ConstraintTarget.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * ConstraintTarget.target -> target:   pointer  "Target Object"
+ * Constraint|ActionConstraint.action -> action:   pointer  "NO DESCRIPTION"
+ * Constraint|ActionConstraint.frame_end -> frame_end:   int  "Last frame of the Action to use"
+ * Constraint|ActionConstraint.frame_start -> frame_start:   int  "First frame of the Action to use"
+ * Constraint|ActionConstraint.maximum -> max:   float  "Maximum value for target channel range"
+ * Constraint|ActionConstraint.minimum -> min:   float  "Minimum value for target channel range"
+ * Constraint|ActionConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|ActionConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|ActionConstraint.transform_channel -> transform_channel:   enum  "Transformation channel from the target that is used to key the Action"
+ * Constraint|ChildOfConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|ChildOfConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|ChildOfConstraint.use_location_x -> use_location_x:   boolean  "Use X Location of Parent"
+ * Constraint|ChildOfConstraint.use_location_y -> use_location_y:   boolean  "Use Y Location of Parent"
+ * Constraint|ChildOfConstraint.use_location_z -> use_location_z:   boolean  "Use Z Location of Parent"
+ * Constraint|ChildOfConstraint.use_rotation_x -> use_rotation_x:   boolean  "Use X Rotation of Parent"
+ * Constraint|ChildOfConstraint.use_rotation_y -> use_rotation_y:   boolean  "Use Y Rotation of Parent"
+ * Constraint|ChildOfConstraint.use_rotation_z -> use_rotation_z:   boolean  "Use Z Rotation of Parent"
+ * Constraint|ChildOfConstraint.use_scale_x -> use_scale_x:   boolean  "Use X Scale of Parent"
+ * Constraint|ChildOfConstraint.use_scale_y -> use_scale_y:   boolean  "Use Y Scale of Parent"
+ * Constraint|ChildOfConstraint.use_scale_z -> use_scale_z:   boolean  "Use Z Scale of Parent"
+ * Constraint|ClampToConstraint.main_axis -> main_axis:   enum  "Main axis of movement"
+ * Constraint|ClampToConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|ClampToConstraint.cyclic -> use_cyclic:   boolean  "Treat curve as cyclic curve (no clamping to curve bounding box"
+ * Constraint|CopyLocationConstraint.head_tail -> head_tail:   float  "Target along length of bone: Head=0, Tail=1"
+ * Constraint|CopyLocationConstraint.invert_x -> invert_x:   boolean  "Invert the X location"
+ * Constraint|CopyLocationConstraint.invert_y -> invert_y:   boolean  "Invert the Y location"
+ * Constraint|CopyLocationConstraint.invert_z -> invert_z:   boolean  "Invert the Z location"
+ * Constraint|CopyLocationConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|CopyLocationConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|CopyLocationConstraint.use_offset -> use_offset:   boolean  "Add original location into copied location"
+ * Constraint|CopyLocationConstraint.use_x -> use_x:   boolean  "Copy the targets X location"
+ * Constraint|CopyLocationConstraint.use_y -> use_y:   boolean  "Copy the targets Y location"
+ * Constraint|CopyLocationConstraint.use_z -> use_z:   boolean  "Copy the targets Z location"
+ * Constraint|CopyRotationConstraint.invert_x -> invert_x:   boolean  "Invert the X rotation"
+ * Constraint|CopyRotationConstraint.invert_y -> invert_y:   boolean  "Invert the Y rotation"
+ * Constraint|CopyRotationConstraint.invert_z -> invert_z:   boolean  "Invert the Z rotation"
+ * Constraint|CopyRotationConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|CopyRotationConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|CopyRotationConstraint.use_offset -> use_offset:   boolean  "Add original rotation into copied rotation"
+ * Constraint|CopyRotationConstraint.use_x -> use_x:   boolean  "Copy the targets X rotation"
+ * Constraint|CopyRotationConstraint.use_y -> use_y:   boolean  "Copy the targets Y rotation"
+ * Constraint|CopyRotationConstraint.use_z -> use_z:   boolean  "Copy the targets Z rotation"
+ * Constraint|CopyScaleConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|CopyScaleConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|CopyScaleConstraint.use_offset -> use_offset:   boolean  "Add original scale into copied scale"
+ * Constraint|CopyScaleConstraint.use_x -> use_x:   boolean  "Copy the targets X scale"
+ * Constraint|CopyScaleConstraint.use_y -> use_y:   boolean  "Copy the targets Y scale"
+ * Constraint|CopyScaleConstraint.use_z -> use_z:   boolean  "Copy the targets Z scale"
+ * Constraint|CopyTransformsConstraint.head_tail -> head_tail:   float  "Target along length of bone: Head=0, Tail=1"
+ * Constraint|CopyTransformsConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|CopyTransformsConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|DampedTrackConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|DampedTrackConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|DampedTrackConstraint.track -> track_axis:   enum  "Axis that points to the target object"
+ * Constraint|FloorConstraint.floor_location -> floor_location:   enum  "Location of target that object will not pass through"
+ * Constraint|FloorConstraint.offset -> offset:   float  "Offset of floor from object origin"
+ * Constraint|FloorConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|FloorConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|FloorConstraint.use_rotation -> use_rotation:   boolean  "Use the targets rotation to determine floor"
+ * Constraint|FloorConstraint.sticky -> use_sticky:   boolean  "Immobilize object while constrained"
+ * Constraint|FollowPathConstraint.forward -> forward_axis:   enum  "Axis that points forward along the path"
+ * Constraint|FollowPathConstraint.offset -> offset:   int  "Offset from the position corresponding to the time frame"
+ * Constraint|FollowPathConstraint.offset_factor -> offset_factor:   float  "Percentage value defining target position along length of bone"
+ * Constraint|FollowPathConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|FollowPathConstraint.up -> up_axis:   enum  "Axis that points upward"
+ * Constraint|FollowPathConstraint.use_curve_follow -> use_curve_follow:   boolean  "Object will follow the heading and banking of the curve"
+ * Constraint|FollowPathConstraint.use_curve_radius -> use_curve_radius:   boolean  "Objects scale by the curve radius"
+ * Constraint|FollowPathConstraint.use_fixed_position -> use_fixed_location:   boolean  "Object will stay locked to a single point somewhere along the length of the curve regardless of time"
+ * Constraint|KinematicConstraint.chain_length -> chain_count:   int  "How many bones are included in the IK effect - 0 uses all bones"
+ * Constraint|KinematicConstraint.distance -> distance:   float  "Radius of limiting sphere"
+ * Constraint|KinematicConstraint.ik_type -> ik_type:   enum  "NO DESCRIPTION"
+ * Constraint|KinematicConstraint.iterations -> iterations:   int  "Maximum number of solving iterations"
+ * Constraint|KinematicConstraint.limit_mode -> limit_mode:   enum  "Distances in relation to sphere of influence to allow"
+ * Constraint|KinematicConstraint.pos_lock_x -> lock_location_x:   boolean  "Constraint position along X axis"
+ * Constraint|KinematicConstraint.pos_lock_y -> lock_location_y:   boolean  "Constraint position along Y axis"
+ * Constraint|KinematicConstraint.pos_lock_z -> lock_location_z:   boolean  "Constraint position along Z axis"
+ * Constraint|KinematicConstraint.rot_lock_x -> lock_rotation_x:   boolean  "Constraint rotation along X axis"
+ * Constraint|KinematicConstraint.rot_lock_y -> lock_rotation_y:   boolean  "Constraint rotation along Y axis"
+ * Constraint|KinematicConstraint.rot_lock_z -> lock_rotation_z:   boolean  "Constraint rotation along Z axis"
+ * Constraint|KinematicConstraint.orient_weight -> orient_weight:   float  "For Tree-IK: Weight of orientation control for this target"
+ * Constraint|KinematicConstraint.pole_angle -> pole_angle:   float  "Pole rotation offset"
+ * Constraint|KinematicConstraint.pole_subtarget -> pole_subtarget:   string  "NO DESCRIPTION"
+ * Constraint|KinematicConstraint.pole_target -> pole_target:   pointer  "Object for pole rotation"
+ * Constraint|KinematicConstraint.axis_reference -> reference_axis:   enum  "Constraint axis Lock options relative to Bone or Target reference"
+ * Constraint|KinematicConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|KinematicConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|KinematicConstraint.use_position -> use_location:   boolean  "Chain follows position of target"
+ * Constraint|KinematicConstraint.use_rotation -> use_rotation:   boolean  "Chain follows rotation of target"
+ * Constraint|KinematicConstraint.use_stretch -> use_stretch:   boolean  "Enable IK Stretching"
+ * Constraint|KinematicConstraint.use_tail -> use_tail:   boolean  "Include bones tail as last element in chain"
+ * Constraint|KinematicConstraint.use_target -> use_target:   boolean  "Disable for targetless IK"
+ * Constraint|KinematicConstraint.weight -> weight:   float  "For Tree-IK: Weight of position control for this target"
+ * Constraint|LimitDistanceConstraint.distance -> distance:   float  "Radius of limiting sphere"
+ * Constraint|LimitDistanceConstraint.limit_mode -> limit_mode:   enum  "Distances in relation to sphere of influence to allow"
+ * Constraint|LimitDistanceConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|LimitDistanceConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|LimitLocationConstraint.maximum_x -> max_x:   float  "Highest X value to allow"
+ * Constraint|LimitLocationConstraint.maximum_y -> max_y:   float  "Highest Y value to allow"
+ * Constraint|LimitLocationConstraint.maximum_z -> max_z:   float  "Highest Z value to allow"
+ * Constraint|LimitLocationConstraint.minimum_x -> min_x:   float  "Lowest X value to allow"
+ * Constraint|LimitLocationConstraint.minimum_y -> min_y:   float  "Lowest Y value to allow"
+ * Constraint|LimitLocationConstraint.minimum_z -> min_z:   float  "Lowest Z value to allow"
+ * Constraint|LimitLocationConstraint.use_maximum_x -> use_max_x:   boolean  "Use the maximum X value"
+ * Constraint|LimitLocationConstraint.use_maximum_y -> use_max_y:   boolean  "Use the maximum Y value"
+ * Constraint|LimitLocationConstraint.use_maximum_z -> use_max_z:   boolean  "Use the maximum Z value"
+ * Constraint|LimitLocationConstraint.use_minimum_x -> use_min_x:   boolean  "Use the minimum X value"
+ * Constraint|LimitLocationConstraint.use_minimum_y -> use_min_y:   boolean  "Use the minimum Y value"
+ * Constraint|LimitLocationConstraint.use_minimum_z -> use_min_z:   boolean  "Use the minimum Z value"
+ * Constraint|LimitLocationConstraint.limit_transform -> use_transform_limit:   boolean  "Transforms are affected by this constraint as well"
+ * Constraint|LimitRotationConstraint.maximum_x -> max_x:   float  "Highest X value to allow"
+ * Constraint|LimitRotationConstraint.maximum_y -> max_y:   float  "Highest Y value to allow"
+ * Constraint|LimitRotationConstraint.maximum_z -> max_z:   float  "Highest Z value to allow"
+ * Constraint|LimitRotationConstraint.minimum_x -> min_x:   float  "Lowest X value to allow"
+ * Constraint|LimitRotationConstraint.minimum_y -> min_y:   float  "Lowest Y value to allow"
+ * Constraint|LimitRotationConstraint.minimum_z -> min_z:   float  "Lowest Z value to allow"
+ * Constraint|LimitRotationConstraint.use_limit_x -> use_limit_x:   boolean  "Use the minimum X value"
+ * Constraint|LimitRotationConstraint.use_limit_y -> use_limit_y:   boolean  "Use the minimum Y value"
+ * Constraint|LimitRotationConstraint.use_limit_z -> use_limit_z:   boolean  "Use the minimum Z value"
+ * Constraint|LimitRotationConstraint.limit_transform -> use_transform_limit:   boolean  "Transforms are affected by this constraint as well"
+ * Constraint|LimitScaleConstraint.maximum_x -> max_x:   float  "Highest X value to allow"
+ * Constraint|LimitScaleConstraint.maximum_y -> max_y:   float  "Highest Y value to allow"
+ * Constraint|LimitScaleConstraint.maximum_z -> max_z:   float  "Highest Z value to allow"
+ * Constraint|LimitScaleConstraint.minimum_x -> min_x:   float  "Lowest X value to allow"
+ * Constraint|LimitScaleConstraint.minimum_y -> min_y:   float  "Lowest Y value to allow"
+ * Constraint|LimitScaleConstraint.minimum_z -> min_z:   float  "Lowest Z value to allow"
+ * Constraint|LimitScaleConstraint.use_maximum_x -> use_max_x:   boolean  "Use the maximum X value"
+ * Constraint|LimitScaleConstraint.use_maximum_y -> use_max_y:   boolean  "Use the maximum Y value"
+ * Constraint|LimitScaleConstraint.use_maximum_z -> use_max_z:   boolean  "Use the maximum Z value"
+ * Constraint|LimitScaleConstraint.use_minimum_x -> use_min_x:   boolean  "Use the minimum X value"
+ * Constraint|LimitScaleConstraint.use_minimum_y -> use_min_y:   boolean  "Use the minimum Y value"
+ * Constraint|LimitScaleConstraint.use_minimum_z -> use_min_z:   boolean  "Use the minimum Z value"
+ * Constraint|LimitScaleConstraint.limit_transform -> use_transform_limit:   boolean  "Transforms are affected by this constraint as well"
+ * Constraint|LockedTrackConstraint.lock -> lock_axis:   enum  "Axis that points upward"
+ * Constraint|LockedTrackConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|LockedTrackConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|LockedTrackConstraint.track -> track_axis:   enum  "Axis that points to the target object"
+ * Constraint|MaintainVolumeConstraint.axis -> free_axis:   enum  "The free scaling axis of the object"
+ * Constraint|MaintainVolumeConstraint.volume -> volume:   float  "Volume of the bone at rest"
+ * Constraint|PivotConstraint.head_tail -> head_tail:   float  "Target along length of bone: Head=0, Tail=1"
+ * Constraint|PivotConstraint.offset -> offset:   float[3]  "Offset of pivot from target (when set), or from owners location (when Fixed Position is off), or the absolute pivot point"
+ * Constraint|PivotConstraint.enabled_rotation_range -> rotation_range:   enum  "Rotation range on which pivoting should occur"
+ * Constraint|PivotConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|PivotConstraint.target -> target:   pointer  "Target Object, defining the position of the pivot when defined"
+ * Constraint|PivotConstraint.use_relative_position -> use_relative_location:   boolean  "Offset will be an absolute point in space instead of relative to the target"
+ * Constraint|PythonConstraint.script_error -> has_script_error:   boolean,  "(read-only)    The linked Python script has thrown an error"
+ * Constraint|PythonConstraint.number_of_targets -> target_count:   int  "Usually only 1-3 are needed"
+ * Constraint|PythonConstraint.targets -> targets:   collection,  "(read-only)    Target Objects"
+ * Constraint|PythonConstraint.text -> text:   pointer  "The text object that contains the Python script"
+ * Constraint|PythonConstraint.use_targets -> use_targets:   boolean  "Use the targets indicated in the constraint panel"
+ * Constraint|RigidBodyJointConstraint.axis_x -> axis_x:   float  "Rotate pivot on X axis in degrees"
+ * Constraint|RigidBodyJointConstraint.axis_y -> axis_y:   float  "Rotate pivot on Y axis in degrees"
+ * Constraint|RigidBodyJointConstraint.axis_z -> axis_z:   float  "Rotate pivot on Z axis in degrees"
+ * Constraint|RigidBodyJointConstraint.child -> child:   pointer  "Child object"
+ * Constraint|RigidBodyJointConstraint.pivot_type -> pivot_type:   enum  "NO DESCRIPTION"
+ * Constraint|RigidBodyJointConstraint.pivot_x -> pivot_x:   float  "Offset pivot on X"
+ * Constraint|RigidBodyJointConstraint.pivot_y -> pivot_y:   float  "Offset pivot on Y"
+ * Constraint|RigidBodyJointConstraint.pivot_z -> pivot_z:   float  "Offset pivot on Z"
+ * Constraint|RigidBodyJointConstraint.draw_pivot -> show_pivot:   boolean  "Display the pivot point and rotation in 3D view"
+ * Constraint|RigidBodyJointConstraint.target -> target:   pointer  "Target Object"
+NEGATE * Constraint|RigidBodyJointConstraint.disable_linked_collision -> use_linked_collision:   boolean  "Disable collision between linked bodies"
+ * Constraint|ShrinkwrapConstraint.distance -> distance:   float  "Distance to Target"
+ * Constraint|ShrinkwrapConstraint.shrinkwrap_type -> shrinkwrap_type:   enum  "Selects type of shrinkwrap algorithm for target position"
+ * Constraint|ShrinkwrapConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|ShrinkwrapConstraint.use_x -> use_x:   boolean  "Projection over X Axis"
+ * Constraint|ShrinkwrapConstraint.use_y -> use_y:   boolean  "Projection over Y Axis"
+ * Constraint|ShrinkwrapConstraint.use_z -> use_z:   boolean  "Projection over Z Axis"
+ * Constraint|SplineIKConstraint.chain_length -> chain_count:   int  "How many bones are included in the chain"
+ * Constraint|SplineIKConstraint.joint_bindings -> joint_bindings:   float[32]  "(EXPERIENCED USERS ONLY) The relative positions of the joints along the chain as percentages"
+ * Constraint|SplineIKConstraint.target -> target:   pointer  "Curve that controls this relationship"
+ * Constraint|SplineIKConstraint.chain_offset -> use_chain_offset:   boolean  "Offset the entire chain relative to the root joint"
+ * Constraint|SplineIKConstraint.use_curve_radius -> use_curve_radius:   boolean  "Average radius of the endpoints is used to tweak the X and Z Scaling of the bones, on top of XZ Scale mode"
+ * Constraint|SplineIKConstraint.even_divisions -> use_even_divisions:   boolean  "Ignore the relative lengths of the bones when fitting to the curve"
+ * Constraint|SplineIKConstraint.y_stretch -> use_y_stretch:   boolean  "Stretch the Y axis of the bones to fit the curve"
+ * Constraint|SplineIKConstraint.xz_scaling_mode -> xz_scale_mode:   enum  "Method used for determining the scaling of the X and Z axes of the bones"
+ * Constraint|StretchToConstraint.bulge -> bulge:   float  "Factor between volume variation and stretching"
+ * Constraint|StretchToConstraint.head_tail -> head_tail:   float  "Target along length of bone: Head=0, Tail=1"
+ * Constraint|StretchToConstraint.keep_axis -> keep_axis:   enum  "Axis to maintain during stretch"
+ * Constraint|StretchToConstraint.original_length -> rest_length:   float  "Length at rest position"
+ * Constraint|StretchToConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|StretchToConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|StretchToConstraint.volume -> volume:   enum  "Maintain the objects volume as it stretches"
+ * Constraint|TrackToConstraint.head_tail -> head_tail:   float  "Target along length of bone: Head=0, Tail=1"
+ * Constraint|TrackToConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|TrackToConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|TrackToConstraint.track -> track_axis:   enum  "Axis that points to the target object"
+ * Constraint|TrackToConstraint.up -> up_axis:   enum  "Axis that points upward"
+ * Constraint|TrackToConstraint.target_z -> use_target_z:   boolean  "Targets Z axis, not World Z axis, will constraint the Up direction"
+ * Constraint|TransformConstraint.from_max_x -> from_max_x:   float  "Top range of X axis source motion"
+ * Constraint|TransformConstraint.from_max_y -> from_max_y:   float  "Top range of Y axis source motion"
+ * Constraint|TransformConstraint.from_max_z -> from_max_z:   float  "Top range of Z axis source motion"
+ * Constraint|TransformConstraint.from_min_x -> from_min_x:   float  "Bottom range of X axis source motion"
+ * Constraint|TransformConstraint.from_min_y -> from_min_y:   float  "Bottom range of Y axis source motion"
+ * Constraint|TransformConstraint.from_min_z -> from_min_z:   float  "Bottom range of Z axis source motion"
+ * Constraint|TransformConstraint.map_from -> map_from:   enum  "The transformation type to use from the target"
+ * Constraint|TransformConstraint.map_to -> map_to:   enum  "The transformation type to affect of the constrained object"
+ * Constraint|TransformConstraint.map_to_x_from -> map_to_x_from:   enum  "The source axis constrained objects X axis uses"
+ * Constraint|TransformConstraint.map_to_y_from -> map_to_y_from:   enum  "The source axis constrained objects Y axis uses"
+ * Constraint|TransformConstraint.map_to_z_from -> map_to_z_from:   enum  "The source axis constrained objects Z axis uses"
+ * Constraint|TransformConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
+ * Constraint|TransformConstraint.target -> target:   pointer  "Target Object"
+ * Constraint|TransformConstraint.to_max_x -> to_max_x:   float  "Top range of X axis destination motion"
+ * Constraint|TransformConstraint.to_max_y -> to_max_y:   float  "Top range of Y axis destination motion"
+ * Constraint|TransformConstraint.to_max_z -> to_max_z:   float  "Top range of Z axis destination motion"
+ * Constraint|TransformConstraint.to_min_x -> to_min_x:   float  "Bottom range of X axis destination motion"
+ * Constraint|TransformConstraint.to_min_y -> to_min_y:   float  "Bottom range of Y axis destination motion"
+ * Constraint|TransformConstraint.to_min_z -> to_min_z:   float  "Bottom range of Z axis destination motion"
+ * Constraint|TransformConstraint.extrapolate_motion -> use_motion_extrapolate:   boolean  "Extrapolate ranges"
+ * Context.area -> area:   pointer,  "(read-only)"
+ * Context.main -> main:   pointer,  "(read-only)"
+ * Context.mode -> mode:   enum,  "(read-only)"
+ * Context.region -> region:   pointer,  "(read-only)"
+ * Context.region_data -> region_data:   pointer,  "(read-only)"
+ * Context.scene -> scene:   pointer,  "(read-only)"
+ * Context.screen -> screen:   pointer,  "(read-only)"
+ * Context.space_data -> space_data:   pointer,  "(read-only)"
+ * Context.tool_settings -> tool_settings:   pointer,  "(read-only)"
+ * Context.user_preferences -> user_preferences:   pointer,  "(read-only)"
+ * Context.window -> window:   pointer,  "(read-only)"
+ * Context.manager -> wm:   pointer,  "(read-only)"
+ * Controller.name -> name:   string  "NO DESCRIPTION"
+ * Controller.expanded -> show_expanded:   boolean  "Set controller expanded in the user interface"
+ * Controller.state -> state:   int  "Set Controller state index (1 to 30)"
+ * Controller.type -> type:   enum  "NO DESCRIPTION"
+ * Controller.priority -> use_priority:   boolean  "Mark controller for execution before all non-marked controllers (good for startup scripts)"
+ * Controller|ExpressionController.expression -> expression:   string  "NO DESCRIPTION"
+ * Controller|PythonController.mode -> mode:   enum  "Python script type (textblock or module - faster)"
+ * Controller|PythonController.module -> module:   string  "Module name and function to run e.g. someModule.main. Internal texts and external python files can be used"
+ * Controller|PythonController.text -> text:   pointer  "Text datablock with the python script"
+ * Controller|PythonController.debug -> use_debug:   boolean  "Continuously reload the module from disk for editing external modules without restarting"
+ * CurveMap.extend -> extend:   enum,  "(read-only)    Extrapolate the curve or extend it horizontally"
+ * CurveMap.points -> points:   collection,  "(read-only)"
+ * CurveMapPoint.handle_type -> handle_type:   enum,  "(read-only)    Curve interpolation at this point: bezier or vector"
+ * CurveMapPoint.location -> location:   float[2],  "(read-only)    X/Y coordinates of the curve point"
+ * CurveMapPoint.select -> select:   boolean  "Selection state of the curve point"
+ * CurveMapping.black_level -> black_level:   float[3]  "For RGB curves, the color that black is mapped to"
+ * CurveMapping.clip_max_x -> clip_max_x:   float  "NO DESCRIPTION"
+ * CurveMapping.clip_max_y -> clip_max_y:   float  "NO DESCRIPTION"
+ * CurveMapping.clip_min_x -> clip_min_x:   float  "NO DESCRIPTION"
+ * CurveMapping.clip_min_y -> clip_min_y:   float  "NO DESCRIPTION"
+ * CurveMapping.curves -> curves:   collection,  "(read-only)"
+ * CurveMapping.clip -> use_clip:   boolean  "Force the curve view to fit a defined boundary"
+ * CurveMapping.white_level -> white_level:   float[3]  "For RGB curves, the color that white is mapped to"
TODO MOVE TO COLLECTION * CurveSplines.active -> active:   pointer  "Active curve spline"
+ * DopeSheet.filtering_group -> filter_group:   pointer  "Group that included Object should be a member of"
+ * DopeSheet.display_armature -> show_armatures:   boolean  "Include visualization of Armature related Animation data"
+ * DopeSheet.display_camera -> show_cameras:   boolean  "Include visualization of Camera related Animation data"
+ * DopeSheet.display_curve -> show_curves:   boolean  "Include visualization of Curve related Animation data"
+NEGATE * DopeSheet.collapse_summary -> show_expanded_summary:   boolean  "Collapse summary when shown, so all other channels get hidden. (DopeSheet Editors Only)"
+ * DopeSheet.display_hidden -> show_hidden:   boolean  "Include channels from objects/bone that arent visible"
+ * DopeSheet.display_lamp -> show_lamps:   boolean  "Include visualization of Lamp related Animation data"
+ * DopeSheet.display_material -> show_materials:   boolean  "Include visualization of Material related Animation data"
+ * DopeSheet.display_mesh -> show_meshes:   boolean  "Include visualization of Mesh related Animation data"
+ * DopeSheet.display_metaball -> show_metaballs:   boolean  "Include visualization of Metaball related Animation data"
+ * DopeSheet.include_missing_nla -> show_missing_nla:   boolean  "Include Animation Data blocks with no NLA data. (NLA Editor only)"
+ * DopeSheet.display_node -> show_nodes:   boolean  "Include visualization of Node related Animation data"
+ * DopeSheet.only_group_objects -> show_only_group_objects:   boolean  "Only include channels from Objects in the specified Group"
+ * DopeSheet.only_selected -> show_only_selected:   boolean  "Only include channels relating to selected objects and data"
+ * DopeSheet.display_particle -> show_particles:   boolean  "Include visualization of Particle related Animation data"
+ * DopeSheet.display_scene -> show_scenes:   boolean  "Include visualization of Scene related Animation data"
+ * DopeSheet.display_shapekeys -> show_shapekeys:   boolean  "Include visualization of ShapeKey related Animation data"
+ * DopeSheet.display_summary -> show_summary:   boolean  "Display an additional summary line. (DopeSheet Editors only)"
+ * DopeSheet.display_texture -> show_textures:   boolean  "Include visualization of Texture related Animation data"
+ * DopeSheet.display_transforms -> show_transforms:   boolean  "Include visualization of Object-level Animation data (mostly Transforms)"
+ * DopeSheet.display_world -> show_worlds:   boolean  "Include visualization of World related Animation data"
+ * DopeSheet.source -> source:   pointer,  "(read-only)    ID-Block representing source data, currently ID_SCE (for Dopesheet), and ID_SC (for Grease Pencil)"
+ * Driver.expression -> expression:   string  "Expression to use for Scripted Expression"
+NEGATE * Driver.invalid -> is_valid:   boolean  "Driver could not be evaluated in past, so should be skipped"
+ * Driver.show_debug_info -> show_debug_info:   boolean  "Show intermediate values for the driver calculations to allow debugging of drivers"
+ * Driver.type -> type:   enum  "Driver type"
+ * Driver.variables -> variables:   collection,  "(read-only)    Properties acting as inputs for this driver"
+ * DriverTarget.bone_target -> bone_target:   string  "Name of PoseBone to use as target"
+ * DriverTarget.data_path -> data_path:   string  "RNA Path (from ID-block) to property used"
+ * DriverTarget.id -> id:   pointer  "ID-block that the specific property used can be found from (id_type property must be set first)"
+ * DriverTarget.id_type -> id_type:   enum  "Type of ID-block that can be used"
+ * DriverTarget.transform_type -> transform_type:   enum  "Driver variable type"
+ * DriverTarget.use_local_space_transforms -> use_local_space_transform:   boolean  "Use transforms in Local Space (as opposed to the worldspace default)"
+ * DriverVariable.name -> name:   string  "Name to use in scripted expressions/functions. (No spaces or dots are allowed. Also, must not start with a symbol or digit)"
+ * DriverVariable.targets -> targets:   collection,  "(read-only)    Sources of input data for evaluating this variable"
+ * DriverVariable.type -> type:   enum  "Driver variable type"
+ * DupliObject.matrix -> matrix:   float[16]  "Object duplicate transformation matrix"
+ * DupliObject.matrix_original -> matrix_original:   float[16]  "The original matrix of this object before it was duplicated"
+ * DupliObject.object -> object:   pointer,  "(read-only)    Object being duplicated"
+ * EditBone.bbone_in -> bbone_in:   float  "Length of first Bezier Handle (for B-Bones only)"
+ * EditBone.bbone_out -> bbone_out:   float  "Length of second Bezier Handle (for B-Bones only)"
+ * EditBone.bbone_segments -> bbone_segments:   int  "Number of subdivisions of bone (for B-Bones only)"
+ * EditBone.envelope_distance -> envelope_distance:   float  "Bone deformation distance (for Envelope deform only)"
+ * EditBone.envelope_weight -> envelope_weight:   float  "Bone deformation weight (for Envelope deform only)"
+ * EditBone.head -> head:   float[3]  "Location of head end of the bone"
+ * EditBone.head_radius -> head_radius:   float  "Radius of head of bone (for Envelope deform only)"
+ * EditBone.hide -> hide:   boolean  "Bone is not visible when in Edit Mode"
+ * EditBone.hide_select -> hide_select:   boolean  "Bone is able to be selected"
+ * EditBone.layer -> layers:   boolean[32]  "Layers bone exists in"
+ * EditBone.lock -> lock:   boolean  "Bone is not able to be transformed when in Edit Mode"
+ * EditBone.matrix -> matrix:   float[16],  "(read-only)    Read-only matrix calculated from the roll (armature space)"
+ * EditBone.name -> name:   string  "NO DESCRIPTION"
+ * EditBone.parent -> parent:   pointer  "Parent edit bone (in same Armature)"
+ * EditBone.roll -> roll:   float  "Bone rotation around head-tail axis"
+ * EditBone.select -> select:   boolean  "NO DESCRIPTION"
+ * EditBone.select_head -> select_head:   boolean  "NO DESCRIPTION"
+ * EditBone.select_tail -> select_tail:   boolean  "NO DESCRIPTION"
+ * EditBone.draw_wire -> show_wire:   boolean  "Bone is always drawn as Wireframe regardless of viewport draw mode. Useful for non-obstructive custom bone shapes"
+ * EditBone.tail -> tail:   float[3]  "Location of tail end of the bone"
+ * EditBone.tail_radius -> tail_radius:   float  "Radius of tail of bone (for Envelope deform only)"
+ * EditBone.connected -> use_connect:   boolean  "When bone has a parent, bones head is struck to the parents tail"
+ * EditBone.cyclic_offset -> use_cyclic_offset:   boolean  "When bone doesnt have a parent, it receives cyclic offset effects"
+ * EditBone.deform -> use_deform:   boolean  "Bone does not deform any geometry"
+ * EditBone.multiply_vertexgroup_with_envelope -> use_envelope_multiply:   boolean  "When deforming bone, multiply effects of Vertex Group weights with Envelope influence"
+ * EditBone.hinge -> use_hinge:   boolean  "Bone inherits rotation or scale from parent bone"
+ * EditBone.inherit_scale -> use_inherit_scale:   boolean  "Bone inherits scaling from parent bone"
+ * EditBone.local_location -> use_local_location:   boolean  "Bone location is set in local space"
+ * EffectorWeights.all -> all:   float  "All effectors weight"
+ * EffectorWeights.do_growing_hair -> apply_to_hair_growing:   boolean  "Use force fields when growing hair"
+ * EffectorWeights.boid -> boid:   float  "Boid effector weight"
+ * EffectorWeights.charge -> charge:   float  "Charge effector weight"
+ * EffectorWeights.curveguide -> curve_guide:   float  "Curve guide effector weight"
+ * EffectorWeights.drag -> drag:   float  "Drag effector weight"
+ * EffectorWeights.force -> force:   float  "Force effector weight"
+ * EffectorWeights.gravity -> gravity:   float  "Global gravity weight"
+ * EffectorWeights.group -> group:   pointer  "Limit effectors to this Group"
+ * EffectorWeights.harmonic -> harmonic:   float  "Harmonic effector weight"
+ * EffectorWeights.lennardjones -> lennardjones:   float  "Lennard-Jones effector weight"
+ * EffectorWeights.magnetic -> magnetic:   float  "Magnetic effector weight"
+ * EffectorWeights.texture -> texture:   float  "Texture effector weight"
+ * EffectorWeights.turbulence -> turbulence:   float  "Turbulence effector weight"
+ * EffectorWeights.vortex -> vortex:   float  "Vortex effector weight"
+ * EffectorWeights.wind -> wind:   float  "Wind effector weight"
+ * EnumPropertyItem.description -> description:   string,  "(read-only)    Description of the items purpose"
+ * EnumPropertyItem.identifier -> identifier:   string,  "(read-only)    Unique name used in the code and scripting"
+ * EnumPropertyItem.name -> name:   string,  "(read-only)    Human readable name"
+ * EnumPropertyItem.value -> value:   int,  "(read-only)    Value of the item"
+ * EnvironmentMap.clip_end -> clip_end:   float  "Objects further than this are not visible to map"
+ * EnvironmentMap.clip_start -> clip_start:   float  "Objects nearer than this are not visible to map"
+ * EnvironmentMap.depth -> depth:   int  "Number of times a map will be rendered recursively (mirror effects.)"
+ * EnvironmentMap.ignore_layers -> layers_ignore:   boolean[20]  "Hide objects on these layers when generating the Environment Map"
+ * EnvironmentMap.mapping -> mapping:   enum  "NO DESCRIPTION"
+ * EnvironmentMap.resolution -> resolution:   int  "Pixel resolution of the rendered environment map"
+ * EnvironmentMap.source -> source:   enum  "NO DESCRIPTION"
+ * EnvironmentMap.viewpoint_object -> viewpoint_object:   pointer  "Object to use as the environment maps viewpoint location"
+ * EnvironmentMap.zoom -> zoom:   float  "NO DESCRIPTION"
+ * Event.ascii -> ascii:   string,  "(read-only)    Single ASCII character for this event"
+ * Event.alt -> is_pressed_alt:   boolean,  "(read-only)    True when the Alt/Option key is held"
+ * Event.oskey -> is_pressed_cmd:   boolean,  "(read-only)    True when the Cmd key is held"
+ * Event.ctrl -> is_pressed_ctrl:   boolean,  "(read-only)    True when the Ctrl key is held"
+ * Event.shift -> is_pressed_shift:   boolean,  "(read-only)    True when the Shift key is held"
+ * Event.mouse_prev_x -> mouse_prev_x:   int,  "(read-only)    The window relative vertical location of the mouse"
+ * Event.mouse_prev_y -> mouse_prev_y:   int,  "(read-only)    The window relative horizontal location of the mouse"
+ * Event.mouse_region_x -> mouse_region_x:   int,  "(read-only)    The region relative vertical location of the mouse"
+ * Event.mouse_region_y -> mouse_region_y:   int,  "(read-only)    The region relative horizontal location of the mouse"
+ * Event.mouse_x -> mouse_x:   int,  "(read-only)    The window relative vertical location of the mouse"
+ * Event.mouse_y -> mouse_y:   int,  "(read-only)    The window relative horizontal location of the mouse"
+ * Event.type -> type:   enum,  "(read-only)"
+ * Event.value -> value:   enum,  "(read-only)    The type of event, only applies to some"
+ * FCurve.array_index -> array_index:   int  "Index to the specific property affected by F-Curve if applicable"
+ * FCurve.color -> color:   float[3]  "Color of the F-Curve in the Graph Editor"
+ * FCurve.color_mode -> color_mode:   enum  "Method used to determine color of F-Curve in Graph Editor"
+ * FCurve.data_path -> data_path:   string  "RNA Path to property affected by F-Curve"
+ * FCurve.driver -> driver:   pointer,  "(read-only)    Channel Driver (only set for Driver F-Curves)"
+ * FCurve.extrapolation -> extrapolation:   enum  "NO DESCRIPTION"
+ * FCurve.group -> group:   pointer  "Action Group that this F-Curve belongs to"
+ * FCurve.hide -> hide:   boolean  "F-Curve and its keyframes are hidden in the Graph Editor graphs"
+ * FCurve.enabled -> is_valid:   boolean  "False when F-Curve could not be evaluated in past, so should be skipped when evaluating"
+ * FCurve.keyframe_points -> keyframe_points:   collection,  "(read-only)    User-editable keyframes"
+ * FCurve.lock -> lock:   boolean  "F-Curves settings cannot be edited"
+ * FCurve.modifiers -> modifiers:   collection,  "(read-only)    Modifiers affecting the shape of the F-Curve"
+ * FCurve.mute -> mute:   boolean  "F-Curve is not evaluated"
+ * FCurve.sampled_points -> sampled_points:   collection,  "(read-only)    Sampled animation data"
+ * FCurve.select -> select:   boolean  "F-Curve is selected for editing"
+ * FCurve.auto_clamped_handles -> use_auto_handle_clamp:   boolean  "All auto-handles for F-Curve are clamped"
+ * FCurveModifiers.active -> active:   pointer  "Active F-Curve Modifier"
+ * FCurveSample.co -> co:   float[2]  "Point coordinates"
+ * FCurveSample.select -> select:   boolean  "Selection status"
REMOVE * FModifier.active -> active:   boolean  "F-Curve Modifier is the one being edited"
+ * FModifier.mute -> mute:   boolean  "F-Curve Modifier will not be evaluated"
+ * FModifier.expanded -> show_expanded:   boolean  "F-Curve Modifiers panel is expanded in UI"
+ * FModifier.type -> type:   enum,  "(read-only)    F-Curve Modifier Type"
+NEGATE * FModifier.disabled -> use:   boolean,  "(read-only)    F-Curve Modifier has invalid settings and will not be evaluated"
+ * FModifierEnvelopeControlPoint.frame -> frame:   float  "Frame this control-point occurs on"
+ * FModifierEnvelopeControlPoint.maximum -> max:   float  "Upper bound of envelope at this control-point"
+ * FModifierEnvelopeControlPoint.minimum -> min:   float  "Lower bound of envelope at this control-point"
+ * FModifier|FModifierCycles.after_cycles -> cycles_after:   float  "Maximum number of cycles to allow after last keyframe. (0 = infinite)"
+ * FModifier|FModifierCycles.before_cycles -> cycles_before:   float  "Maximum number of cycles to allow before first keyframe. (0 = infinite)"
+ * FModifier|FModifierCycles.after_mode -> mode_after:   enum  "Cycling mode to use after last keyframe"
+ * FModifier|FModifierCycles.before_mode -> mode_before:   enum  "Cycling mode to use before first keyframe"
+ * FModifier|FModifierEnvelope.control_points -> control_points:   collection,  "(read-only)    Control points defining the shape of the envelope"
+ * FModifier|FModifierEnvelope.default_maximum -> default_max:   float  "Upper distance from Reference Value for 1:1 default influence"
+ * FModifier|FModifierEnvelope.default_minimum -> default_min:   float  "Lower distance from Reference Value for 1:1 default influence"
+ * FModifier|FModifierEnvelope.reference_value -> reference_value:   float  "Value that envelopes influence is centered around / based on"
+ * FModifier|FModifierFunctionGenerator.amplitude -> amplitude:   float  "Scale factor determining the maximum/minimum values"
+ * FModifier|FModifierFunctionGenerator.function_type -> function_type:   enum  "Type of built-in function to use"
+ * FModifier|FModifierFunctionGenerator.phase_multiplier -> phase_multiplier:   float  "Scale factor determining the speed of the function"
+ * FModifier|FModifierFunctionGenerator.phase_offset -> phase_offset:   float  "Constant factor to offset time by for function"
+ * FModifier|FModifierFunctionGenerator.additive -> use_additive:   boolean  "Values generated by this modifier are applied on top of the existing values instead of overwriting them"
+ * FModifier|FModifierFunctionGenerator.value_offset -> value_offset:   float  "Constant factor to offset values by"
+ * FModifier|FModifierGenerator.coefficients -> coefficients:   float[32]  "Coefficients for x (starting from lowest power of x^0)"
+ * FModifier|FModifierGenerator.mode -> mode:   enum  "Type of generator to use"
+ * FModifier|FModifierGenerator.poly_order -> poly_order:   int  "The highest power of x for this polynomial. (number of coefficients - 1)"
+ * FModifier|FModifierGenerator.additive -> use_additive:   boolean  "Values generated by this modifier are applied on top of the existing values instead of overwriting them"
+ * FModifier|FModifierLimits.maximum_x -> max_x:   float  "Highest X value to allow"
+ * FModifier|FModifierLimits.maximum_y -> max_y:   float  "Highest Y value to allow"
+ * FModifier|FModifierLimits.minimum_x -> min_x:   float  "Lowest X value to allow"
+ * FModifier|FModifierLimits.minimum_y -> min_y:   float  "Lowest Y value to allow"
+ * FModifier|FModifierLimits.use_maximum_x -> use_max_x:   boolean  "Use the maximum X value"
+ * FModifier|FModifierLimits.use_maximum_y -> use_max_y:   boolean  "Use the maximum Y value"
+ * FModifier|FModifierLimits.use_minimum_x -> use_min_x:   boolean  "Use the minimum X value"
+ * FModifier|FModifierLimits.use_minimum_y -> use_min_y:   boolean  "Use the minimum Y value"
+ * FModifier|FModifierNoise.modification -> blend_type:   enum  "Method of modifying the existing F-Curve"
+ * FModifier|FModifierNoise.depth -> depth:   int  "Amount of fine level detail present in the noise"
+ * FModifier|FModifierNoise.phase -> phase:   float  "A random seed for the noise effect"
+ * FModifier|FModifierNoise.size -> scale:   float  "Scaling (in time) of the noise"
+ * FModifier|FModifierNoise.strength -> strength:   float  "Amplitude of the noise - the amount that it modifies the underlying curve"
+ * FModifier|FModifierStepped.frame_end -> frame_end:   float  "Frame that modifiers influence ends (if applicable)"
+ * FModifier|FModifierStepped.offset -> frame_offset:   float  "Reference number of frames before frames get held. Use to get hold for 1-3 vs 5-7 holding patterns"
+ * FModifier|FModifierStepped.frame_start -> frame_start:   float  "Frame that modifiers influence starts (if applicable)"
+ * FModifier|FModifierStepped.step_size -> frame_step:   float  "Number of frames to hold each value"
+ * FModifier|FModifierStepped.use_frame_end -> use_frame_end:   boolean  "Restrict modifier to only act before its end frame"
+ * FModifier|FModifierStepped.use_frame_start -> use_frame_start:   boolean  "Restrict modifier to only act after its start frame"
+ * FieldSettings.do_location -> apply_to_location:   boolean  "Effect particles location"
+ * FieldSettings.do_rotation -> apply_to_rotation:   boolean  "Effect particles dynamic rotation"
+ * FieldSettings.maximum_distance -> distance_max:   float  "Maximum distance for the field to work"
+ * FieldSettings.minimum_distance -> distance_min:   float  "Minimum distance for the fields fall-off"
+ * FieldSettings.falloff_power -> falloff_power:   float  "Falloff power (real gravitational falloff = 2)"
+ * FieldSettings.falloff_type -> falloff_type:   enum  "Fall-off shape"
+ * FieldSettings.flow -> flow:   float  "Convert effector force into air flow velocity"
+ * FieldSettings.guide_clump_amount -> guide_clump_amount:   float  "Amount of clumping"
+ * FieldSettings.guide_clump_shape -> guide_clump_shape:   float  "Shape of clumping"
+ * FieldSettings.guide_free -> guide_free:   float  "Guide-free time from particle lifes end"
+ * FieldSettings.guide_kink_amplitude -> guide_kink_amplitude:   float  "The amplitude of the offset"
+ * FieldSettings.guide_kink_axis -> guide_kink_axis:   enum  "Which axis to use for offset"
+ * FieldSettings.guide_kink_frequency -> guide_kink_frequency:   float  "The frequency of the offset (1/total length)"
+ * FieldSettings.guide_kink_shape -> guide_kink_shape:   float  "Adjust the offset to the beginning/end"
+ * FieldSettings.guide_kink_type -> guide_kink_type:   enum  "Type of periodic offset on the curve"
+ * FieldSettings.guide_minimum -> guide_minimum:   float  "The distance from which particles are affected fully"
+ * FieldSettings.harmonic_damping -> harmonic_damping:   float  "Damping of the harmonic force"
+ * FieldSettings.inflow -> inflow:   float  "Inwards component of the vortex force"
+ * FieldSettings.linear_drag -> linear_drag:   float  "Drag component proportional to velocity"
+ * FieldSettings.noise -> noise:   float  "Noise of the force"
+ * FieldSettings.quadratic_drag -> quadratic_drag:   float  "Drag component proportional to the square of velocity"
+ * FieldSettings.radial_falloff -> radial_falloff:   float  "Radial falloff power (real gravitational falloff = 2)"
+ * FieldSettings.radial_maximum -> radial_max:   float  "Maximum radial distance for the field to work"
+ * FieldSettings.radial_minimum -> radial_min:   float  "Minimum radial distance for the fields fall-off"
+ * FieldSettings.rest_length -> rest_length:   float  "Rest length of the harmonic force"
+ * FieldSettings.seed -> seed:   int  "Seed of the noise"
+ * FieldSettings.shape -> shape:   enum  "Which direction is used to calculate the effector force"
+ * FieldSettings.size -> size:   float  "Size of the noise"
+ * FieldSettings.strength -> strength:   float  "Strength of force field"
+ * FieldSettings.texture -> texture:   pointer  "Texture to use as force"
+ * FieldSettings.texture_mode -> texture_mode:   enum  "How the texture effect is calculated (RGB & Curl need a RGB texture else Gradient will be used instead)"
+ * FieldSettings.texture_nabla -> texture_nabla:   float  "Defines size of derivative offset used for calculating gradient and curl"
+ * FieldSettings.type -> type:   enum  "Type of field"
+ * FieldSettings.force_2d -> use_2d_force:   boolean  "Apply force only in 2d"
+ * FieldSettings.do_absorption -> use_absorption:   boolean  "Force gets absorbed by collision objects"
+ * FieldSettings.global_coordinates -> use_global_coords:   boolean  "Use effector/global coordinates for turbulence"
+ * FieldSettings.guide_path_add -> use_guide_path_add:   boolean  "Based on distance/falloff it adds a portion of the entire path"
+ * FieldSettings.use_guide_path_weight -> use_guide_path_weight:   boolean  "Use curve weights to influence the particle influence along the curve"
+ * FieldSettings.use_max_distance -> use_max_distance:   boolean  "Use a maximum distance for the field to work"
+ * FieldSettings.use_min_distance -> use_min_distance:   boolean  "Use a minimum distance for the fields fall-off"
+ * FieldSettings.multiple_springs -> use_multiple_springs:   boolean  "Every point is effected by multiple springs"
+ * FieldSettings.use_coordinates -> use_object_coords:   boolean  "Use object/global coordinates for texture"
+ * FieldSettings.use_radial_max -> use_radial_max:   boolean  "Use a maximum radial distance for the field to work"
+ * FieldSettings.use_radial_min -> use_radial_min:   boolean  "Use a minimum radial distance for the fields fall-off"
+ * FieldSettings.root_coordinates -> use_root_coords:   boolean  "Texture coordinates from root particle locations"
+ * FieldSettings.z_direction -> z_direction:   enum  "Effect in full or only positive/negative Z direction"
+ * FileSelectParams.directory -> directory:   string  "Directory displayed in the file browser"
+ * FileSelectParams.display -> display_type:   enum  "Display mode for the file list"
+ * FileSelectParams.file -> filename:   string  "Active file in the file browser"
+NEGATE * FileSelectParams.hide_dot -> show_hidden:   boolean  "Hide hidden dot files"
+ * FileSelectParams.sort -> sort_method:   enum  "NO DESCRIPTION"
+ * FileSelectParams.title -> title:   string,  "(read-only)    Title for the file browser"
+ * FileSelectParams.do_filter -> use_filter:   boolean  "Enable filtering of files"
+ * FileSelectParams.filter_blender -> use_filter_blender:   boolean  "Show .blend files"
+ * FileSelectParams.filter_folder -> use_filter_folder:   boolean  "Show folders"
+ * FileSelectParams.filter_font -> use_filter_font:   boolean  "Show font files"
+ * FileSelectParams.filter_image -> use_filter_image:   boolean  "Show image files"
+ * FileSelectParams.filter_movie -> use_filter_movie:   boolean  "Show movie files"
+ * FileSelectParams.filter_script -> use_filter_script:   boolean  "Show script files"
+ * FileSelectParams.filter_sound -> use_filter_sound:   boolean  "Show sound files"
+ * FileSelectParams.filter_text -> use_filter_text:   boolean  "Show text files"
+ * FluidSettings.type -> type:   enum  "Type of participation in the fluid simulation"
+ * FluidSettings|ControlFluidSettings.attraction_radius -> attraction_radius:   float  "Specifies the force field radius around the control object"
+ * FluidSettings|ControlFluidSettings.attraction_strength -> attraction_strength:   float  "Force strength for directional attraction towards the control object"
+ * FluidSettings|ControlFluidSettings.end_time -> end_time:   float  "Specifies time when the control particles are deactivated"
+ * FluidSettings|ControlFluidSettings.quality -> quality:   float  "Specifies the quality which is used for object sampling. (higher = better but slower)"
+ * FluidSettings|ControlFluidSettings.start_time -> start_time:   float  "Specifies time when the control particles are activated"
+ * FluidSettings|ControlFluidSettings.active -> use:   boolean  "Object contributes to the fluid simulation"
+ * FluidSettings|ControlFluidSettings.reverse_frames -> use_reverse_frames:   boolean  "Reverse control object movement"
+ * FluidSettings|ControlFluidSettings.velocity_radius -> velocity_radius:   float  "Specifies the force field radius around the control object"
+ * FluidSettings|ControlFluidSettings.velocity_strength -> velocity_strength:   float  "Force strength of how much of the control objects velocity is influencing the fluid velocity"
+ * FluidSettings|DomainFluidSettings.compressibility -> compressibility:   float  "Allowed compressibility due to gravitational force for standing fluid. (directly affects simulation step size)"
+ * FluidSettings|DomainFluidSettings.end_time -> end_time:   float  "Simulation time of the last blender frame (in seconds)"
+ * FluidSettings|DomainFluidSettings.path -> filepath:   string  "Directory (and/or filename prefix) to store baked fluid simulation files in"
+ * FluidSettings|DomainFluidSettings.generate_particles -> generate_particles:   float  "Amount of particles to generate (0=off, 1=normal, >1=more)"
+ * FluidSettings|DomainFluidSettings.gravity -> gravity:   float[3]  "Gravity in X, Y and Z direction"
+ * FluidSettings|DomainFluidSettings.grid_levels -> grid_levels:   int  "Number of coarsened grids to use (-1 for automatic)"
+ * FluidSettings|DomainFluidSettings.memory_estimate -> memory_estimate:   string,  "(read-only)    Estimated amount of memory needed for baking the domain"
+ * FluidSettings|DomainFluidSettings.partial_slip_factor -> partial_slip_factor:   float  "Amount of mixing between no- and free-slip, 0 is no slip and 1 is free slip"
+ * FluidSettings|DomainFluidSettings.preview_resolution -> preview_resolution:   int  "Preview resolution in X,Y and Z direction"
+ * FluidSettings|DomainFluidSettings.render_display_mode -> render_display_mode:   enum  "How to display the mesh for rendering"
+ * FluidSettings|DomainFluidSettings.resolution -> resolution:   int  "Domain resolution in X,Y and Z direction"
+ * FluidSettings|DomainFluidSettings.real_world_size -> size_worldspace:   float  "Size of the simulation domain in metres"
+ * FluidSettings|DomainFluidSettings.slip_type -> slip_type:   enum  "NO DESCRIPTION"
+ * FluidSettings|DomainFluidSettings.start_time -> start_time:   float  "Simulation time of the first blender frame (in seconds)"
+ * FluidSettings|DomainFluidSettings.surface_smoothing -> surface_smooth:   float  "Amount of surface smoothing. A value of 0 is off, 1 is normal smoothing and more than 1 is extra smoothing"
+ * FluidSettings|DomainFluidSettings.surface_subdivisions -> surface_subdivisions:   int  "Number of isosurface subdivisions. This is necessary for the inclusion of particles into the surface generation. Warning - can lead to longer computation times!"
+ * FluidSettings|DomainFluidSettings.tracer_particles -> tracer_particles:   int  "Number of tracer particles to generate"
+ * FluidSettings|DomainFluidSettings.reverse_frames -> use_reverse_frames:   boolean  "Reverse fluid frames"
+ * FluidSettings|DomainFluidSettings.generate_speed_vectors -> use_speed_vectors:   boolean  "Generate speed vectors for vector blur"
+ * FluidSettings|DomainFluidSettings.override_time -> use_time_override:   boolean  "Use a custom start and end time (in seconds) instead of the scenes timeline"
+ * FluidSettings|DomainFluidSettings.viewport_display_mode -> viewport_display_mode:   enum  "How to display the mesh in the viewport"
+ * FluidSettings|DomainFluidSettings.viscosity_base -> viscosity_base:   float  "Viscosity setting: value that is multiplied by 10 to the power of (exponent*-1)"
+ * FluidSettings|DomainFluidSettings.viscosity_exponent -> viscosity_exponent:   int  "Negative exponent for the viscosity value (to simplify entering small values e.g. 5*10^-6.)"
+ * FluidSettings|DomainFluidSettings.viscosity_preset -> viscosity_preset:   enum  "Set viscosity of the fluid to a preset value, or use manual input"
+ * FluidSettings|FluidFluidSettings.initial_velocity -> initial_velocity:   float[3]  "Initial velocity of fluid"
+ * FluidSettings|FluidFluidSettings.active -> use:   boolean  "Object contributes to the fluid simulation"
+ * FluidSettings|FluidFluidSettings.export_animated_mesh -> use_animated_mesh:   boolean  "Export this mesh as an animated one. Slower, only use if really necessary (e.g. armatures or parented objects), animated pos/rot/scale IPOs do not require it"
+ * FluidSettings|FluidFluidSettings.volume_initialization -> volume_initialization:   enum  "Volume initialization type"
+ * FluidSettings|InflowFluidSettings.inflow_velocity -> inflow_velocity:   float[3]  "Initial velocity of fluid"
+ * FluidSettings|InflowFluidSettings.active -> use:   boolean  "Object contributes to the fluid simulation"
+ * FluidSettings|InflowFluidSettings.export_animated_mesh -> use_animated_mesh:   boolean  "Export this mesh as an animated one. Slower, only use if really necessary (e.g. armatures or parented objects), animated pos/rot/scale IPOs do not require it"
+ * FluidSettings|InflowFluidSettings.local_coordinates -> use_local_coords:   boolean  "Use local coordinates for inflow. (e.g. for rotating objects)"
+ * FluidSettings|InflowFluidSettings.volume_initialization -> volume_initialization:   enum  "Volume initialization type"
+ * FluidSettings|ObstacleFluidSettings.impact_factor -> impact_factor:   float  "This is an unphysical value for moving objects - it controls the impact an obstacle has on the fluid, =0 behaves a bit like outflow (deleting fluid), =1 is default, while >1 results in high forces. Can be used to tweak total mass"
+ * FluidSettings|ObstacleFluidSettings.partial_slip_factor -> partial_slip_factor:   float  "Amount of mixing between no- and free-slip, 0 is no slip and 1 is free slip"
+ * FluidSettings|ObstacleFluidSettings.slip_type -> slip_type:   enum  "NO DESCRIPTION"
+ * FluidSettings|ObstacleFluidSettings.active -> use:   boolean  "Object contributes to the fluid simulation"
+ * FluidSettings|ObstacleFluidSettings.export_animated_mesh -> use_animated_mesh:   boolean  "Export this mesh as an animated one. Slower, only use if really necessary (e.g. armatures or parented objects), animated pos/rot/scale IPOs do not require it"
+ * FluidSettings|ObstacleFluidSettings.volume_initialization -> volume_initialization:   enum  "Volume initialization type"
+ * FluidSettings|OutflowFluidSettings.active -> use:   boolean  "Object contributes to the fluid simulation"
+ * FluidSettings|OutflowFluidSettings.export_animated_mesh -> use_animated_mesh:   boolean  "Export this mesh as an animated one. Slower, only use if really necessary (e.g. armatures or parented objects), animated pos/rot/scale IPOs do not require it"
+ * FluidSettings|OutflowFluidSettings.volume_initialization -> volume_initialization:   enum  "Volume initialization type"
+ * FluidSettings|ParticleFluidSettings.alpha_influence -> alpha_influence:   float  "Amount of particle alpha change, inverse of size influence: 0=off (all same alpha), 1=full. (large particles get lower alphas, smaller ones higher values)"
+ * FluidSettings|ParticleFluidSettings.path -> filepath:   string  "Directory (and/or filename prefix) to store and load particles from"
+ * FluidSettings|ParticleFluidSettings.particle_influence -> particle_influence:   float  "Amount of particle size scaling: 0=off (all same size), 1=full (range 0.2-2.0), >1=stronger"
+ * FluidSettings|ParticleFluidSettings.tracer -> show_tracer:   boolean  "Show tracer particles"
+ * FluidSettings|ParticleFluidSettings.drops -> use_drops:   boolean  "Show drop particles"
+ * FluidSettings|ParticleFluidSettings.floats -> use_floats:   boolean  "Show floating foam particles"
+ * Function.description -> description:   string,  "(read-only)    Description of the Functions purpose"
+ * Function.identifier -> identifier:   string,  "(read-only)    Unique name used in the code and scripting"
+ * Function.registered -> is_registered:   boolean,  "(read-only)    Function is registered as callback as part of type registration"
+ * Function.registered_optional -> is_registered_optional:   boolean,  "(read-only)    Function is optionally registered as callback part of type registration"
+ * Function.parameters -> parameters:   collection,  "(read-only)    Parameters for the function"
+ * GPencilFrame.frame_number -> frame_number:   int  "The frame on which this sketch appears"
+ * GPencilFrame.paint_lock -> is_edited:   boolean  "Frame is being edited (painted on)"
+ * GPencilFrame.select -> select:   boolean  "Frame is selected for editing in the DopeSheet"
+ * GPencilFrame.strokes -> strokes:   collection,  "(read-only)    Freehand curves defining the sketch on this frame"
+ * GPencilLayer.active -> active:   boolean  "Set active layer for editing"
+ * GPencilLayer.active_frame -> active_frame:   pointer,  "(read-only)    Frame currently being displayed for this layer"
+ * GPencilLayer.opacity -> alpha:   float  "Layer Opacity"
+ * GPencilLayer.color -> color:   float[3]  "Color for all strokes in this layer"
+ * GPencilLayer.frames -> frames:   collection,  "(read-only)    Sketches for this layer on different frames"
+ * GPencilLayer.max_ghost_range -> ghost_range_max:   int  "Maximum number of frames on either side of the active frame to show (0 = show the first available sketch on either side)"
+ * GPencilLayer.hide -> hide:   boolean  "Set layer Visibility"
+ * GPencilLayer.info -> info:   string  "Layer name"
+ * GPencilLayer.line_thickness -> line_width:   int  "Thickness of strokes (in pixels)"
+ * GPencilLayer.lock -> lock:   boolean  "Protect layer from further editing and/or frame changes"
+ * GPencilLayer.frame_lock -> lock_frame:   boolean  "Lock current frame displayed by layer"
+ * GPencilLayer.select -> select:   boolean  "Layer is selected for editing in the DopeSheet"
+ * GPencilLayer.show_points -> show_points:   boolean  "Draw the points which make up the strokes (for debugging purposes)"
+ * GPencilLayer.use_onion_skinning -> use_onion_skinning:   boolean  "Ghost frames on either side of frame"
+ * GPencilStroke.points -> points:   collection,  "(read-only)    Stroke data points"
+ * GPencilStrokePoint.co -> co:   float[3]  "NO DESCRIPTION"
+ * GPencilStrokePoint.pressure -> pressure:   float  "Pressure of tablet at point when drawing it"
+ * GameObjectSettings.actuators -> actuators:   collection,  "(read-only)    Game engine actuators to act on events"
+ * GameObjectSettings.collision_bounds -> collision_bounds_type:   enum  "Selects the collision type"
+ * GameObjectSettings.collision_margin -> collision_margin:   float  "Extra margin around object for collision detection, small amount required for stability"
+ * GameObjectSettings.controllers -> controllers:   collection,  "(read-only)    Game engine controllers to process events, connecting sensor to actuators"
+ * GameObjectSettings.damping -> damping:   float  "General movement damping"
+ * GameObjectSettings.form_factor -> form_factor:   float  "Form factor scales the inertia tensor"
+ * GameObjectSettings.friction_coefficients -> friction_coefficients:   float[3]  "Relative friction coefficient in the in the X, Y and Z directions, when anisotropic friction is enabled"
+ * GameObjectSettings.lock_x_axis -> lock_location_x:   boolean  "Disable simulation of linear motion along the X axis"
+ * GameObjectSettings.lock_y_axis -> lock_location_y:   boolean  "Disable simulation of linear motion along the Y axis"
+ * GameObjectSettings.lock_z_axis -> lock_location_z:   boolean  "Disable simulation of linear motion along the Z axis"
+ * GameObjectSettings.lock_x_rot_axis -> lock_rotation_x:   boolean  "Disable simulation of angular  motion along the X axis"
+ * GameObjectSettings.lock_y_rot_axis -> lock_rotation_y:   boolean  "Disable simulation of angular  motion along the Y axis"
+ * GameObjectSettings.lock_z_rot_axis -> lock_rotation_z:   boolean  "Disable simulation of angular  motion along the Z axis"
+ * GameObjectSettings.mass -> mass:   float  "Mass of the object"
+ * GameObjectSettings.physics_type -> physics_type:   enum  "Selects the type of physical representation"
+ * GameObjectSettings.properties -> properties:   collection,  "(read-only)    Game engine properties"
+ * GameObjectSettings.radius -> radius:   float  "Radius of bounding sphere and material physics"
+ * GameObjectSettings.rotation_damping -> rotation_damping:   float  "General rotation damping"
+ * GameObjectSettings.sensors -> sensors:   collection,  "(read-only)    Game engine sensor to detect events"
+ * GameObjectSettings.show_actuators -> show_actuators:   boolean  "Shows actuators for this object in the user interface"
+ * GameObjectSettings.show_controllers -> show_controllers:   boolean  "Shows controllers for this object in the user interface"
+ * GameObjectSettings.debug_state -> show_debug_state:   boolean  "Print state debug info in the game engine"
+ * GameObjectSettings.show_sensors -> show_sensors:   boolean  "Shows sensors for this object in the user interface"
+ * GameObjectSettings.show_state_panel -> show_state_panel:   boolean  "Show state panel"
+ * GameObjectSettings.soft_body -> soft_body:   pointer,  "(read-only)    Settings for Bullet soft body simulation"
+ * GameObjectSettings.initial_state -> states_initial:   boolean[30]  "Initial state when the game starts"
+ * GameObjectSettings.used_state -> states_used:   boolean[30],  "(read-only)    States which are being used by controllers"
+ * GameObjectSettings.visible_state -> states_visible:   boolean[30]  "State determining which controllers are displayed"
+ * GameObjectSettings.use_activity_culling -> use_activity_culling:   boolean  "Disable simulation of angular  motion along the Z axis"
+ * GameObjectSettings.actor -> use_actor:   boolean  "Object is detected by the Near and Radar sensor"
+ * GameObjectSettings.all_states -> use_all_states:   boolean  "Set all state bits"
+ * GameObjectSettings.anisotropic_friction -> use_anisotropic_friction:   boolean  "Enable anisotropic friction"
+ * GameObjectSettings.use_collision_bounds -> use_collision_bounds:   boolean  "Specify a collision bounds type other than the default"
+ * GameObjectSettings.collision_compound -> use_collision_compound:   boolean  "Add children to form a compound collision object"
+ * GameObjectSettings.ghost -> use_ghost:   boolean  "Object does not restitute collisions, like a ghost"
+ * GameObjectSettings.material_physics -> use_material_physics:   boolean  "Use physics settings in materials"
+ * GameObjectSettings.rotate_from_normal -> use_rotate_from_normal:   boolean  "Use face normal to rotate object, so that it points away from the surface"
+NEGATE * GameObjectSettings.no_sleeping -> use_sleep:   boolean  "Disable auto (de)activation in physics simulation"
+ * GameObjectSettings.maximum_velocity -> velocity_max:   float  "Clamp velocity to this maximum speed"
+ * GameObjectSettings.minimum_velocity -> velocity_min:   float  "Clamp velocity to this minimum speed (except when totally still)"
+ * GameProperty.name -> name:   string  "Available as GameObject attributes in the game engines python API"
+ * GameProperty.debug -> show_debug:   boolean  "Print debug information for this property"
+ * GameProperty.type -> type:   enum  "NO DESCRIPTION"
+ * GameProperty|GameBooleanProperty.value -> value:   boolean  "Property value"
+ * GameProperty|GameFloatProperty.value -> value:   float  "Property value"
+ * GameProperty|GameIntProperty.value -> value:   int  "Property value"
+ * GameProperty|GameStringProperty.value -> value:   string  "Property value"
+ * GameProperty|GameTimerProperty.value -> value:   float  "Property value"
+ * GameSoftBodySettings.cluster_iterations -> cluster_iterations:   int  "Specify the number of cluster iterations"
+ * GameSoftBodySettings.margin -> collision_margin:   float  "Collision margin for soft body. Small value makes the algorithm unstable"
+ * GameSoftBodySettings.dynamic_friction -> dynamic_friction:   float  "Dynamic Friction"
+ * GameSoftBodySettings.linstiff -> linear_stiffness:   float  "Linear stiffness of the soft body links"
+ * GameSoftBodySettings.position_iterations -> location_iterations:   int  "Position solver iterations"
+ * GameSoftBodySettings.threshold -> shape_threshold:   float  "Shape matching threshold"
+ * GameSoftBodySettings.bending_const -> use_bending_constraints:   boolean  "Enable bending constraints"
+ * GameSoftBodySettings.cluster_rigid_to_softbody -> use_cluster_rigid_to_softbody:   boolean  "Enable cluster collision between soft and rigid body"
+ * GameSoftBodySettings.cluster_soft_to_softbody -> use_cluster_soft_to_softbody:   boolean  "Enable cluster collision between soft and soft body"
+ * GameSoftBodySettings.shape_match -> use_shape_match:   boolean  "Enable soft body shape matching goal"
+ * GameSoftBodySettings.welding -> weld_threshold:   float  "Welding threshold: distance between nearby vertices to be considered equal => set to 0.0 to disable welding test and speed up scene loading (ok if the mesh has no duplicates)"
+ * Header.bl_idname -> bl_idname:   string  "If this is set, the header gets a custom ID, otherwise it takes the name of the class used to define the panel. For example, if the class name is OBJECT_HT_hello, and bl_idname is not set by the script, then bl_idname = OBJECT_HT_hello"
+ * Header.bl_space_type -> bl_space_type:   enum  "The space where the header is going to be used in."
+ * Header.layout -> layout:   pointer,  "(read-only)    Defines the structure of the header in the UI."
+ * Histogram.mode -> mode:   enum  "Channels to display when drawing the histogram"
+ * ID.library -> library:   pointer,  "(read-only)    Library file the datablock is linked from"
+ * ID.name -> name:   string  "Unique datablock ID name"
+ * ID.tag -> tag:   boolean  "Tools can use this to tag data, (initial state is undefined)"
+ * ID.fake_user -> use_fake_user:   boolean  "Saves this datablock even if it has no users"
+ * ID.users -> users:   int,  "(read-only)    Number of times this datablock is referenced"
+ * IDProperty.collection -> collection:   collection,  "(read-only)"
+ * IDProperty.double -> double:   float  "NO DESCRIPTION"
+ * IDProperty.double_array -> double_array:   float[1]  "NO DESCRIPTION"
+ * IDProperty.float -> float:   float  "NO DESCRIPTION"
+ * IDProperty.float_array -> float_array:   float[1]  "NO DESCRIPTION"
+ * IDProperty.group -> group:   pointer,  "(read-only)"
+ * IDProperty.int -> int:   int  "NO DESCRIPTION"
+ * IDProperty.int_array -> int_array:   int[1]  "NO DESCRIPTION"
+ * IDProperty.string -> string:   string  "NO DESCRIPTION"
+ * IDPropertyGroup.name -> name:   string  "Unique name used in the code and scripting"
+ * IDPropertyGroup|NetRenderJob.name -> name:   string  "NO DESCRIPTION"
+ * IDPropertyGroup|NetRenderSettings.active_blacklisted_slave_index -> active_blacklisted_slave_index:   int  "NO DESCRIPTION"
+ * IDPropertyGroup|NetRenderSettings.active_job_index -> active_job_index:   int  "NO DESCRIPTION"
+ * IDPropertyGroup|NetRenderSettings.active_slave_index -> active_slave_index:   int  "NO DESCRIPTION"
+ * IDPropertyGroup|NetRenderSettings.chunks -> chunks:   int  "Number of frame to dispatch to each slave in one chunk"
+ * IDPropertyGroup|NetRenderSettings.job_category -> job_category:   string  "Category of the job"
+ * IDPropertyGroup|NetRenderSettings.job_id -> job_id:   string  "id of the last sent render job"
+ * IDPropertyGroup|NetRenderSettings.job_name -> job_name:   string  "Name of the job"
+ * IDPropertyGroup|NetRenderSettings.jobs -> jobs:   collection,  "(read-only)"
+ * IDPropertyGroup|NetRenderSettings.mode -> mode:   enum  "Mode of operation of this instance"
+ * IDPropertyGroup|NetRenderSettings.path -> path:   string  "Path for temporary files"
+ * IDPropertyGroup|NetRenderSettings.priority -> priority:   int  "Priority of the job"
+ * IDPropertyGroup|NetRenderSettings.server_address -> server_address:   string  "IP or name of the master render server"
+ * IDPropertyGroup|NetRenderSettings.server_port -> server_port:   int  "port of the master render server"
+ * IDPropertyGroup|NetRenderSettings.slaves -> slaves:   collection,  "(read-only)"
+ * IDPropertyGroup|NetRenderSettings.slaves_blacklist -> slaves_blacklist:   collection,  "(read-only)"
+ * IDPropertyGroup|NetRenderSettings.master_broadcast -> use_master_broadcast:   boolean  "broadcast master server address on local network"
+ * IDPropertyGroup|NetRenderSettings.master_clear -> use_master_clear:   boolean  "delete saved files on exit"
+ * IDPropertyGroup|NetRenderSettings.slave_clear -> use_slave_clear:   boolean  "delete downloaded files on exit"
+ * IDPropertyGroup|NetRenderSettings.slave_outputlog -> use_slave_output_log:   boolean  "Output render text log to console as well as sending it to the master"
+ * IDPropertyGroup|NetRenderSettings.slave_thumb -> use_slave_thumb:   boolean  "Generate thumbnails on slaves instead of master"
+ * IDPropertyGroup|NetRenderSlave.name -> name:   string  "NO DESCRIPTION"
+ * IDPropertyGroup|OperatorFileListElement.name -> name:   string  "the name of a file or directory within a file list"
+ * IDPropertyGroup|OperatorMousePath.loc -> loc:   float[2]  "Mouse location"
+ * IDPropertyGroup|OperatorMousePath.time -> time:   float  "Time of mouse location"
+ * IDPropertyGroup|OperatorStrokeElement.location -> location:   float[3]  "NO DESCRIPTION"
+ * IDPropertyGroup|OperatorStrokeElement.mouse -> mouse:   float[2]  "NO DESCRIPTION"
+ * IDPropertyGroup|OperatorStrokeElement.pen_flip -> pen_flip:   boolean  "NO DESCRIPTION"
+ * IDPropertyGroup|OperatorStrokeElement.pressure -> pressure:   float  "Tablet pressure"
+ * IDPropertyGroup|OperatorStrokeElement.time -> time:   float  "NO DESCRIPTION"
+ * IDPropertyGroup|PoseTemplate.name -> name:   string  "NO DESCRIPTION"
+ * IDPropertyGroup|PoseTemplateSettings.active_template_index -> active_template_index:   int  "NO DESCRIPTION"
+ * IDPropertyGroup|PoseTemplateSettings.templates -> templates:   collection,  "(read-only)"
+ * IDPropertyGroup|PoseTemplateSettings.generate_def_rig -> use_generate_deform_rig:   boolean  "Create a copy of the metarig, constrainted by the generated rig"
+ * ID|Action.fcurves -> fcurves:   collection,  "(read-only)    The individual F-Curves that make up the Action"
+ * ID|Action.groups -> groups:   collection,  "(read-only)    Convenient groupings of F-Curves"
+ * ID|Action.pose_markers -> pose_markers:   collection,  "(read-only)    Markers specific to this Action, for labeling poses"
+ * ID|Armature.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Armature.bones -> bones:   collection,  "(read-only)"
+ * ID|Armature.drawtype -> draw_type:   enum  "NO DESCRIPTION"
+ * ID|Armature.edit_bones -> edit_bones:   collection,  "(read-only)"
+ * ID|Armature.ghost_frame_end -> ghost_frame_end:   int  "End frame of range of Ghosts to display (not for Around Current Frame Onion-skinning method)"
+ * ID|Armature.ghost_frame_start -> ghost_frame_start:   int  "Starting frame of range of Ghosts to display (not for Around Current Frame Onion-skinning method)"
+ * ID|Armature.ghost_size -> ghost_size:   int  "Frame step for Ghosts (not for On Keyframes Onion-skinning method)"
+ * ID|Armature.ghost_step -> ghost_step:   int  "Number of frame steps on either side of current frame to show as ghosts (only for Around Current Frame Onion-skinning method)"
+ * ID|Armature.ghost_type -> ghost_type:   enum  "Method of Onion-skinning for active Action"
+ * ID|Armature.layer -> layers:   boolean[32]  "Armature layer visibility"
+ * ID|Armature.layer_protection -> layers_protected:   boolean[32]  "Protected layers in Proxy Instances are restored to Proxy settings on file reload and undo"
+ * ID|Armature.pose_position -> pose_position:   enum  "Show armature in binding pose or final posed state"
+ * ID|Armature.draw_axes -> show_axes:   boolean  "Draw bone axes"
+ * ID|Armature.draw_custom_bone_shapes -> show_bone_custom_shapes:   boolean  "Draw bones with their custom shapes"
+ * ID|Armature.draw_group_colors -> show_group_colors:   boolean  "Draw bone group colors"
+ * ID|Armature.draw_names -> show_names:   boolean  "Draw bone names"
+ * ID|Armature.ghost_only_selected -> show_only_ghost_selected:   boolean  "NO DESCRIPTION"
+ * ID|Armature.auto_ik -> use_auto_ik:   boolean  "Add temporaral IK constraints while grabbing bones in Pose Mode"
+ * ID|Armature.delay_deform -> use_deform_delay:   boolean  "Dont deform children when manipulating bones in Pose Mode"
+ * ID|Armature.deform_envelope -> use_deform_envelopes:   boolean  "Enable Bone Envelopes when defining deform"
+ * ID|Armature.deform_quaternion -> use_deform_preserve_volume:   boolean  "Enable deform rotation with Quaternions"
+ * ID|Armature.deform_vertexgroups -> use_deform_vertex_groups:   boolean  "Enable Vertex Groups when defining deform"
+ * ID|Armature.x_axis_mirror -> use_mirror_x:   boolean  "Apply changes to matching bone on opposite side of X-Axis"
+ * ID|Brush.autosmooth_factor -> auto_smooth_factor:   float  "Amount of smoothing to automatically apply to each stroke"
+ * ID|Brush.blend -> blend:   enum  "Brush blending mode"
+ * ID|Brush.clone_alpha -> clone_alpha:   float  "Opacity of clone image display"
+ * ID|Brush.clone_image -> clone_image:   pointer  "Image for clone tool"
+ * ID|Brush.clone_offset -> clone_offset:   float[2]  "NO DESCRIPTION"
+ * ID|Brush.color -> color:   float[3]  "NO DESCRIPTION"
+ * ID|Brush.crease_pinch_factor -> crease_pinch_factor:   float  "How much the crease brush pinches"
+ * ID|Brush.add_col -> cursor_color_add:   float[3]  "Color of cursor when adding"
+ * ID|Brush.sub_col -> cursor_color_subtract:   float[3]  "Color of cursor when subtracting"
+ * ID|Brush.curve -> curve:   pointer,  "(read-only)    Editable falloff curve"
+ * ID|Brush.direction -> direction:   enum  "NO DESCRIPTION"
+ * ID|Brush.icon_filepath -> icon_filepath:   string  "File path to brush icon"
+ * ID|Brush.imagepaint_tool -> imagepaint_tool:   enum  "NO DESCRIPTION"
+ * ID|Brush.jitter -> jitter:   float  "Jitter the position of the brush while painting"
+ * ID|Brush.normal_weight -> normal_weight:   float  "How much grab will pull vertexes out of surface during a grab"
+ * ID|Brush.plane_offset -> plane_offset:   float  "Adjusts plane on which the brush acts towards or away from the object surface"
+ * ID|Brush.plane_trim -> plane_trim:   float  "If a vertex is further from offset plane than this then it is not affected"
+ * ID|Brush.rate -> rate:   float  "Interval between paints for Airbrush"
+ * ID|Brush.sculpt_plane -> sculpt_plane:   enum  "NO DESCRIPTION"
+ * ID|Brush.sculpt_tool -> sculpt_tool:   enum  "NO DESCRIPTION"
+ * ID|Brush.size -> size:   int  "Radius of the brush in pixels"
+ * ID|Brush.smooth_stroke_factor -> smooth_stroke_factor:   float  "Higher values give a smoother stroke"
+ * ID|Brush.smooth_stroke_radius -> smooth_stroke_radius:   int  "Minimum distance from last point before stroke continues"
+ * ID|Brush.spacing -> spacing:   int  "Spacing between brush daubs as a percentage of brush diameter"
+ * ID|Brush.strength -> strength:   float  "How powerful the effect of the brush is when applied"
+ * ID|Brush.stroke_method -> stroke_method:   enum  "NO DESCRIPTION"
+ * ID|Brush.texture -> texture:   pointer  "NO DESCRIPTION"
ID|Brush.texture_angle_source_no_random -> texture_angle_source_no_random:   enum  "NO DESCRIPTION"
+ * ID|Brush.texture_angle_source -> texture_angle_source_random:   enum  "NO DESCRIPTION"
+ * ID|Brush.texture_overlay_alpha -> texture_overlay_alpha:   int  "NO DESCRIPTION"
+ * ID|Brush.texture_sample_bias -> texture_sample_bias:   float  "Value added to texture samples"
+ * ID|Brush.texture_slot -> texture_slot:   pointer,  "(read-only)"
+ * ID|Brush.unprojected_radius -> unprojected_radius:   float  "Radius of brush in Blender units"
+ * ID|Brush.use_accumulate -> use_accumulate:   boolean  "Accumulate stroke dabs on top of each other"
+ * ID|Brush.use_adaptive_space -> use_adaptive_space:   boolean  "Space daubs according to surface orientation instead of screen space"
+ * ID|Brush.use_airbrush -> use_airbrush:   boolean  "Keep applying paint effect while holding mouse (spray)"
+ * ID|Brush.use_alpha -> use_alpha:   boolean  "When this is disabled, lock alpha while painting"
+ * ID|Brush.use_anchor -> use_anchor:   boolean  "Keep the brush anchored to the initial location"
+ * ID|Brush.use_custom_icon -> use_custom_icon:   boolean  "Set the brush icon from an image file"
+ * ID|Brush.edge_to_edge -> use_edge_to_edge:   boolean  "Drag anchor brush from edge-to-edge"
+ * ID|Brush.use_frontface -> use_frontface:   boolean  "Brush only affects vertexes that face the viewer"
+ * ID|Brush.use_inverse_smooth_pressure -> use_inverse_smooth_pressure:   boolean  "Lighter pressure causes more smoothing to be applied"
+ * ID|Brush.use_locked_size -> use_locked_size:   boolean  "When locked brush stays same size relative to object; when unlocked brush size is given in pixels"
+ * ID|Brush.use_offset_pressure -> use_offset_pressure:   boolean  "Enable tablet pressure sensitivity for offset"
+ * ID|Brush.use_original_normal -> use_original_normal:   boolean  "When locked keep using normal of surface where stroke was initiated"
+ * ID|Brush.use_paint_sculpt -> use_paint_sculpt:   boolean  "Use this brush in sculpt mode"
+ * ID|Brush.use_paint_texture -> use_paint_texture:   boolean  "Use this brush in texture paint mode"
+ * ID|Brush.use_paint_vertex -> use_paint_vertex:   boolean  "Use this brush in vertex paint mode"
+ * ID|Brush.use_paint_weight -> use_paint_weight:   boolean  "Use this brush in weight paint mode"
+ * ID|Brush.use_persistent -> use_persistent:   boolean  "Sculpts on a persistent layer of the mesh"
+ * ID|Brush.use_plane_trim -> use_plane_trim:   boolean  "Enable Plane Trim"
+ * ID|Brush.use_jitter_pressure -> use_pressure_jitter:   boolean  "Enable tablet pressure sensitivity for jitter"
+ * ID|Brush.use_size_pressure -> use_pressure_size:   boolean  "Enable tablet pressure sensitivity for size"
+ * ID|Brush.use_spacing_pressure -> use_pressure_spacing:   boolean  "Enable tablet pressure sensitivity for spacing"
+ * ID|Brush.use_strength_pressure -> use_pressure_strength:   boolean  "Enable tablet pressure sensitivity for strength"
+ * ID|Brush.use_rake -> use_rake:   boolean  "Rotate the brush texture to match the stroke direction"
+ * ID|Brush.use_random_rotation -> use_random_rotation:   boolean  "Rotate the brush texture at random"
+ * ID|Brush.restore_mesh -> use_restore_mesh:   boolean  "Allows a single dot to be carefully positioned"
+ * ID|Brush.use_smooth_stroke -> use_smooth_stroke:   boolean  "Brush lags behind mouse and follows a smoother path"
+ * ID|Brush.use_space -> use_space:   boolean  "Limit brush application to the distance specified by spacing"
+ * ID|Brush.use_space_atten -> use_space_atten:   boolean  "Automatically adjusts strength to give consistent results for different spacings"
+ * ID|Brush.use_texture_overlay -> use_texture_overlay:   boolean  "Show texture in viewport"
+ * ID|Brush.use_wrap -> use_wrap:   boolean  "Enable torus wrapping while painting"
+ * ID|Brush.vertexpaint_tool -> vertexpaint_tool:   enum  "NO DESCRIPTION"
+ * ID|Camera.angle -> angle:   float  "Perspective Camera lens field of view in degrees"
+ * ID|Camera.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Camera.clip_end -> clip_end:   float  "Camera far clipping distance"
+ * ID|Camera.clip_start -> clip_start:   float  "Camera near clipping distance"
+ * ID|Camera.dof_distance -> dof_distance:   float  "Distance to the focus point for depth of field"
+ * ID|Camera.dof_object -> dof_object:   pointer  "Use this object to define the depth of field focal point"
+ * ID|Camera.draw_size -> draw_size:   float  "Apparent size of the Camera object in the 3D View"
+ * ID|Camera.lens -> lens:   float  "Perspective Camera lens value in millimeters"
+ * ID|Camera.lens_unit -> lens_unit:   enum  "Unit to edit lens in for the user interface"
+ * ID|Camera.ortho_scale -> ortho_scale:   float  "Orthographic Camera scale (similar to zoom)"
+ * ID|Camera.passepartout_alpha -> passepartout_alpha:   float  "Opacity (alpha) of the darkened overlay in Camera view"
+ * ID|Camera.shift_x -> shift_x:   float  "Perspective Camera horizontal shift"
+ * ID|Camera.shift_y -> shift_y:   float  "Perspective Camera vertical shift"
+ * ID|Camera.show_limits -> show_limits:   boolean  "Draw the clipping range and focus point on the camera"
+ * ID|Camera.show_mist -> show_mist:   boolean  "Draw a line from the Camera to indicate the mist area"
+ * ID|Camera.show_name -> show_name:   boolean  "Show the active Cameras name in Camera view"
+ * ID|Camera.show_passepartout -> show_passepartout:   boolean  "Show a darkened overlay outside the image area in Camera view"
+ * ID|Camera.show_title_safe -> show_title_safe:   boolean  "Show indicators for the title safe zone in Camera view"
+ * ID|Camera.type -> type:   enum  "Camera types"
+ * ID|Camera.panorama -> use_panorama:   boolean  "Render the scene with a cylindrical camera for pseudo-fisheye lens effects"
+ * ID|Curve.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Curve.bevel_depth -> bevel_depth:   float  "Bevel depth when not using a bevel object"
+ * ID|Curve.bevel_object -> bevel_object:   pointer  "Curve object name that defines the bevel shape"
+ * ID|Curve.bevel_resolution -> bevel_resolution:   int  "Bevel resolution when depth is non-zero and no specific bevel object has been defined"
+ * ID|Curve.dimensions -> dimensions:   enum  "Select 2D or 3D curve type"
+ * ID|Curve.eval_time -> eval_time:   float  "Parametric position along the length of the curve that Objects following it should be at. Position is evaluated by dividing by the Path Length value"
+ * ID|Curve.extrude -> extrude:   float  "Amount of curve extrusion when not using a bevel object"
+ * ID|Curve.materials -> materials:   collection,  "(read-only)"
+ * ID|Curve.width -> offset:   float  "Scale the original width (1.0) based on given factor"
+ * ID|Curve.path_length -> path_duration:   int  "The number of frames that are needed to traverse the path, defining the maximum value for the Evaluation Time setting"
+ * ID|Curve.render_resolution_u -> render_resolution_u:   int  "Surface resolution in U direction used while rendering. Zero skips this property"
+ * ID|Curve.render_resolution_v -> render_resolution_v:   int  "Surface resolution in V direction used while rendering. Zero skips this property"
+ * ID|Curve.resolution_u -> resolution_u:   int  "Surface resolution in U direction"
+ * ID|Curve.resolution_v -> resolution_v:   int  "Surface resolution in V direction"
+ * ID|Curve.shape_keys -> shape_keys:   pointer,  "(read-only)"
+ * ID|Curve.draw_handles -> show_handles:   boolean  "Display bezier handles in editmode"
+ * ID|Curve.draw_normals -> show_normals:   boolean  "Display 3D curve normals in editmode"
+ * ID|Curve.splines -> splines:   collection,  "(read-only)    Collection of splines in this curve data object"
+ * ID|Curve.taper_object -> taper_object:   pointer  "Curve object name that defines the taper (width)"
ID|Curve.texspace_loc -> texspace_location:   float[3]  "Texture space location"
+ * ID|Curve.texspace_size -> texspace_size:   float[3]  "Texture space size"
+ * ID|Curve.twist_mode -> twist_mode:   enum  "The type of tilt calculation for 3D Curves"
+ * ID|Curve.twist_smooth -> twist_smooth:   float  "Smoothing iteration for tangents"
+ * ID|Curve.auto_texspace -> use_auto_texspace:   boolean  "Adjusts active objects texture space automatically when transforming object"
+ * ID|Curve.use_deform_bounds -> use_deform_bounds:   boolean  "Use the mesh bounds to clamp the deformation"
+ * ID|Curve.back -> use_fill_back:   boolean  "Draw filled back for extruded/beveled curves"
+ * ID|Curve.use_deform_fill -> use_fill_deform:   boolean  "Fill curve after applying deformation"
+ * ID|Curve.front -> use_fill_front:   boolean  "Draw filled front for extruded/beveled curves"
+ * ID|Curve.map_along_length -> use_map_on_length:   boolean  "Generate texture mapping coordinates following the curve direction, rather than the local bounding box"
+ * ID|Curve.use_path -> use_path:   boolean  "Enable the curve to become a translation path"
+ * ID|Curve.use_path_follow -> use_path_follow:   boolean  "Make curve path children to rotate along the path"
+ * ID|Curve.use_radius -> use_radius:   boolean  "Option for paths: apply the curve radius with path following it and deforming"
+ * ID|Curve.use_stretch -> use_stretch:   boolean  "Option for curve-deform: makes deformed child to stretch along entire path"
+ * ID|Curve.use_time_offset -> use_time_offset:   boolean  "Children will use TimeOffs value as path distance offset"
+ * ID|Curve|SurfaceCurve.map_along_length -> use_map_on_length:   boolean  "Generate texture mapping coordinates following the curve direction, rather than the local bounding box"
MAKE COLLECTION ATTR * ID|Curve|TextCurve.active_textbox -> active_textbox:   int  "NO DESCRIPTION"
+ * ID|Curve|TextCurve.spacemode -> align:   enum  "Text align from the object center"
+ * ID|Curve|TextCurve.body -> body:   string  "contents of this text object"
+ * ID|Curve|TextCurve.body_format -> body_format:   collection,  "(read-only)    Stores the style of each character"
+ * ID|Curve|TextCurve.edit_format -> edit_format:   pointer,  "(read-only)    Editing settings character formatting"
+ * ID|Curve|TextCurve.family -> family:   string  "Use Blender Objects as font characters. Give font objects a common name followed by the character it represents, eg. familya, familyb etc, and turn on Verts Duplication"
+ * ID|Curve|TextCurve.text_on_curve -> follow_curve:   pointer  "Curve deforming text object"
+ * ID|Curve|TextCurve.font -> font:   pointer  "NO DESCRIPTION"
+ * ID|Curve|TextCurve.offset_x -> offset_x:   float  "Horizontal offset from the object origin"
+ * ID|Curve|TextCurve.offset_y -> offset_y:   float  "Vertical offset from the object origin"
+ * ID|Curve|TextCurve.shear -> shear:   float  "Italic angle of the characters"
+ * ID|Curve|TextCurve.text_size -> size:   float  "NO DESCRIPTION"
+ * ID|Curve|TextCurve.small_caps_scale -> small_caps_scale:   float  "Scale of small capitals"
+ * ID|Curve|TextCurve.spacing -> space_character:   float  "NO DESCRIPTION"
+ * ID|Curve|TextCurve.line_dist -> space_line:   float  "NO DESCRIPTION"
+ * ID|Curve|TextCurve.word_spacing -> space_word:   float  "NO DESCRIPTION"
+ * ID|Curve|TextCurve.textboxes -> text_boxes:   collection,  "(read-only)"
+ * ID|Curve|TextCurve.ul_height -> underline_height:   float  "NO DESCRIPTION"
+ * ID|Curve|TextCurve.ul_position -> underline_position:   float  "Vertical position of underline"
+ * ID|Curve|TextCurve.fast -> use_fast_edit:   boolean  "Dont fill polygons while editing"
+ * ID|Curve|TextCurve.map_along_length -> use_map_on_length:   boolean  "Generate texture mapping coordinates following the curve direction, rather than the local bounding box"
+ * ID|GreasePencil.draw_mode -> draw_mode:   enum  "NO DESCRIPTION"
+ * ID|GreasePencil.layers -> layers:   collection,  "(read-only)"
+ * ID|GreasePencil.use_stroke_endpoints -> use_stroke_endpoints:   boolean  "Only use the first and last parts of the stroke for snapping"
+ * ID|Group.dupli_offset -> dupli_offset:   float[3]  "Offset from the origin to use when instancing as DupliGroup"
+ * ID|Group.layer -> layers:   boolean[20]  "Layers visible when this groups is instanced as a dupli"
+ * ID|Group.objects -> objects:   collection,  "(read-only)    A collection of this groups objects"
+ * ID|Image.bindcode -> bindcode:   int,  "(read-only)    OpenGL bindcode"
+ * ID|Image.depth -> depth:   int,  "(read-only)    Image bit depth"
+ * ID|Image.display_aspect -> display_aspect:   float[2]  "Display Aspect for this image, does not affect rendering"
+ * ID|Image.field_order -> field_order:   enum  "Order of video fields. Select which lines are displayed first"
+ * ID|Image.file_format -> file_format:   enum  "Format used for re-saving this file"
+ * ID|Image.filepath -> filepath:   string  "Image/Movie file name"
+ * ID|Image.filepath_raw -> filepath_raw:   string  "Image/Movie file name (without data refreshing)"
+ * ID|Image.animation_speed -> fps:   int  "Speed of the animation in frames per second"
+ * ID|Image.animation_end -> frame_end:   int  "End frame of an animated texture"
+ * ID|Image.animation_start -> frame_start:   int  "Start frame of an animated texture"
+ * ID|Image.generated_height -> generated_height:   int  "Generated image height"
+ * ID|Image.generated_type -> generated_type:   enum  "Generated image type"
+ * ID|Image.generated_width -> generated_width:   int  "Generated image width"
+ * ID|Image.has_data -> has_data:   boolean,  "(read-only)    True if this image has data"
+ * ID|Image.dirty -> is_dirty:   boolean,  "(read-only)    Image has changed and is not saved"
+ * ID|Image.mapping -> mapping:   enum  "Mapping type to use for this image in the game engine"
+ * ID|Image.packed_file -> packed_file:   pointer,  "(read-only)"
+ * ID|Image.size -> size:   int[2],  "(read-only)    Width and height in pixels, zero when image data cant be loaded"
+ * ID|Image.source -> source:   enum  "Where the image comes from"
+ * ID|Image.tiles_x -> tiles_x:   int  "Degree of repetition in the X direction"
+ * ID|Image.tiles_y -> tiles_y:   int  "Degree of repetition in the Y direction"
+ * ID|Image.type -> type:   enum,  "(read-only)    How to generate the image"
+ * ID|Image.animated -> use_animation:   boolean  "Use as animated texture in the game engine"
+ * ID|Image.clamp_x -> use_clamp_x:   boolean  "Disable texture repeating horizontally"
+ * ID|Image.clamp_y -> use_clamp_y:   boolean  "Disable texture repeating vertically"
+ * ID|Image.fields -> use_fields:   boolean  "Use fields of the image"
+ * ID|Image.premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
+ * ID|Image.tiles -> use_tiles:   boolean  "Use of tilemode for faces (default shift-LMB to pick the tile for selected faces)"
+ * ID|Key.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Key.keys -> keys:   collection,  "(read-only)    Shape keys"
+ * ID|Key.reference_key -> reference_key:   pointer,  "(read-only)"
+ * ID|Key.slurph -> slurph:   int  "Creates a delay in amount of frames in applying keypositions, first vertex goes first"
+ * ID|Key.relative -> use_relative:   boolean  "Makes shape keys relative"
+ * ID|Key.user -> user:   pointer,  "(read-only)    Datablock using these shape keys"
+ * ID|Lamp.active_texture -> active_texture:   pointer  "Active texture slot being displayed"
+ * ID|Lamp.active_texture_index -> active_texture_index:   int  "Index of active texture slot"
+ * ID|Lamp.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Lamp.color -> color:   float[3]  "Light color"
+ * ID|Lamp.distance -> distance:   float  "Falloff distance - the light is at half the original intensity at this point"
+ * ID|Lamp.energy -> energy:   float  "Amount of light that the lamp emits"
+ * ID|Lamp.texture_slots -> texture_slots:   collection,  "(read-only)    Texture slots defining the mapping and influence of textures"
+ * ID|Lamp.type -> type:   enum  "Type of Lamp"
+ * ID|Lamp.diffuse -> use_diffuse:   boolean  "Lamp does diffuse shading"
+ * ID|Lamp.negative -> use_negative:   boolean  "Lamp casts negative light"
+ * ID|Lamp.layer -> use_own_layer:   boolean  "Illuminates objects only on the same layer the lamp is on"
+ * ID|Lamp.specular -> use_specular:   boolean  "Lamp creates specular highlights"
+ * ID|Lamp|AreaLamp.gamma -> gamma:   float  "Light gamma correction value"
+ * ID|Lamp|AreaLamp.shadow_adaptive_threshold -> shadow_adaptive_threshold:   float  "Threshold for Adaptive Sampling (Raytraced shadows)"
+ * ID|Lamp|AreaLamp.shadow_color -> shadow_color:   float[3]  "Color of shadows cast by the lamp"
+ * ID|Lamp|AreaLamp.shadow_method -> shadow_method:   enum  "Method to compute lamp shadow with"
+ * ID|Lamp|AreaLamp.shadow_ray_sampling_method -> shadow_ray_sample_method:   enum  "Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower"
+ * ID|Lamp|AreaLamp.shadow_ray_samples_x -> shadow_ray_samples_x:   int  "Amount of samples taken extra (samples x samples)"
+ * ID|Lamp|AreaLamp.shadow_ray_samples_y -> shadow_ray_samples_y:   int  "Amount of samples taken extra (samples x samples)"
+ * ID|Lamp|AreaLamp.shadow_soft_size -> shadow_soft_size:   float  "Light size for ray shadow sampling (Raytraced shadows)"
+ * ID|Lamp|AreaLamp.shape -> shape:   enum  "Shape of the area lamp"
+ * ID|Lamp|AreaLamp.size -> size:   float  "Size of the area of the area Lamp, X direction size for Rectangle shapes"
+ * ID|Lamp|AreaLamp.size_y -> size_y:   float  "Size of the area of the area Lamp in the Y direction for Rectangle shapes"
+ * ID|Lamp|AreaLamp.dither -> use_dither:   boolean  "Use 2x2 dithering for sampling  (Constant Jittered sampling)"
+ * ID|Lamp|AreaLamp.jitter -> use_jitter:   boolean  "Use noise for sampling  (Constant Jittered sampling)"
+ * ID|Lamp|AreaLamp.only_shadow -> use_only_shadow:   boolean  "Causes light to cast shadows only without illuminating objects"
+ * ID|Lamp|AreaLamp.shadow_layer -> use_shadow_layer:   boolean  "Causes only objects on the same layer to cast shadows"
+ * ID|Lamp|AreaLamp.umbra -> use_umbra:   boolean  "Emphasize parts that are fully shadowed (Constant Jittered sampling)"
+ * ID|Lamp|PointLamp.falloff_curve -> falloff_curve:   pointer,  "(read-only)    Custom Lamp Falloff Curve"
+ * ID|Lamp|PointLamp.falloff_type -> falloff_type:   enum  "Intensity Decay with distance"
+ * ID|Lamp|PointLamp.linear_attenuation -> linear_attenuation:   float  "Linear distance attenuation"
+ * ID|Lamp|PointLamp.quadratic_attenuation -> quadratic_attenuation:   float  "Quadratic distance attenuation"
+ * ID|Lamp|PointLamp.shadow_adaptive_threshold -> shadow_adaptive_threshold:   float  "Threshold for Adaptive Sampling (Raytraced shadows)"
+ * ID|Lamp|PointLamp.shadow_color -> shadow_color:   float[3]  "Color of shadows cast by the lamp"
+ * ID|Lamp|PointLamp.shadow_method -> shadow_method:   enum  "Method to compute lamp shadow with"
+ * ID|Lamp|PointLamp.shadow_ray_sampling_method -> shadow_ray_sample_method:   enum  "Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower"
+ * ID|Lamp|PointLamp.shadow_ray_samples -> shadow_ray_samples:   int  "Amount of samples taken extra (samples x samples)"
+ * ID|Lamp|PointLamp.shadow_soft_size -> shadow_soft_size:   float  "Light size for ray shadow sampling (Raytraced shadows)"
+ * ID|Lamp|PointLamp.only_shadow -> use_only_shadow:   boolean  "Causes light to cast shadows only without illuminating objects"
+ * ID|Lamp|PointLamp.shadow_layer -> use_shadow_layer:   boolean  "Causes only objects on the same layer to cast shadows"
+ * ID|Lamp|PointLamp.sphere -> use_sphere:   boolean  "Sets light intensity to zero beyond lamp distance"
+ * ID|Lamp|SpotLamp.compression_threshold -> compression_threshold:   float  "Deep shadow map compression threshold"
+ * ID|Lamp|SpotLamp.falloff_curve -> falloff_curve:   pointer,  "(read-only)    Custom Lamp Falloff Curve"
+ * ID|Lamp|SpotLamp.falloff_type -> falloff_type:   enum  "Intensity Decay with distance"
+ * ID|Lamp|SpotLamp.halo_intensity -> halo_intensity:   float  "Brightness of the spotlights halo cone  (Buffer Shadows)"
+ * ID|Lamp|SpotLamp.halo_step -> halo_step:   int  "Volumetric halo sampling frequency"
+ * ID|Lamp|SpotLamp.linear_attenuation -> linear_attenuation:   float  "Linear distance attenuation"
+ * ID|Lamp|SpotLamp.quadratic_attenuation -> quadratic_attenuation:   float  "Quadratic distance attenuation"
+ * ID|Lamp|SpotLamp.shadow_adaptive_threshold -> shadow_adaptive_threshold:   float  "Threshold for Adaptive Sampling (Raytraced shadows)"
+ * ID|Lamp|SpotLamp.shadow_buffer_bias -> shadow_buffer_bias:   float  "Shadow buffer sampling bias"
+ * ID|Lamp|SpotLamp.shadow_buffer_clip_end -> shadow_buffer_clip_end:   float  "Shadow map clip end beyond which objects will not generate shadows"
+ * ID|Lamp|SpotLamp.shadow_buffer_clip_start -> shadow_buffer_clip_start:   float  "Shadow map clip start: objects closer will not generate shadows"
+ * ID|Lamp|SpotLamp.shadow_buffer_samples -> shadow_buffer_samples:   int  "Number of shadow buffer samples"
+ * ID|Lamp|SpotLamp.shadow_buffer_size -> shadow_buffer_size:   int  "Resolution of the shadow buffer, higher values give crisper shadows but use more memory"
+ * ID|Lamp|SpotLamp.shadow_buffer_soft -> shadow_buffer_soft:   float  "Size of shadow buffer sampling area"
+ * ID|Lamp|SpotLamp.shadow_buffer_type -> shadow_buffer_type:   enum  "Type of shadow buffer"
+ * ID|Lamp|SpotLamp.shadow_color -> shadow_color:   float[3]  "Color of shadows cast by the lamp"
+ * ID|Lamp|SpotLamp.shadow_filter_type -> shadow_filter_type:   enum  "Type of shadow filter (Buffer Shadows)"
+ * ID|Lamp|SpotLamp.shadow_method -> shadow_method:   enum  "Method to compute lamp shadow with"
+ * ID|Lamp|SpotLamp.shadow_ray_sampling_method -> shadow_ray_sample_method:   enum  "Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower"
+ * ID|Lamp|SpotLamp.shadow_ray_samples -> shadow_ray_samples:   int  "Amount of samples taken extra (samples x samples)"
+ * ID|Lamp|SpotLamp.shadow_sample_buffers -> shadow_sample_buffers:   enum  "Number of shadow buffers to render for better AA, this increases memory usage"
+ * ID|Lamp|SpotLamp.shadow_soft_size -> shadow_soft_size:   float  "Light size for ray shadow sampling (Raytraced shadows)"
+ * ID|Lamp|SpotLamp.show_cone -> show_cone:   boolean  "Draw transparent cone in 3D view to visualize which objects are contained in it"
+ * ID|Lamp|SpotLamp.spot_blend -> spot_blend:   float  "The softness of the spotlight edge"
+ * ID|Lamp|SpotLamp.spot_size -> spot_size:   float  "Angle of the spotlight beam in degrees"
+ * ID|Lamp|SpotLamp.auto_clip_end -> use_auto_clip_end:   boolean  "Automatic calculation of clipping-end, based on visible vertices"
+ * ID|Lamp|SpotLamp.auto_clip_start -> use_auto_clip_start:   boolean  "Automatic calculation of clipping-start, based on visible vertices"
+ * ID|Lamp|SpotLamp.halo -> use_halo:   boolean  "Renders spotlight with a volumetric halo (Buffer Shadows)"
+ * ID|Lamp|SpotLamp.only_shadow -> use_only_shadow:   boolean  "Causes light to cast shadows only without illuminating objects"
+ * ID|Lamp|SpotLamp.shadow_layer -> use_shadow_layer:   boolean  "Causes only objects on the same layer to cast shadows"
+ * ID|Lamp|SpotLamp.sphere -> use_sphere:   boolean  "Sets light intensity to zero beyond lamp distance"
+ * ID|Lamp|SpotLamp.square -> use_square:   boolean  "Casts a square spot light shape"
+ * ID|Lamp|SunLamp.shadow_adaptive_threshold -> shadow_adaptive_threshold:   float  "Threshold for Adaptive Sampling (Raytraced shadows)"
+ * ID|Lamp|SunLamp.shadow_color -> shadow_color:   float[3]  "Color of shadows cast by the lamp"
+ * ID|Lamp|SunLamp.shadow_method -> shadow_method:   enum  "Method to compute lamp shadow with"
+ * ID|Lamp|SunLamp.shadow_ray_samples -> shadow_ray_samples:   int  "Amount of samples taken extra (samples x samples)"
+ * ID|Lamp|SunLamp.shadow_ray_sampling_method -> shadow_ray_sampling_method:   enum  "Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower"
+ * ID|Lamp|SunLamp.shadow_soft_size -> shadow_soft_size:   float  "Light size for ray shadow sampling (Raytraced shadows)"
+ * ID|Lamp|SunLamp.sky -> sky:   pointer,  "(read-only)    Sky related settings for sun lamps"
+ * ID|Lamp|SunLamp.only_shadow -> use_only_shadow:   boolean  "Causes light to cast shadows only without illuminating objects"
+ * ID|Lamp|SunLamp.shadow_layer -> use_shadow_layer:   boolean  "Causes only objects on the same layer to cast shadows"
+ * ID|Lattice.interpolation_type_u -> interpolation_type_u:   enum  "NO DESCRIPTION"
+ * ID|Lattice.interpolation_type_v -> interpolation_type_v:   enum  "NO DESCRIPTION"
+ * ID|Lattice.interpolation_type_w -> interpolation_type_w:   enum  "NO DESCRIPTION"
+ * ID|Lattice.points -> points:   collection,  "(read-only)    Points of the lattice"
+ * ID|Lattice.points_u -> points_u:   int  "Points in U direction (cant be changed when there are shape keys)"
+ * ID|Lattice.points_v -> points_v:   int  "Points in V direction (cant be changed when there are shape keys)"
+ * ID|Lattice.points_w -> points_w:   int  "Points in W direction (cant be changed when there are shape keys)"
+ * ID|Lattice.shape_keys -> shape_keys:   pointer,  "(read-only)"
+ * ID|Lattice.outside -> use_outside:   boolean  "Only draw, and take into account, the outer vertices"
+ * ID|Lattice.vertex_group -> vertex_group:   string  "Vertex group to apply the influence of the lattice"
+ * ID|Library.filepath -> filepath:   string  "Path to the library .blend file"
+ * ID|Library.parent -> parent:   pointer,  "(read-only)"
+ * ID|Material.active_node_material -> active_node_material:   pointer  "Active node material"
+ * ID|Material.active_texture -> active_texture:   pointer  "Active texture slot being displayed"
+ * ID|Material.active_texture_index -> active_texture_index:   int  "Index of active texture slot"
+ * ID|Material.alpha -> alpha:   float  "Alpha transparency of the material"
+ * ID|Material.ambient -> ambient:   float  "Amount of global ambient color the material receives"
+ * ID|Material.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Material.darkness -> darkness:   float  "Minnaert darkness"
+ * ID|Material.diffuse_color -> diffuse_color:   float[3]  "NO DESCRIPTION"
+ * ID|Material.diffuse_fresnel -> diffuse_fresnel:   float  "Power of Fresnel"
+ * ID|Material.diffuse_fresnel_factor -> diffuse_fresnel_factor:   float  "Blending factor of Fresnel"
+ * ID|Material.diffuse_intensity -> diffuse_intensity:   float  "Amount of diffuse reflection"
+ * ID|Material.diffuse_ramp -> diffuse_ramp:   pointer,  "(read-only)    Color ramp used to affect diffuse shading"
+ * ID|Material.diffuse_ramp_blend -> diffuse_ramp_blend:   enum  "NO DESCRIPTION"
+ * ID|Material.diffuse_ramp_factor -> diffuse_ramp_factor:   float  "Blending factor (also uses alpha in Colorband)"
+ * ID|Material.diffuse_ramp_input -> diffuse_ramp_input:   enum  "NO DESCRIPTION"
+ * ID|Material.diffuse_shader -> diffuse_shader:   enum  "NO DESCRIPTION"
+ * ID|Material.diffuse_toon_size -> diffuse_toon_size:   float  "Size of diffuse toon area"
+ * ID|Material.diffuse_toon_smooth -> diffuse_toon_smooth:   float  "Smoothness of diffuse toon area"
+ * ID|Material.emit -> emit:   float  "Amount of light to emit"
+ * ID|Material.halo -> halo:   pointer,  "(read-only)    Halo settings for the material"
+ * ID|Material.invert_z -> invert_z:   boolean  "Renders materials faces with an inverted Z buffer (scanline only)"
+ * ID|Material.light_group -> light_group:   pointer  "Limit lighting to lamps in this Group"
+ * ID|Material.mirror_color -> mirror_color:   float[3]  "Mirror color of the material"
+ * ID|Material.node_tree -> node_tree:   pointer,  "(read-only)    Node tree for node based materials"
+ * ID|Material.z_offset -> offset_z:   float  "Gives faces an artificial offset in the Z buffer for Z transparency"
+ * ID|Material.physics -> physics:   pointer,  "(read-only)    Game physics settings"
+ * ID|Material.preview_render_type -> preview_render_type:   enum  "Type of preview render"
+ * ID|Material.raytrace_mirror -> raytrace_mirror:   pointer,  "(read-only)    Raytraced reflection settings for the material"
+ * ID|Material.raytrace_transparency -> raytrace_transparency:   pointer,  "(read-only)    Raytraced transparency settings for the material"
+ * ID|Material.roughness -> rough:   float  "Oren-Nayar Roughness"
+ * ID|Material.shadow_buffer_bias -> shadow_buffer_bias:   float  "Factor to multiply shadow buffer bias with (0 is ignore.)"
+ * ID|Material.shadow_casting_alpha -> shadow_cast_alpha:   float  "Shadow casting alpha, in use for Irregular and Deep shadow buffer"
+ * ID|Material.shadow_ray_bias -> shadow_ray_bias:   float  "Shadow raytracing bias to prevent terminator problems on shadow boundary"
+ * ID|Material.specular_alpha -> specular_alpha:   float  "Alpha transparency for specular areas"
+ * ID|Material.specular_color -> specular_color:   float[3]  "Specular color of the material"
+ * ID|Material.specular_hardness -> specular_hard:   int  "NO DESCRIPTION"
+ * ID|Material.specular_intensity -> specular_intensity:   float  "NO DESCRIPTION"
+ * ID|Material.specular_ior -> specular_ior:   float  "NO DESCRIPTION"
+ * ID|Material.specular_ramp -> specular_ramp:   pointer,  "(read-only)    Color ramp used to affect specular shading"
+ * ID|Material.specular_ramp_blend -> specular_ramp_blend:   enum  "NO DESCRIPTION"
+ * ID|Material.specular_ramp_factor -> specular_ramp_factor:   float  "Blending factor (also uses alpha in Colorband)"
+ * ID|Material.specular_ramp_input -> specular_ramp_input:   enum  "NO DESCRIPTION"
+ * ID|Material.specular_shader -> specular_shader:   enum  "NO DESCRIPTION"
+ * ID|Material.specular_slope -> specular_slope:   float  "The standard deviation of surface slope"
+ * ID|Material.specular_toon_size -> specular_toon_size:   float  "Size of specular toon area"
+ * ID|Material.specular_toon_smooth -> specular_toon_smooth:   float  "Smoothness of specular toon area"
+ * ID|Material.strand -> strand:   pointer,  "(read-only)    Strand settings for the material"
+ * ID|Material.subsurface_scattering -> subsurface_scattering:   pointer,  "(read-only)    Subsurface scattering settings for the material"
+ * ID|Material.texture_slots -> texture_slots:   collection,  "(read-only)    Texture slots defining the mapping and influence of textures"
+ * ID|Material.translucency -> translucency:   float  "Amount of diffuse shading on the back side"
+ * ID|Material.transparency_method -> transparency_method:   enum  "Method to use for rendering transparency"
+ * ID|Material.type -> type:   enum  "Material type defining how the object is rendered"
+ * ID|Material.cast_approximate -> use_cast_approximate:   boolean  "Allow this material to cast shadows when using approximate ambient occlusion."
+ * ID|Material.cast_buffer_shadows -> use_cast_buffer_shadows:   boolean  "Allow this material to cast shadows from shadow buffer lamps"
+ * ID|Material.cast_shadows_only -> use_cast_shadows_only:   boolean  "Makes objects with this material appear invisible, only casting shadows (not rendered)"
+ * ID|Material.cubic -> use_cubic:   boolean  "Use cubic interpolation for diffuse values, for smoother transitions"
+ * ID|Material.use_diffuse_ramp -> use_diffuse_ramp:   boolean  "Toggle diffuse ramp operations"
+ * ID|Material.face_texture -> use_face_texture:   boolean  "Replaces the objects base color with color from face assigned image textures"
+ * ID|Material.face_texture_alpha -> use_face_texture_alpha:   boolean  "Replaces the objects base alpha value with alpha from face assigned image textures"
+ * ID|Material.full_oversampling -> use_full_oversampling:   boolean  "Force this material to render full shading/textures for all anti-aliasing samples"
+ * ID|Material.light_group_exclusive -> use_light_group_exclusive:   boolean  "Material uses the light group exclusively - these lamps are excluded from other scene lighting"
+NEGATE * ID|Material.exclude_mist -> use_mist:   boolean  "Excludes this material from mist effects (in world settings)"
+ * ID|Material.use_nodes -> use_nodes:   boolean  "Use shader nodes to render the material"
+ * ID|Material.object_color -> use_object_color:   boolean  "Modulate the result with a per-object color"
+ * ID|Material.only_shadow -> use_only_shadow:   boolean  "Renders shadows as the materials alpha value, making materials transparent except for shadowed areas"
+ * ID|Material.ray_shadow_bias -> use_ray_shadow_bias:   boolean  "Prevents raytraced shadow errors on surfaces with smooth shaded normals (terminator problem)"
+ * ID|Material.traceable -> use_raytrace:   boolean  "Include this material and geometry that uses it in ray tracing calculations"
+ * ID|Material.shadeless -> use_shadeless:   boolean  "Makes this material insensitive to light or shadow"
+ * ID|Material.shadows -> use_shadows:   boolean  "Allows this material to receive shadows"
+ * ID|Material.use_sky -> use_sky:   boolean  "Renders this material with zero alpha, with sky background in place (scanline only)"
+ * ID|Material.use_specular_ramp -> use_specular_ramp:   boolean  "Toggle specular ramp operations"
+ * ID|Material.tangent_shading -> use_tangent_shading:   boolean  "Use the materials tangent vector instead of the normal for shading - for anisotropic shading effects"
+ * ID|Material.use_textures -> use_textures:   boolean[18]  "Enable/Disable each texture"
+ * ID|Material.transparency -> use_transparency:   boolean  "Render material as transparent"
+ * ID|Material.receive_transparent_shadows -> use_transparent_shadows:   boolean  "Allow this object to receive transparent shadows casted through other objects"
+ * ID|Material.vertex_color_light -> use_vertex_color_light:   boolean  "Add vertex colors as additional lighting"
+ * ID|Material.vertex_color_paint -> use_vertex_color_paint:   boolean  "Replaces object base color with vertex colors (multiplies with texture face face assigned textures)"
+ * ID|Material.volume -> volume:   pointer,  "(read-only)    Volume settings for the material"
+ * ID|Mesh.active_uv_texture -> active_uv_texture:   pointer  "Active UV texture"
+ * ID|Mesh.active_uv_texture_index -> active_uv_texture_index:   int  "Active UV texture index"
+ * ID|Mesh.active_vertex_color -> active_vertex_color:   pointer  "Active vertex color layer"
+ * ID|Mesh.active_vertex_color_index -> active_vertex_color_index:   int  "Active vertex color index"
+ * ID|Mesh.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Mesh.autosmooth_angle -> auto_smooth_angle:   int  "Defines maximum angle between face normals that Auto Smooth will operate on"
+ * ID|Mesh.edges -> edges:   collection,  "(read-only)    Edges of the mesh"
+ * ID|Mesh.faces -> faces:   collection,  "(read-only)    Faces of the mesh"
+ * ID|Mesh.float_layers -> layers_float:   collection,  "(read-only)"
+ * ID|Mesh.int_layers -> layers_int:   collection,  "(read-only)"
+ * ID|Mesh.string_layers -> layers_string:   collection,  "(read-only)"
+ * ID|Mesh.materials -> materials:   collection,  "(read-only)"
+ * ID|Mesh.shape_keys -> shape_keys:   pointer,  "(read-only)"
+ * ID|Mesh.all_edges -> show_all_edges:   boolean  "Displays all edges for wireframe in all view modes in the 3D view"
+ * ID|Mesh.double_sided -> show_double_sided:   boolean  "Render/display the mesh with double or single sided lighting"
+ * ID|Mesh.draw_bevel_weights -> show_edge_bevel_weight:   boolean  "Displays weights created for the Bevel modifier"
+ * ID|Mesh.draw_creases -> show_edge_crease:   boolean  "Displays creases created for subsurf weighting"
+ * ID|Mesh.draw_seams -> show_edge_seams:   boolean  "Displays UV unwrapping seams"
+ * ID|Mesh.draw_sharp -> show_edge_sharp:   boolean  "Displays sharp edges, used with the EdgeSplit modifier"
+ * ID|Mesh.draw_edges -> show_edges:   boolean  "Displays selected edges using highlights in the 3D view and UV editor"
+ * ID|Mesh.draw_edge_angle -> show_extra_edge_angle:   boolean  "Displays the angles in the selected edges in degrees, Using global values when set in the transform panel"
+ * ID|Mesh.draw_edge_length -> show_extra_edge_length:   boolean  "Displays selected edge lengths, Using global values when set in the transform panel"
+ * ID|Mesh.draw_face_area -> show_extra_face_area:   boolean  "Displays the area of selected faces, Using global values when set in the transform panel"
+ * ID|Mesh.draw_faces -> show_faces:   boolean  "Displays all faces as shades in the 3D view and UV editor"
+ * ID|Mesh.draw_normals -> show_normal_face:   boolean  "Displays face normals as lines"
+ * ID|Mesh.draw_vertex_normals -> show_normal_vertex:   boolean  "Displays vertex normals as lines"
+ * ID|Mesh.sticky -> sticky:   collection,  "(read-only)    Sticky texture coordinates"
+ * ID|Mesh.texco_mesh -> texco_mesh:   pointer  "Derive texture coordinates from another mesh"
+ * ID|Mesh.texspace_loc -> texspace_location:   float[3]  "Texture space location"
+ * ID|Mesh.texspace_size -> texspace_size:   float[3]  "Texture space size"
+ * ID|Mesh.texture_mesh -> texture_mesh:   pointer  "Use another mesh for texture indices (vertex indices must be aligned)"
+ * ID|Mesh.total_edge_sel -> total_edge_sel:   int,  "(read-only)    Selected edge count in editmode"
+ * ID|Mesh.total_face_sel -> total_face_sel:   int,  "(read-only)    Selected face count in editmode"
+ * ID|Mesh.total_vert_sel -> total_vert_sel:   int,  "(read-only)    Selected vertex count in editmode"
+ * ID|Mesh.autosmooth -> use_auto_smooth:   boolean  "Treats all set-smoothed faces with angles less than the specified angle as smooth during render"
+ * ID|Mesh.auto_texspace -> use_auto_texspace:   boolean  "Adjusts active objects texture space automatically when transforming object"
+ * ID|Mesh.use_mirror_topology -> use_mirror_topology:   boolean  "Use topology based mirroring"
+ * ID|Mesh.use_mirror_x -> use_mirror_x:   boolean  "X Axis mirror editing"
+ * ID|Mesh.use_paint_mask -> use_paint_mask:   boolean  "Face selection masking for painting"
+ * ID|Mesh.uv_texture_clone -> uv_texture_clone:   pointer  "UV texture to be used as cloning source"
+ * ID|Mesh.uv_texture_clone_index -> uv_texture_clone_index:   int  "Clone UV texture index"
+ * ID|Mesh.uv_texture_stencil -> uv_texture_stencil:   pointer  "UV texture to mask the painted area"
+ * ID|Mesh.uv_texture_stencil_index -> uv_texture_stencil_index:   int  "Mask UV texture index"
+ * ID|Mesh.uv_textures -> uv_textures:   collection,  "(read-only)"
+ * ID|Mesh.vertex_colors -> vertex_colors:   collection,  "(read-only)"
+ * ID|Mesh.verts -> vertices:   collection,  "(read-only)    Vertices of the mesh"
TODO MOVE TO ELEMENTS * ID|MetaBall.active_element -> active_element:   pointer,  "(read-only)    Last selected element"
+ * ID|MetaBall.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|MetaBall.elements -> elements:   collection,  "(read-only)    Meta elements"
+ * ID|MetaBall.materials -> materials:   collection,  "(read-only)"
+ * ID|MetaBall.render_size -> render_detail:   float  "Polygonization resolution in rendering"
+ * ID|MetaBall.texspace_loc -> texspace_location:   float[3]  "Texture space location"
+ * ID|MetaBall.texspace_size -> texspace_size:   float[3]  "Texture space size"
+ * ID|MetaBall.threshold -> threshold:   float  "Influence of meta elements"
+ * ID|MetaBall.flag -> update_method:   enum  "Metaball edit update behavior"
+ * ID|MetaBall.auto_texspace -> use_auto_texspace:   boolean  "Adjusts active objects texture space automatically when transforming object"
+ * ID|MetaBall.wire_size -> viewport_detail:   float  "Polygonization resolution in the 3D viewport"
+ * ID|NodeTree.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|NodeTree.grease_pencil -> grease_pencil:   pointer  "Grease Pencil datablock"
+ * ID|NodeTree.nodes -> nodes:   collection,  "(read-only)"
+ * ID|Object.active_material -> active_material:   pointer  "Active material being displayed"
+ * ID|Object.active_material_index -> active_material_index:   int  "Index of active material slot"
+ * ID|Object.active_particle_system -> active_particle_system:   pointer,  "(read-only)    Active particle system being displayed"
+ * ID|Object.active_particle_system_index -> active_particle_system_index:   int  "Index of active particle system slot"
+ * ID|Object.active_shape_key -> active_shape_key:   pointer,  "(read-only)    Current shape key"
+ * ID|Object.active_shape_key_index -> active_shape_key_index:   int  "Current shape key index"
+ * ID|Object.active_vertex_group -> active_vertex_group:   pointer,  "(read-only)    Vertex groups of the object"
+ * ID|Object.active_vertex_group_index -> active_vertex_group_index:   int  "Active index in vertex group array"
+ * ID|Object.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Object.animation_visualisation -> animation_visualisation:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Object.bound_box -> bound_box:   float[24],  "(read-only)    Objects bound box in object-space coordinates"
+ * ID|Object.collision -> collision:   pointer,  "(read-only)    Settings for using the objects as a collider in physics simulation"
+ * ID|Object.color -> color:   float[4]  "Object color and alpha, used when faces have the ObColor mode enabled"
+ * ID|Object.constraints -> constraints:   collection,  "(read-only)    Constraints affecting the transformation of the object"
+ * ID|Object.data -> data:   pointer  "Object data"
+ * ID|Object.delta_location -> delta_location:   float[3]  "Extra translation added to the location of the object"
+ * ID|Object.delta_rotation_euler -> delta_rotation_euler:   float[3]  "Extra rotation added to the rotation of the object (when using Euler rotations)"
+ * ID|Object.delta_rotation_quaternion -> delta_rotation_quaternion:   float[4]  "Extra rotation added to the rotation of the object (when using Quaternion rotations)"
+ * ID|Object.delta_scale -> delta_scale:   float[3]  "Extra scaling added to the scale of the object"
+ * ID|Object.dimensions -> dimensions:   float[3]  "Absolute bounding box dimensions of the object"
+ * ID|Object.draw_bounds_type -> draw_bounds_type:   enum  "Object boundary display type"
+ * ID|Object.max_draw_type -> draw_type:   enum  "Maximum draw type to display object with in viewport"
+ * ID|Object.dupli_faces_scale -> dupli_faces_scale:   float  "Scale the DupliFace objects"
+ * ID|Object.dupli_frames_end -> dupli_frames_end:   int  "End frame for DupliFrames"
+ * ID|Object.dupli_frames_off -> dupli_frames_off:   int  "Recurring frames to exclude from the Dupliframes"
+ * ID|Object.dupli_frames_on -> dupli_frames_on:   int  "Number of frames to use between DupOff frames"
+ * ID|Object.dupli_frames_start -> dupli_frames_start:   int  "Start frame for DupliFrames"
+ * ID|Object.dupli_group -> dupli_group:   pointer  "Instance an existing group"
+ * ID|Object.dupli_list -> dupli_list:   collection,  "(read-only)    Object duplis"
+ * ID|Object.dupli_type -> dupli_type:   enum  "If not None, object duplication method to use"
+ * ID|Object.empty_draw_size -> empty_draw_size:   float  "Size of display for empties in the viewport"
+ * ID|Object.empty_draw_type -> empty_draw_type:   enum  "Viewport display style for empties"
+ * ID|Object.field -> field:   pointer,  "(read-only)    Settings for using the objects as a field in physics simulation"
+ * ID|Object.game -> game:   pointer,  "(read-only)    Game engine related settings for the object"
+ * ID|Object.grease_pencil -> grease_pencil:   pointer  "Grease Pencil datablock"
+ * ID|Object.hide -> hide:   boolean  "Restrict visibility in the viewport"
+ * ID|Object.hide_render -> hide_render:   boolean  "Restrict renderability"
+ * ID|Object.hide_select -> hide_select:   boolean  "Restrict selection in the viewport"
+ * ID|Object.duplis_used -> is_duplicator:   boolean,  "(read-only)"
+ * ID|Object.layers -> layers:   boolean[20]  "Layers the object is on"
+ * ID|Object.location -> location:   float[3]  "Location of the object"
+ * ID|Object.lock_location -> lock_location:   boolean[3]  "Lock editing of location in the interface"
+ * ID|Object.lock_rotation -> lock_rotation:   boolean[3]  "Lock editing of rotation in the interface"
+ * ID|Object.lock_rotation_w -> lock_rotation_w:   boolean  "Lock editing of angle component of four-component rotations in the interface"
+ * ID|Object.lock_rotations_4d -> lock_rotations_4d:   boolean  "Lock editing of four component rotations by components (instead of as Eulers)"
+ * ID|Object.lock_scale -> lock_scale:   boolean[3]  "Lock editing of scale in the interface"
+ * ID|Object.material_slots -> material_slots:   collection,  "(read-only)    Material slots in the object"
+ * ID|Object.matrix_local -> matrix_local:   float[16]  "Parent relative transformation matrix"
+ * ID|Object.matrix_world -> matrix_world:   float[16]  "Worldspace transformation matrix"
+ * ID|Object.mode -> mode:   enum,  "(read-only)    Object interaction mode"
+ * ID|Object.modifiers -> modifiers:   collection,  "(read-only)    Modifiers affecting the geometric data of the object"
+ * ID|Object.motion_path -> motion_path:   pointer,  "(read-only)    Motion Path for this element"
+ * ID|Object.parent -> parent:   pointer  "Parent Object"
+ * ID|Object.parent_bone -> parent_bone:   string  "Name of parent bone in case of a bone parenting relation"
+ * ID|Object.parent_type -> parent_type:   enum  "Type of parent relation"
+ * ID|Object.parent_vertices -> parent_vertices:   int[3],  "(read-only)    Indices of vertices in cases of a vertex parenting relation"
+ * ID|Object.particle_systems -> particle_systems:   collection,  "(read-only)    Particle systems emitted from the object"
+ * ID|Object.pass_index -> pass_index:   int  "Index # for the IndexOB render pass"
+ * ID|Object.pose -> pose:   pointer,  "(read-only)    Current pose for armatures"
+ * ID|Object.pose_library -> pose_library:   pointer,  "(read-only)    Action used as a pose library for armatures"
+ * ID|Object.proxy -> proxy:   pointer,  "(read-only)    Library object this proxy object controls"
+ * ID|Object.proxy_group -> proxy_group:   pointer,  "(read-only)    Library group duplicator object this proxy object controls"
+ * ID|Object.rotation_axis_angle -> rotation_axis_angle:   float[4]  "Angle of Rotation for Axis-Angle rotation representation"
+ * ID|Object.rotation_euler -> rotation_euler:   float[3]  "Rotation in Eulers"
+ * ID|Object.rotation_mode -> rotation_mode:   enum  "NO DESCRIPTION"
+ * ID|Object.rotation_quaternion -> rotation_quaternion:   float[4]  "Rotation in Quaternions"
+ * ID|Object.scale -> scale:   float[3]  "Scaling of the object"
+ * ID|Object.select -> select:   boolean  "Object selection state"
+ * ID|Object.draw_axis -> show_axis:   boolean  "Displays the objects origin and axis"
+ * ID|Object.draw_bounds -> show_bounds:   boolean  "Displays the objects bounds"
+ * ID|Object.draw_name -> show_name:   boolean  "Displays the objects name"
+ * ID|Object.shape_key_lock -> show_shape_key:   boolean  "Always show the current Shape for this Object"
+ * ID|Object.draw_texture_space -> show_texture_space:   boolean  "Displays the objects texture space"
+ * ID|Object.draw_transparent -> show_transparent:   boolean  "Enables transparent materials for the object (Mesh only)"
+ * ID|Object.draw_wire -> show_wire:   boolean  "Adds the objects wireframe over solid drawing"
+ * ID|Object.x_ray -> show_x_ray:   boolean  "Makes the object draw in front of others"
+ * ID|Object.soft_body -> soft_body:   pointer,  "(read-only)    Settings for soft body simulation"
+ * ID|Object.time_offset -> time_offset:   float  "Animation offset in frames for F-Curve and dupligroup instances"
+ * ID|Object.track_axis -> track_axis:   enum  "Axis that points in forward direction"
+ * ID|Object.type -> type:   enum,  "(read-only)    Type of Object"
+ * ID|Object.up_axis -> up_axis:   enum  "Axis that points in the upward direction"
+ * ID|Object.use_dupli_faces_scale -> use_dupli_faces_scale:   boolean  "Scale dupli based on face size"
+ * ID|Object.use_dupli_frames_speed -> use_dupli_frames_speed:   boolean  "Set dupliframes to use the frame"
+ * ID|Object.use_dupli_verts_rotation -> use_dupli_vertices_rotation:   boolean  "Rotate dupli according to vertex normal"
+ * ID|Object.shape_key_edit_mode -> use_shape_key_edit_mode:   boolean  "Apply shape keys in edit mode (for Meshes only)"
+ * ID|Object.slow_parent -> use_slow_parent:   boolean  "Create a delay in the parent relationship"
+ * ID|Object.time_offset_add_parent -> use_time_offset_add_parent:   boolean  "Add the parents time offset value"
+ * ID|Object.time_offset_edit -> use_time_offset_edit:   boolean  "Use time offset when inserting keys and display time offset for F-Curve and action views"
+ * ID|Object.time_offset_parent -> use_time_offset_parent:   boolean  "Apply the time offset to this objects parent relationship"
+ * ID|Object.time_offset_particle -> use_time_offset_particle:   boolean  "Let the time offset work on the particle effect"
+ * ID|Object.vertex_groups -> vertex_groups:   collection,  "(read-only)    Vertex groups of the object"
+ * ID|ParticleSettings.active_dupliweight -> active_dupliweight:   pointer,  "(read-only)"
+ * ID|ParticleSettings.active_dupliweight_index -> active_dupliweight_index:   int  "NO DESCRIPTION"
+ * ID|ParticleSettings.adaptive_angle -> adaptive_angle:   int  "How many degrees path has to curve to make another render segment"
+ * ID|ParticleSettings.adaptive_pix -> adaptive_pixel:   int  "How many pixels path has to cover to make another render segment"
+ * ID|ParticleSettings.angular_velocity_factor -> angular_velocity_factor:   float  "Angular velocity amount"
+ * ID|ParticleSettings.angular_velocity_mode -> angular_velocity_mode:   enum  "Particle angular velocity mode"
+ * ID|ParticleSettings.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|ParticleSettings.child_effector -> apply_effector_to_children:   boolean  "Apply effectors to children"
+ * ID|ParticleSettings.child_guide -> apply_guide_to_children:   boolean  "NO DESCRIPTION"
+ * ID|ParticleSettings.billboard_align -> billboard_align:   enum  "In respect to what the billboards are aligned"
+ * ID|ParticleSettings.billboard_animation -> billboard_animation:   enum  "How to animate billboard textures"
+ * ID|ParticleSettings.billboard_object -> billboard_object:   pointer  "Billboards face this object (default is active camera)"
+ * ID|ParticleSettings.billboard_offset -> billboard_offset:   float[2]  "NO DESCRIPTION"
+ * ID|ParticleSettings.billboard_split_offset -> billboard_offset_split:   enum  "How to offset billboard textures"
+ * ID|ParticleSettings.billboard_tilt -> billboard_tilt:   float  "Tilt of the billboards"
+ * ID|ParticleSettings.billboard_random_tilt -> billboard_tilt_random:   float  "Random tilt of the billboards"
+ * ID|ParticleSettings.billboard_uv_split -> billboard_uv_split:   int  "Amount of rows/columns to split UV coordinates for billboards"
+ * ID|ParticleSettings.boids -> boids:   pointer,  "(read-only)"
+ * ID|ParticleSettings.branch_threshold -> branch_threshold:   float  "Threshold of branching"
+ * ID|ParticleSettings.brownian_factor -> brownian_factor:   float  "Specify the amount of Brownian motion"
+ * ID|ParticleSettings.child_length -> child_length:   float  "Length of child paths"
+ * ID|ParticleSettings.child_length_thres -> child_length_threshold:   float  "Amount of particles left untouched by child path length"
+ * ID|ParticleSettings.child_nbr -> child_nbr:   int  "Amount of children/parent"
+ * ID|ParticleSettings.child_radius -> child_radius:   float  "Radius of children around parent"
+ * ID|ParticleSettings.child_roundness -> child_roundness:   float  "Roundness of children around parent"
+ * ID|ParticleSettings.child_size -> child_size:   float  "A multiplier for the child particle size"
+ * ID|ParticleSettings.child_random_size -> child_size_random:   float  "Random variation to the size of the child particles"
+ * ID|ParticleSettings.child_type -> child_type:   enum  "Create child particles"
+ * ID|ParticleSettings.clump_factor -> clump_factor:   float  "Amount of clumping"
+ * ID|ParticleSettings.clumppow -> clump_shape:   float  "Shape of clumping"
+ * ID|ParticleSettings.amount -> count:   int  "Total number of particles"
+ * ID|ParticleSettings.damp_factor -> damping:   float  "Specify the amount of damping"
+ * ID|ParticleSettings.distribution -> distribution:   enum  "How to distribute particles on selected element"
+ * ID|ParticleSettings.drag_factor -> drag_factor:   float  "Specify the amount of air-drag"
+ * ID|ParticleSettings.draw_as -> draw_method:   enum  "How particles are drawn in viewport"
+ * ID|ParticleSettings.display -> draw_percentage:   int  "Percentage of particles to display in 3D view"
+ * ID|ParticleSettings.draw_size -> draw_size:   int  "Size of particles on viewport in pixels (0=default)"
+ * ID|ParticleSettings.draw_step -> draw_step:   int  "How many steps paths are drawn with (power of 2)"
+ * ID|ParticleSettings.dupli_group -> dupli_group:   pointer  "Show Objects in this Group in place of particles"
+ * ID|ParticleSettings.dupli_object -> dupli_object:   pointer  "Show this Object in place of particles"
+ * ID|ParticleSettings.dupliweights -> dupli_weights:   collection,  "(read-only)    Weights for all of the objects in the dupli group"
+ * ID|ParticleSettings.effect_hair -> effect_hair:   float  "Hair stiffness for effectors"
+ * ID|ParticleSettings.effector_weights -> effector_weights:   pointer,  "(read-only)"
+ * ID|ParticleSettings.emit_from -> emit_from:   enum  "Where to emit particles from"
+ * ID|ParticleSettings.random_factor -> factor_random:   float  "Give the starting speed a random variation"
+ * ID|ParticleSettings.fluid -> fluid:   pointer,  "(read-only)"
+ * ID|ParticleSettings.force_field_1 -> force_field_1:   pointer,  "(read-only)"
+ * ID|ParticleSettings.force_field_2 -> force_field_2:   pointer,  "(read-only)"
+ * ID|ParticleSettings.frame_end -> frame_end:   float  "Frame # to stop emitting particles"
+ * ID|ParticleSettings.frame_start -> frame_start:   float  "Frame # to start emitting particles"
+ * ID|ParticleSettings.grid_resolution -> grid_resolution:   int  "The resolution of the particle grid"
+ * ID|ParticleSettings.hair_step -> hair_step:   int  "Number of hair segments"
+ * ID|ParticleSettings.integrator -> integrator:   enum  "Select physics integrator type"
+ * ID|ParticleSettings.grid_invert -> invert_grid:   boolean  "Invert what is considered object and what is not"
+ * ID|ParticleSettings.jitter_factor -> jitter_factor:   float  "Amount of jitter applied to the sampling"
+ * ID|ParticleSettings.keyed_loops -> keyed_loops:   int  "Number of times the keys are looped"
+ * ID|ParticleSettings.keys_step -> keys_step:   int  "NO DESCRIPTION"
+ * ID|ParticleSettings.kink -> kink:   enum  "Type of periodic offset on the path"
+ * ID|ParticleSettings.kink_amplitude -> kink_amplitude:   float  "The amplitude of the offset"
+ * ID|ParticleSettings.kink_axis -> kink_axis:   enum  "Which axis to use for offset"
+ * ID|ParticleSettings.kink_frequency -> kink_frequency:   float  "The frequency of the offset (1/total length)"
+ * ID|ParticleSettings.kink_shape -> kink_shape:   float  "Adjust the offset to the beginning/end"
+ * ID|ParticleSettings.random_length -> length_random:   float  "Give path length a random variation"
+ * ID|ParticleSettings.lifetime -> lifetime:   float  "Specify the life span of the particles"
+ * ID|ParticleSettings.random_lifetime -> lifetime_random:   float  "Give the particle life a random variation"
+ * ID|ParticleSettings.line_length_head -> line_length_head:   float  "Length of the lines head"
+ * ID|ParticleSettings.line_length_tail -> line_length_tail:   float  "Length of the lines tail"
+ * ID|ParticleSettings.billboard_lock -> lock_billboard:   boolean  "Lock the billboards align axis"
+ * ID|ParticleSettings.boids_2d -> lock_boids_to_surface:   boolean  "Constrain boids to a surface"
+ * ID|ParticleSettings.mass -> mass:   float  "Specify the mass of the particles"
+ * ID|ParticleSettings.material -> material:   int  "Specify material used for the particles"
+ * ID|ParticleSettings.normal_factor -> normal_factor:   float  "Let the surface normal give the particle a starting speed"
+ * ID|ParticleSettings.object_aligned_factor -> object_align_factor:   float[3]  "Let the emitter object orientation give the particle a starting speed"
+ * ID|ParticleSettings.object_factor -> object_factor:   float  "Let the object give the particle a starting speed"
+ * ID|ParticleSettings.particle_factor -> particle_factor:   float  "Let the target particle give the particle a starting speed"
+ * ID|ParticleSettings.particle_size -> particle_size:   float  "The size of the particles"
+ * ID|ParticleSettings.path_end -> path_end:   float  "End time of drawn path"
+ * ID|ParticleSettings.path_start -> path_start:   float  "Starting time of drawn path"
+ * ID|ParticleSettings.phase_factor -> phase_factor:   float  "Initial rotation phase"
+ * ID|ParticleSettings.random_phase_factor -> phase_factor_random:   float  "Randomize rotation phase"
+ * ID|ParticleSettings.physics_type -> physics_type:   enum  "Particle physics type"
+ * ID|ParticleSettings.react_event -> react_event:   enum  "The event of target particles to react on"
+ * ID|ParticleSettings.reaction_shape -> reaction_shape:   float  "Power of reaction strength dependence on distance to target"
+ * ID|ParticleSettings.reactor_factor -> reactor_factor:   float  "Let the vector away from the target particles location give the particle a starting speed"
+ * ID|ParticleSettings.ren_as -> render_method:   enum  "How particles are rendered"
+ * ID|ParticleSettings.render_step -> render_step:   int  "How many steps paths are rendered with (power of 2)"
+ * ID|ParticleSettings.rendered_child_nbr -> rendered_child_count:   int  "Amount of children/parent for rendering"
+ * ID|ParticleSettings.random_rotation_factor -> rotation_factor_random:   float  "Randomize rotation"
+ * ID|ParticleSettings.rotation_mode -> rotation_mode:   enum  "Particles initial rotation"
+ * ID|ParticleSettings.rough1 -> rough_1:   float  "Amount of location dependent rough"
+ * ID|ParticleSettings.rough1_size -> rough_1_size:   float  "Size of location dependent rough"
+ * ID|ParticleSettings.rough2 -> rough_2:   float  "Amount of random rough"
+ * ID|ParticleSettings.rough2_size -> rough_2_size:   float  "Size of random rough"
+ * ID|ParticleSettings.rough2_thres -> rough_2_threshold:   float  "Amount of particles left untouched by random rough"
+ * ID|ParticleSettings.rough_end_shape -> rough_end_shape:   float  "Shape of end point rough"
+ * ID|ParticleSettings.rough_endpoint -> rough_endpoint:   float  "Amount of end point rough"
+ * ID|ParticleSettings.draw_health -> show_health:   boolean  "Draw boid health"
+ * ID|ParticleSettings.material_color -> show_material_color:   boolean  "Draw particles using materials diffuse color"
+ * ID|ParticleSettings.num -> show_number:   boolean  "Show particle number"
+ * ID|ParticleSettings.show_size -> show_size:   boolean  "Show particle size"
+ * ID|ParticleSettings.velocity -> show_velocity:   boolean  "Show particle velocity"
+ * ID|ParticleSettings.simplify_rate -> simplify_rate:   float  "Speed of simplification"
+ * ID|ParticleSettings.simplify_refsize -> simplify_refsize:   int  "Reference size in pixels, after which simplification begins"
+ * ID|ParticleSettings.simplify_transition -> simplify_transition:   float  "Transition period for fading out strands"
+ * ID|ParticleSettings.simplify_viewport -> simplify_viewport:   float  "Speed of Simplification"
+ * ID|ParticleSettings.random_size -> size_random:   float  "Give the particle size a random variation"
+ * ID|ParticleSettings.subframes -> subframes:   int  "Subframes to simulate for improved stability and finer granularity simulations"
+ * ID|ParticleSettings.tangent_factor -> tangent_factor:   float  "Let the surface tangent give the particle a starting speed"
+ * ID|ParticleSettings.tangent_phase -> tangent_phase:   float  "Rotate the surface tangent"
+ * ID|ParticleSettings.time_tweak -> time_tweak:   float  "A multiplier for physics timestep (1.0 means one frame = 1/25 seconds)"
+ * ID|ParticleSettings.trail_count -> trail_count:   int  "Number of trail particles"
+ * ID|ParticleSettings.type -> type:   enum  "NO DESCRIPTION"
+ * ID|ParticleSettings.abs_path_time -> use_absolute_path_time:   boolean  "Path timing is in absolute frames"
+ * ID|ParticleSettings.animate_branching -> use_animate_branching:   boolean  "Animate branching"
+ * ID|ParticleSettings.branching -> use_branching:   boolean  "Branch child paths from each other"
+ * ID|ParticleSettings.died -> use_dead:   boolean  "Show particles after they have died"
+ * ID|ParticleSettings.die_on_collision -> use_die_on_collision:   boolean  "Particles die when they collide with a deflector object"
+ * ID|ParticleSettings.rotation_dynamic -> use_dynamic_rotation:   boolean  "Sets rotation to dynamic/constant"
+ * ID|ParticleSettings.trand -> use_emit_random:   boolean  "Emit in random order of elements"
+ * ID|ParticleSettings.even_distribution -> use_even_distribution:   boolean  "Use even distribution from faces based on face areas or edge lengths"
+ * ID|ParticleSettings.use_global_dupli -> use_global_dupli:   boolean  "Use objects global coordinates for duplication"
+ * ID|ParticleSettings.use_group_count -> use_group_count:   boolean  "Use object multiple times in the same group"
+ * ID|ParticleSettings.rand_group -> use_group_pick_random:   boolean  "Pick objects from group randomly"
+ * ID|ParticleSettings.hair_bspline -> use_hair_bspline:   boolean  "Interpolate hair using B-Splines"
+ * ID|ParticleSettings.sizemass -> use_multiply_size_mass:   boolean  "Multiply mass by particle size"
+ * ID|ParticleSettings.parent -> use_parent_particles:   boolean  "Render parent particles"
+ * ID|ParticleSettings.react_multiple -> use_react_multiple:   boolean  "React multiple times"
+ * ID|ParticleSettings.react_start_end -> use_react_start_end:   boolean  "Give birth to unreacted particles eventually"
+ * ID|ParticleSettings.render_adaptive -> use_render_adaptive:   boolean  "Draw steps of the particle path"
+ * ID|ParticleSettings.emitter -> use_render_emitter:   boolean  "Render emitter Object also"
+ * ID|ParticleSettings.self_effect -> use_self_effect:   boolean  "Particle effectors effect themselves"
+ * ID|ParticleSettings.enable_simplify -> use_simplify:   boolean  "Remove child strands as the object becomes smaller on the screen"
+ * ID|ParticleSettings.viewport -> use_simplify_viewport:   boolean  "NO DESCRIPTION"
+ * ID|ParticleSettings.size_deflect -> use_size_deflect:   boolean  "Use particles size in deflection"
+ * ID|ParticleSettings.render_strand -> use_strand_primitive:   boolean  "Use the strand primitive for rendering"
+ * ID|ParticleSettings.symmetric_branching -> use_symmetric_branching:   boolean  "Start and end points are the same"
+ * ID|ParticleSettings.unborn -> use_unborn:   boolean  "Show particles before they are emitted"
+ * ID|ParticleSettings.velocity_length -> use_velocity_length:   boolean  "Multiply line length by particle speed"
+ * ID|ParticleSettings.whole_group -> use_whole_group:   boolean  "Use whole group at once"
+ * ID|ParticleSettings.userjit -> userjit:   int  "Emission locations / face (0 = automatic)"
+ * ID|ParticleSettings.virtual_parents -> virtual_parents:   float  "Relative amount of virtual parents"
+ * ID|Scene.active_keying_set -> active_keying_set:   pointer  "Active Keying Set used to insert/delete keyframes"
+ * ID|Scene.active_keying_set_index -> active_keying_set_index:   int  "Current Keying Set index (negative for builtin and positive for absolute)"
+ * ID|Scene.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Scene.distance_model -> audio_distance_model:   enum  "Distance model for distance attenuation calculation"
+ * ID|Scene.doppler_factor -> audio_doppler_factor:   float  "Pitch factor for Doppler effect calculation"
+ * ID|Scene.speed_of_sound -> audio_doppler_speed:   float  "Speed of sound for Doppler effect calculation"
+ * ID|Scene.set -> background_set:   pointer  "Background set scene"
+ * ID|Scene.camera -> camera:   pointer  "Active camera used for rendering the scene"
+ * ID|Scene.cursor_location -> cursor_location:   float[3]  "3D cursor location"
+ * ID|Scene.frame_current -> frame_current:   int  "NO DESCRIPTION"
+ * ID|Scene.frame_end -> frame_end:   int  "Final frame of the playback/rendering range"
+ * ID|Scene.preview_range_frame_end -> frame_preview_end:   int  "Alternative end frame for UI playback"
+ * ID|Scene.preview_range_frame_start -> frame_preview_start:   int  "Alternative start frame for UI playback"
+ * ID|Scene.frame_start -> frame_start:   int  "First frame of the playback/rendering range"
+ * ID|Scene.frame_step -> frame_step:   int  "Number of frames to skip forward while rendering/playing back each frame"
+ * ID|Scene.game_data -> game_settings:   pointer,  "(read-only)"
+ * ID|Scene.gravity -> gravity:   float[3]  "Constant acceleration in a given direction"
+ * ID|Scene.grease_pencil -> grease_pencil:   pointer  "Grease Pencil datablock"
+ * ID|Scene.nla_tweakmode_on -> is_nla_tweakmode:   boolean,  "(read-only)    Indicates whether there is any action referenced by NLA being edited. Strictly read-only"
+ * ID|Scene.keying_sets -> keying_sets:   collection,  "(read-only)    Absolute Keying Sets for this Scene"
+ * ID|Scene.all_keying_sets -> keying_sets_all:   collection,  "(read-only)    All Keying Sets available for use (builtins and Absolute Keying Sets for this Scene)"
+ * ID|Scene.layers -> layers:   boolean[20]  "Layers visible when rendering the scene"
+ * ID|Scene.network_render -> network_render:   pointer,  "(read-only)    Network Render Settings"
+ * ID|Scene.nodetree -> nodetree:   pointer,  "(read-only)    Compositing node tree"
+ * ID|Scene.bases -> object_bases:   collection,  "(read-only)"
+ * ID|Scene.objects -> objects:   collection,  "(read-only)"
+ * ID|Scene.orientations -> orientations:   collection,  "(read-only)"
+ * ID|Scene.pose_templates -> pose_templates:   pointer,  "(read-only)    Pose Template Settings"
+ * ID|Scene.render -> render:   pointer,  "(read-only)"
+ * ID|Scene.sequence_editor -> sequence_editor:   pointer,  "(read-only)"
+ * ID|Scene.stamp_note -> stamp_note:   string  "User define note for the render stamping"
+ * ID|Scene.sync_mode -> sync_mode:   enum  "How to sync playback"
+ * ID|Scene.timeline_markers -> timeline_markers:   collection,  "(read-only)    Markers used in all timelines for the current scene"
+ * ID|Scene.tool_settings -> tool_settings:   pointer,  "(read-only)"
+ * ID|Scene.unit_settings -> unit_settings:   pointer,  "(read-only)    Unit editing settings"
+NEGATE * ID|Scene.mute_audio -> use_audio:   boolean  "Play back of audio from Sequence Editor will be muted"
+ * ID|Scene.scrub_audio -> use_audio_scrub:   boolean  "Play audio from Sequence Editor while scrubbing"
+ * ID|Scene.sync_audio -> use_audio_sync:   boolean  "Play back and sync with audio clock, dropping frames if frame display is too slow"
+ * ID|Scene.frame_drop -> use_frame_drop:   boolean  "Play back dropping frames if frame display is too slow"
+ * ID|Scene.use_gravity -> use_gravity:   boolean  "Use global gravity for all dynamics"
+ * ID|Scene.use_nodes -> use_nodes:   boolean  "Enable the compositing node tree"
+ * ID|Scene.use_preview_range -> use_preview_range:   boolean  "Use an alternative start/end frame for UI playback, rather than the scene start/end frame"
+ * ID|Scene.world -> world:   pointer  "World used for rendering the scene"
+ * ID|Screen.areas -> areas:   collection,  "(read-only)    Areas the screen is subdivided into"
+ * ID|Screen.animation_playing -> is_animation_playing:   boolean,  "(read-only)    Animation playback is active"
+ * ID|Screen.fullscreen -> is_fullscreen:   boolean,  "(read-only)    An area is maximised, filling this screen"
+ * ID|Screen.scene -> scene:   pointer  "Active scene to be edited in the screen"
+ * ID|Sound.filepath -> filepath:   string  "Sound sample file used by this Sound datablock"
+ * ID|Sound.packed_file -> packed_file:   pointer,  "(read-only)"
+ * ID|Sound.caching -> use_ram_cache:   boolean  "The sound file is decoded and loaded into RAM"
+ * ID|Text.current_character -> current_character:   int,  "(read-only)    Index of current character in current line, and also start index of character in selection if one exists"
+ * ID|Text.current_line -> current_line:   pointer,  "(read-only)    Current line, and start line of selection if one exists"
+ * ID|Text.filepath -> filepath:   string  "Filename of the text file"
+ * ID|Text.dirty -> is_dirty:   boolean,  "(read-only)    Text file has been edited since last save"
+ * ID|Text.memory -> is_in_memory:   boolean,  "(read-only)    Text file is in memory, without a corresponding file on disk"
+ * ID|Text.modified -> is_modified:   boolean,  "(read-only)    Text file on disk is different than the one in memory"
+ * ID|Text.lines -> lines:   collection,  "(read-only)    Lines of text"
+ * ID|Text.markers -> markers:   collection,  "(read-only)    Text markers highlighting part of the text"
+ * ID|Text.selection_end_character -> select_end_character:   int,  "(read-only)    Index of character after end of selection in the selection end line"
+ * ID|Text.selection_end_line -> select_end_line:   pointer,  "(read-only)    End line of selection"
+ * ID|Text.use_module -> use_module:   boolean  "Register this text as a module on loading, Text name must end with .py"
+ * ID|Text.tabs_as_spaces -> use_tabs_as_spaces:   boolean  "Automatically converts all new tabs into spaces"
+ * ID|Texture.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|Texture.color_ramp -> color_ramp:   pointer,  "(read-only)"
+ * ID|Texture.contrast -> contrast:   float  "NO DESCRIPTION"
+TODO MAKE COLOR * ID|Texture.factor_blue -> factor_blue:   float  "NO DESCRIPTION"
+TODO MAKE COLOR * ID|Texture.factor_green -> factor_green:   float  "NO DESCRIPTION"
+TODO MAKE COLOR * ID|Texture.factor_red -> factor_red:   float  "NO DESCRIPTION"
+ * ID|Texture.brightness -> intensity:   float  "NO DESCRIPTION"
+ * ID|Texture.node_tree -> node_tree:   pointer,  "(read-only)    Node tree for node-based textures"
+ * ID|Texture.saturation -> saturation:   float  "NO DESCRIPTION"
+ * ID|Texture.type -> type:   enum  "NO DESCRIPTION"
+ * ID|Texture.use_color_ramp -> use_color_ramp:   boolean  "Toggle color ramp operations"
+ * ID|Texture.use_nodes -> use_nodes:   boolean  "Make this a node-based texture"
+ * ID|Texture.use_preview_alpha -> use_preview_alpha:   boolean  "Show Alpha in Preview Render"
+ * ID|Texture|BlendTexture.flip_axis -> flip_axis:   enum  "Flips the textures X and Y axis"
+ * ID|Texture|BlendTexture.progression -> progression:   enum  "Sets the style of the color blending"
+ * ID|Texture|CloudsTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
+ * ID|Texture|CloudsTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
+ * ID|Texture|CloudsTexture.noise_depth -> noise_depth:   int  "Sets the depth of the cloud calculation"
+ * ID|Texture|CloudsTexture.noise_size -> noise_scale:   float  "Sets scaling for noise input"
+ * ID|Texture|CloudsTexture.noise_type -> noise_type:   enum  "NO DESCRIPTION"
+ * ID|Texture|CloudsTexture.stype -> subtype:   enum  "NO DESCRIPTION"
+ * ID|Texture|DistortedNoiseTexture.distortion -> distortion:   float  "NO DESCRIPTION"
+ * ID|Texture|DistortedNoiseTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
+ * ID|Texture|DistortedNoiseTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
+ * ID|Texture|DistortedNoiseTexture.noise_distortion -> noise_distortion:   enum  "Sets the noise basis for the distortion"
+ * ID|Texture|DistortedNoiseTexture.noise_size -> noise_scale:   float  "Sets scaling for noise input"
+ * ID|Texture|EnvironmentMapTexture.environment_map -> environment_map:   pointer,  "(read-only)    Gets the environment map associated with this texture"
+ * ID|Texture|EnvironmentMapTexture.filter_eccentricity -> filter_eccentricity:   int  "Maximum eccentricity. Higher gives less blur at distant/oblique angles, but is also slower"
+ * ID|Texture|EnvironmentMapTexture.filter_probes -> filter_probes:   int  "Maximum number of samples. Higher gives less blur at distant/oblique angles, but is also slower"
+ * ID|Texture|EnvironmentMapTexture.filter_size -> filter_size:   float  "Multiplies the filter size used by MIP Map and Interpolation"
+ * ID|Texture|EnvironmentMapTexture.filter -> filter_type:   enum  "Texture filter to use for sampling image"
+ * ID|Texture|EnvironmentMapTexture.image -> image:   pointer  "Source image file to read the environment map from"
+ * ID|Texture|EnvironmentMapTexture.image_user -> image_user:   pointer,  "(read-only)    Parameters defining which layer, pass and frame of the image is displayed"
+ * ID|Texture|EnvironmentMapTexture.filter_size_minimum -> use_filter_size_min:   boolean  "Use Filter Size as a minimal filter value in pixels"
+ * ID|Texture|EnvironmentMapTexture.mipmap -> use_mipmap:   boolean  "Uses auto-generated MIP maps for the image"
+ * ID|Texture|EnvironmentMapTexture.mipmap_gauss -> use_mipmap_gauss:   boolean  "Uses Gauss filter to sample down MIP maps"
+ * ID|Texture|ImageTexture.checker_distance -> checker_distance:   float  "Sets distance between checker tiles"
+ * ID|Texture|ImageTexture.crop_max_x -> crop_max_x:   float  "Sets maximum X value to crop the image"
+ * ID|Texture|ImageTexture.crop_max_y -> crop_max_y:   float  "Sets maximum Y value to crop the image"
+ * ID|Texture|ImageTexture.crop_min_x -> crop_min_x:   float  "Sets minimum X value to crop the image"
+ * ID|Texture|ImageTexture.crop_min_y -> crop_min_y:   float  "Sets minimum Y value to crop the image"
+ * ID|Texture|ImageTexture.extension -> extension:   enum  "Sets how the image is extrapolated past its original bounds"
+ * ID|Texture|ImageTexture.filter_eccentricity -> filter_eccentricity:   int  "Maximum eccentricity. Higher gives less blur at distant/oblique angles, but is also slower"
+ * ID|Texture|ImageTexture.filter_probes -> filter_probes:   int  "Maximum number of samples. Higher gives less blur at distant/oblique angles, but is also slower"
+ * ID|Texture|ImageTexture.filter_size -> filter_size:   float  "Multiplies the filter size used by MIP Map and Interpolation"
+ * ID|Texture|ImageTexture.filter -> filter_type:   enum  "Texture filter to use for sampling image"
+ * ID|Texture|ImageTexture.image -> image:   pointer  "NO DESCRIPTION"
+ * ID|Texture|ImageTexture.image_user -> image_user:   pointer,  "(read-only)    Parameters defining which layer, pass and frame of the image is displayed"
+ * ID|Texture|ImageTexture.invert_alpha -> invert_alpha:   boolean  "Inverts all the alpha values in the image"
+ * ID|Texture|ImageTexture.normal_space -> normal_space:   enum  "Sets space of normal map image"
+ * ID|Texture|ImageTexture.repeat_x -> repeat_x:   int  "Sets a repetition multiplier in the X direction"
+ * ID|Texture|ImageTexture.repeat_y -> repeat_y:   int  "Sets a repetition multiplier in the Y direction"
+ * ID|Texture|ImageTexture.use_alpha -> use_alpha:   boolean  "Uses the alpha channel information in the image"
+ * ID|Texture|ImageTexture.calculate_alpha -> use_calculate_alpha:   boolean  "Calculates an alpha channel based on RGB values in the image"
+ * ID|Texture|ImageTexture.checker_even -> use_checker_even:   boolean  "Sets even checker tiles"
+ * ID|Texture|ImageTexture.checker_odd -> use_checker_odd:   boolean  "Sets odd checker tiles"
+ * ID|Texture|ImageTexture.filter_size_minimum -> use_filter_size_min:   boolean  "Use Filter Size as a minimal filter value in pixels"
+ * ID|Texture|ImageTexture.flip_axis -> use_flip_axis:   boolean  "Flips the textures X and Y axis"
+ * ID|Texture|ImageTexture.interpolation -> use_interpolation:   boolean  "Interpolates pixels using Area filter"
+ * ID|Texture|ImageTexture.mipmap -> use_mipmap:   boolean  "Uses auto-generated MIP maps for the image"
+ * ID|Texture|ImageTexture.mipmap_gauss -> use_mipmap_gauss:   boolean  "Uses Gauss filter to sample down MIP maps"
+ * ID|Texture|ImageTexture.mirror_x -> use_mirror_x:   boolean  "Mirrors the image repetition on the X direction"
+ * ID|Texture|ImageTexture.mirror_y -> use_mirror_y:   boolean  "Mirrors the image repetition on the Y direction"
+ * ID|Texture|ImageTexture.normal_map -> use_normal_map:   boolean  "Uses image RGB values for normal mapping"
+ * ID|Texture|MagicTexture.noise_depth -> noise_depth:   int  "Sets the depth of the cloud calculation"
+ * ID|Texture|MagicTexture.turbulence -> turbulence:   float  "Sets the turbulence of the bandnoise and ringnoise types"
+ * ID|Texture|MarbleTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
+ * ID|Texture|MarbleTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
+ * ID|Texture|MarbleTexture.noise_depth -> noise_depth:   int  "Sets the depth of the cloud calculation"
+ * ID|Texture|MarbleTexture.noise_size -> noise_scale:   float  "Sets scaling for noise input"
+ * ID|Texture|MarbleTexture.noise_type -> noise_type:   enum  "NO DESCRIPTION"
+ * ID|Texture|MarbleTexture.noisebasis2 -> noisebasis_2:   enum  "NO DESCRIPTION"
+ * ID|Texture|MarbleTexture.stype -> subtype:   enum  "NO DESCRIPTION"
+ * ID|Texture|MarbleTexture.turbulence -> turbulence:   float  "Sets the turbulence of the bandnoise and ringnoise types"
+ * ID|Texture|MusgraveTexture.highest_dimension -> dimension_max:   float  "Highest fractal dimension"
+ * ID|Texture|MusgraveTexture.gain -> gain:   float  "The gain multiplier"
+ * ID|Texture|MusgraveTexture.lacunarity -> lacunarity:   float  "Gap between successive frequencies"
+ * ID|Texture|MusgraveTexture.musgrave_type -> musgrave_type:   enum  "NO DESCRIPTION"
+ * ID|Texture|MusgraveTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
+ * ID|Texture|MusgraveTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
+ * ID|Texture|MusgraveTexture.noise_intensity -> noise_intensity:   float  "NO DESCRIPTION"
+ * ID|Texture|MusgraveTexture.noise_size -> noise_scale:   float  "Sets scaling for noise input"
+ * ID|Texture|MusgraveTexture.octaves -> octaves:   float  "Number of frequencies used"
+ * ID|Texture|MusgraveTexture.offset -> offset:   float  "The fractal offset"
+ * ID|Texture|PointDensityTexture.pointdensity -> point_density:   pointer,  "(read-only)    The point density settings associated with this texture"
+ * ID|Texture|StucciTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
+ * ID|Texture|StucciTexture.noise_size -> noise_scale:   float  "Sets scaling for noise input"
+ * ID|Texture|StucciTexture.noise_type -> noise_type:   enum  "NO DESCRIPTION"
+ * ID|Texture|StucciTexture.stype -> subtype:   enum  "NO DESCRIPTION"
+ * ID|Texture|StucciTexture.turbulence -> turbulence:   float  "Sets the turbulence of the bandnoise and ringnoise types"
+ * ID|Texture|VoronoiTexture.coloring -> color_mode:   enum  "NO DESCRIPTION"
+ * ID|Texture|VoronoiTexture.distance_metric -> distance_metric:   enum  "NO DESCRIPTION"
+ * ID|Texture|VoronoiTexture.minkovsky_exponent -> minkovsky_exponent:   float  "Minkovsky exponent"
+ * ID|Texture|VoronoiTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
+ * ID|Texture|VoronoiTexture.noise_intensity -> noise_intensity:   float  "NO DESCRIPTION"
+ * ID|Texture|VoronoiTexture.noise_size -> noise_scale:   float  "Sets scaling for noise input"
+ * ID|Texture|VoronoiTexture.weight_1 -> weight_1:   float  "Voronoi feature weight 1"
+ * ID|Texture|VoronoiTexture.weight_2 -> weight_2:   float  "Voronoi feature weight 2"
+ * ID|Texture|VoronoiTexture.weight_3 -> weight_3:   float  "Voronoi feature weight 3"
+ * ID|Texture|VoronoiTexture.weight_4 -> weight_4:   float  "Voronoi feature weight 4"
+ * ID|Texture|VoxelDataTexture.image -> image:   pointer  "NO DESCRIPTION"
+ * ID|Texture|VoxelDataTexture.image_user -> image_user:   pointer,  "(read-only)    Parameters defining which layer, pass and frame of the image is displayed"
+ * ID|Texture|VoxelDataTexture.voxeldata -> voxel_data:   pointer,  "(read-only)    The voxel data associated with this texture"
+ * ID|Texture|WoodTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
+ * ID|Texture|WoodTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
+ * ID|Texture|WoodTexture.noise_size -> noise_scale:   float  "Sets scaling for noise input"
+ * ID|Texture|WoodTexture.noise_type -> noise_type:   enum  "NO DESCRIPTION"
+ * ID|Texture|WoodTexture.noisebasis2 -> noisebasis_2:   enum  "NO DESCRIPTION"
+ * ID|Texture|WoodTexture.stype -> subtype:   enum  "NO DESCRIPTION"
+ * ID|Texture|WoodTexture.turbulence -> turbulence:   float  "Sets the turbulence of the bandnoise and ringnoise types"
+ * ID|VectorFont.filepath -> filepath:   string,  "(read-only)"
+ * ID|VectorFont.packed_file -> packed_file:   pointer,  "(read-only)"
TODO, move into collectin * ID|WindowManager.active_keyconfig -> active_keyconfig:   pointer  "NO DESCRIPTION"
+ * ID|WindowManager.default_keyconfig -> default_keyconfig:   pointer,  "(read-only)"
+ * ID|WindowManager.keyconfigs -> keyconfigs:   collection,  "(read-only)    Registered key configurations"
+ * ID|WindowManager.operators -> operators:   collection,  "(read-only)    Operator registry"
+ * ID|WindowManager.windows -> windows:   collection,  "(read-only)    Open windows"
+ * ID|World.active_texture -> active_texture:   pointer  "Active texture slot being displayed"
+ * ID|World.active_texture_index -> active_texture_index:   int  "Index of active texture slot"
+ * ID|World.ambient_color -> ambient_color:   float[3]  "NO DESCRIPTION"
+ * ID|World.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
+ * ID|World.range -> color_range:   float  "The color range that will be mapped to 0-1"
+ * ID|World.exposure -> exposure:   float  "Amount of exponential color correction for light"
+ * ID|World.horizon_color -> horizon_color:   float[3]  "Color at the horizon"
+ * ID|World.lighting -> light_settings:   pointer,  "(read-only)    World lighting settings"
+ * ID|World.mist -> mist_settings:   pointer,  "(read-only)    World mist settings"
+ * ID|World.stars -> star_settings:   pointer,  "(read-only)    World stars settings"
+ * ID|World.texture_slots -> texture_slots:   collection,  "(read-only)    Texture slots defining the mapping and influence of textures"
+ * ID|World.blend_sky -> use_sky_blend:   boolean  "Render background with natural progression from horizon to zenith"
+ * ID|World.paper_sky -> use_sky_paper:   boolean  "Flatten blend or texture coordinates"
+ * ID|World.real_sky -> use_sky_real:   boolean  "Render background with a real horizon, relative to the camera angle"
+ * ID|World.zenith_color -> zenith_color:   float[3]  "Color at the zenith"
+ * IKParam.ik_solver -> ik_solver:   enum,  "(read-only)    IK solver for which these parameters are defined, 0 for Legacy, 1 for iTaSC"
+ * IKParam|Itasc.dampmax -> damping_max:   float  "Maximum damping coefficient when singular value is nearly 0. Higher values=more stability, less reactivity. Default=0.5"
+ * IKParam|Itasc.dampeps -> damping_epsilon:   float  "Singular value under which damping is progressively applied. Higher values=more stability, less reactivity. Default=0.1"
+ * IKParam|Itasc.feedback -> feedback:   float  "Feedback coefficient for error correction. Average response time=1/feedback. Default=20"
+ * IKParam|Itasc.num_iter -> iterations:   int  "Maximum number of iterations for convergence in case of reiteration"
+ * IKParam|Itasc.mode -> mode:   enum  "NO DESCRIPTION"
+ * IKParam|Itasc.precision -> precision:   float  "Precision of convergence in case of reiteration"
+ * IKParam|Itasc.reiteration -> reiteration_method:   enum  "Defines if the solver is allowed to reiterate (converges until precision is met) on none, first or all frames"
+ * IKParam|Itasc.solver -> solver:   enum  "Solving method selection: Automatic damping or manual damping"
+ * IKParam|Itasc.num_step -> step_count:   int  "Divides the frame interval into this many steps"
+ * IKParam|Itasc.max_step -> step_max:   float  "Higher bound for timestep in second in case of automatic substeps"
+ * IKParam|Itasc.min_step -> step_min:   float  "Lower bound for timestep in second in case of automatic substeps"
+ * IKParam|Itasc.auto_step -> use_auto_step:   boolean  "Automatically determine the optimal number of steps for best performance/accuracy trade off"
+ * IKParam|Itasc.max_velocity -> velocity_max:   float  "Maximum joint velocity in rad/s. Default=50"
+ * ImageUser.fields_per_frame -> fields_per_frame:   int  "The number of fields per rendered frame (2 fields is 1 image)"
+ * ImageUser.frames -> frame_duration:   int  "Sets the number of images of a movie to use"
+ * ImageUser.offset -> frame_offset:   int  "Offsets the number of the frame to use in the animation"
+ * ImageUser.frame_start -> frame_start:   int  "Sets the global starting frame of the movie"
+ * ImageUser.multilayer_layer -> multilayer_layer:   int,  "(read-only)    Layer in multilayer image"
+ * ImageUser.multilayer_pass -> multilayer_pass:   int,  "(read-only)    Pass in multilayer image"
+ * ImageUser.auto_refresh -> use_auto_refresh:   boolean  "Always refresh image on frame changes"
+ * ImageUser.cyclic -> use_cyclic:   boolean  "Cycle the images in the movie"
+ * KeyConfig.user_defined -> is_user_defined:   boolean,  "(read-only)    Indicates that a keyconfig was defined by the user"
+ * KeyConfig.keymaps -> keymaps:   collection,  "(read-only)    Key maps configured as part of this configuration"
+ * KeyConfig.name -> name:   string  "Name of the key configuration"
+ * KeyMap.modal -> is_modal:   boolean,  "(read-only)    Indicates that a keymap is used for translate modal events for an operator"
+ * KeyMap.user_defined -> is_user_defined:   boolean  "Keymap is defined by the user"
+ * KeyMap.items -> items:   collection,  "(read-only)    Items in the keymap, linking an operator to an input event"
+ * KeyMap.name -> name:   string,  "(read-only)    Name of the key map"
+ * KeyMap.region_type -> region_type:   enum,  "(read-only)    Optional region type keymap is associated with"
+ * KeyMap.children_expanded -> show_expanded_children:   boolean  "Children expanded in the user interface"
+ * KeyMap.items_expanded -> show_expanded_items:   boolean  "Expanded in the user interface"
+ * KeyMap.space_type -> space_type:   enum,  "(read-only)    Optional space type keymap is associated with"
TODO MOVE TO COLLECTION * KeyMapItem.active -> active:   boolean  "Activate or deactivate item"
+ * KeyMapItem.id -> id:   int,  "(read-only)    ID of the item"
+ * KeyMapItem.idname -> idname:   string  "Identifier of operator to call on input event"
+ * KeyMapItem.key_modifier -> key_modifier:   enum  "Regular key pressed as a modifier"
+ * KeyMapItem.map_type -> map_type:   enum  "Type of event mapping"
+ * KeyMapItem.name -> name:   string,  "(read-only)    Name of operator to call on input event"
+ * KeyMapItem.alt -> pressed_alt:   boolean  "Alt key pressed"
+ * KeyMapItem.any -> pressed_any:   boolean  "Any modifier keys pressed"
+ * KeyMapItem.ctrl -> pressed_ctrl:   boolean  "Control key pressed"
+ * KeyMapItem.oskey -> pressed_oskey:   boolean  "Operating system key pressed"
+ * KeyMapItem.shift -> pressed_shift:   boolean  "Shift key pressed"
+ * KeyMapItem.properties -> properties:   pointer,  "(read-only)    Properties to set when the operator is called"
TODO * KeyMapItem.propvalue -> propvalue:   enum  "The value this event translates to in a modal keymap"
+ * KeyMapItem.expanded -> show_expanded:   boolean  "Show key map event and property details in the user interface"
+ * KeyMapItem.type -> type:   enum  "Type of event"
+ * KeyMapItem.value -> value:   enum  "NO DESCRIPTION"
+ * Keyframe.co -> co:   float[2]  "Coordinates of the control point"
+ * Keyframe.handle1 -> handle_left:   float[2]  "Coordinates of the first handle"
+ * Keyframe.handle1_type -> handle_left_type:   enum  "Handle types"
+ * Keyframe.handle2 -> handle_right:   float[2]  "Coordinates of the second handle"
+ * Keyframe.handle2_type -> handle_right_type:   enum  "Handle types"
+ * Keyframe.interpolation -> interpolation:   enum  "Interpolation method to use for segment of the curve from this Keyframe until the next Keyframe"
+ * Keyframe.select_control_point -> select_control_point:   boolean  "Control point selection status"
+ * Keyframe.select_left_handle -> select_left_handle:   boolean  "Handle 1 selection status"
+ * Keyframe.select_right_handle -> select_right_handle:   boolean  "Handle 2 selection status"
+ * Keyframe.type -> type:   enum  "The type of keyframe"
TODO MOVE TO COLLECTION * KeyingSet.active_path -> active_path:   pointer  "Active Keying Set used to insert/delete keyframes"
+ * KeyingSet.active_path_index -> active_path_index:   int  "Current Keying Set index"
+ * KeyingSet.name -> name:   string  "NO DESCRIPTION"
+ * KeyingSet.paths -> paths:   collection,  "(read-only)    Keying Set Paths to define settings that get keyframed together"
+ * KeyingSet.type_info -> type_info:   pointer,  "(read-only)    Callback function defines for built-in Keying Sets"
+ * KeyingSet.insertkey_needed -> use_insertkey_needed:   boolean  "Only insert keyframes where theyre needed in the relevant F-Curves"
+ * KeyingSet.insertkey_visual -> use_insertkey_visual:   boolean  "Insert keyframes based on visual transforms"
+ * KeyingSet.insertkey_xyz_to_rgb -> use_insertkey_xyz_to_rgb:   boolean  "Color for newly added transformation F-Curves (Location, Rotation, Scale) and also Color is based on the transform axis"
+ * KeyingSet.absolute -> use_path_absolute:   boolean  "Keying Set defines specific paths/settings to be keyframed (i.e. is not reliant on context info)"
+ * KeyingSetInfo.bl_idname -> bl_idname:   string  "NO DESCRIPTION"
+ * KeyingSetInfo.bl_label -> bl_label:   string  "NO DESCRIPTION"
+ * KeyingSetInfo.insertkey_needed -> use_insertkey_needed:   boolean  "Only insert keyframes where theyre needed in the relevant F-Curves"
+ * KeyingSetInfo.insertkey_visual -> use_insertkey_visual:   boolean  "Insert keyframes based on visual transforms"
+ * KeyingSetInfo.insertkey_xyz_to_rgb -> use_insertkey_xyz_to_rgb:   boolean  "Color for newly added transformation F-Curves (Location, Rotation, Scale) and also Color is based on the transform axis"
+ * KeyingSetPath.array_index -> array_index:   int  "Index to the specific setting if applicable"
+ * KeyingSetPath.data_path -> data_path:   string  "Path to property setting"
+ * KeyingSetPath.group -> group:   string  "Name of Action Group to assign setting(s) for this path to"
+ * KeyingSetPath.grouping -> group_method:   enum  "Method used to define which Group-name to use"
+ * KeyingSetPath.id -> id:   pointer  "ID-Block that keyframes for Keying Set should be added to (for Absolute Keying Sets only)"
+ * KeyingSetPath.id_type -> id_type:   enum  "Type of ID-block that can be used"
+ * KeyingSetPath.entire_array -> use_entire_array:   boolean  "When an array/vector type is chosen (Location, Rotation, Color, etc.), entire array is to be used"
+ * KeyingSetPath.insertkey_needed -> use_insertkey_needed:   boolean  "Only insert keyframes where theyre needed in the relevant F-Curves"
+ * KeyingSetPath.insertkey_visual -> use_insertkey_visual:   boolean  "Insert keyframes based on visual transforms"
+ * KeyingSetPath.insertkey_xyz_to_rgb -> use_insertkey_xyz_to_rgb:   boolean  "Color for newly added transformation F-Curves (Location, Rotation, Scale) and also Color is based on the transform axis"
+ * LampSkySettings.atmosphere_distance_factor -> atmosphere_distance_factor:   float  "Multiplier to convert blender units to physical distance"
+ * LampSkySettings.atmosphere_extinction -> atmosphere_extinction:   float  "Extinction scattering contribution factor"
+ * LampSkySettings.atmosphere_inscattering -> atmosphere_inscattering:   float  "Scatter contribution factor"
+ * LampSkySettings.atmosphere_turbidity -> atmosphere_turbidity:   float  "Sky turbidity"
+ * LampSkySettings.backscattered_light -> backscattered_light:   float  "Backscattered light"
+ * LampSkySettings.horizon_brightness -> horizon_intensity:   float  "Horizon brightness"
+ * LampSkySettings.sky_blend -> sky_blend:   float  "Blend factor with sky"
+ * LampSkySettings.sky_blend_type -> sky_blend_type:   enum  "Blend mode for combining sun sky with world sky"
+ * LampSkySettings.sky_color_space -> sky_color_space:   enum  "Color space to use for internal XYZ->RGB color conversion"
+ * LampSkySettings.sky_exposure -> sky_exposure:   float  "Strength of sky shading exponential exposure correction"
+ * LampSkySettings.spread -> spread:   float  "Horizon Spread"
+ * LampSkySettings.sun_brightness -> sun_intensity:   float  "Sun brightness"
+ * LampSkySettings.sun_intensity -> sun_intensity:   float  "Sun intensity"
+ * LampSkySettings.sun_size -> sun_size:   float  "Sun size"
+ * LampSkySettings.use_atmosphere -> use_atmosphere:   boolean  "Apply sun effect on atmosphere"
+ * LampSkySettings.use_sky -> use_sky:   boolean  "Apply sun effect on sky"
+ * LatticePoint.co -> co:   float[3],  "(read-only)"
+ * LatticePoint.deformed_co -> co_deform:   float[3]  "NO DESCRIPTION"
+ * LatticePoint.groups -> groups:   collection,  "(read-only)    Weights for the vertex groups this point is member of"
+ * Macro.bl_description -> bl_description:   string  "NO DESCRIPTION"
+ * Macro.bl_idname -> bl_idname:   string  "NO DESCRIPTION"
+ * Macro.bl_label -> bl_label:   string  "NO DESCRIPTION"
+ * Macro.bl_options -> bl_options:   enum  "Options for this operator type"
+ * Macro.name -> name:   string,  "(read-only)"
+ * Macro.properties -> properties:   pointer,  "(read-only)"
+ * Main.actions -> actions:   collection,  "(read-only)    Action datablocks."
+ * Main.armatures -> armatures:   collection,  "(read-only)    Armature datablocks."
+ * Main.brushes -> brushes:   collection,  "(read-only)    Brush datablocks."
+ * Main.cameras -> cameras:   collection,  "(read-only)    Camera datablocks."
+ * Main.curves -> curves:   collection,  "(read-only)    Curve datablocks."
+ * Main.filepath -> filepath:   string,  "(read-only)    Path to the .blend file"
+ * Main.fonts -> fonts:   collection,  "(read-only)    Vector font datablocks."
+ * Main.gpencil -> grease_pencils:   collection,  "(read-only)    Grease Pencil datablocks."
+ * Main.groups -> groups:   collection,  "(read-only)    Group datablocks."
+ * Main.images -> images:   collection,  "(read-only)    Image datablocks."
+NEGATE * Main.file_is_saved -> is_dirty:   boolean,  "(read-only)    Has the current session been saved to disk as a .blend file"
+ * Main.lamps -> lamps:   collection,  "(read-only)    Lamp datablocks."
+ * Main.lattices -> lattices:   collection,  "(read-only)    Lattice datablocks."
+ * Main.libraries -> libraries:   collection,  "(read-only)    Library datablocks."
+ * Main.materials -> materials:   collection,  "(read-only)    Material datablocks."
+ * Main.meshes -> meshes:   collection,  "(read-only)    Mesh datablocks."
+ * Main.metaballs -> metaballs:   collection,  "(read-only)    Metaball datablocks."
+ * Main.node_groups -> node_groups:   collection,  "(read-only)    Node group datablocks."
+ * Main.objects -> objects:   collection,  "(read-only)    Object datablocks."
+ * Main.particles -> particles:   collection,  "(read-only)    Particle datablocks."
+ * Main.scenes -> scenes:   collection,  "(read-only)    Scene datablocks."
+ * Main.screens -> screens:   collection,  "(read-only)    Screen datablocks."
+ * Main.scripts -> scripts:   collection,  "(read-only)    Script datablocks (DEPRECATED)."
+ * Main.debug -> show_debug:   boolean  "Print debugging information in console"
+ * Main.sounds -> sounds:   collection,  "(read-only)    Sound datablocks."
+ * Main.texts -> texts:   collection,  "(read-only)    Text datablocks."
+ * Main.textures -> textures:   collection,  "(read-only)    Texture datablocks."
+ * Main.window_managers -> window_managers:   collection,  "(read-only)    Window manager datablocks."
+ * Main.worlds -> worlds:   collection,  "(read-only)    World datablocks."
+ * MaterialHalo.add -> add:   float  "Sets the strength of the add effect"
+ * MaterialHalo.flare_boost -> flare_boost:   float  "Gives the flare extra strength"
+ * MaterialHalo.flare_seed -> flare_seed:   int  "Specifies an offset in the flare seed table"
+ * MaterialHalo.flare_size -> flare_size:   float  "Sets the factor by which the flare is larger than the halo"
+ * MaterialHalo.flares_sub -> flare_subflare_count:   int  "Sets the number of subflares"
+ * MaterialHalo.flare_subsize -> flare_subflare_size:   float  "Sets the dimension of the subflares, dots and circles"
+ * MaterialHalo.hardness -> hard:   int  "Sets the hardness of the halo"
+ * MaterialHalo.line_number -> line_count:   int  "Sets the number of star shaped lines rendered over the halo"
+ * MaterialHalo.rings -> ring_count:   int  "Sets the number of rings rendered over the halo"
+ * MaterialHalo.seed -> seed:   int  "Randomizes ring dimension and line location"
+ * MaterialHalo.size -> size:   float  "Sets the dimension of the halo"
+ * MaterialHalo.star_tips -> star_tip_count:   int  "Sets the number of points on the star shaped halo"
+ * MaterialHalo.xalpha -> use_extreme_alpha:   boolean  "Uses extreme alpha"
+ * MaterialHalo.flare_mode -> use_flare_mode:   boolean  "Renders halo as a lensflare"
+ * MaterialHalo.lines -> use_lines:   boolean  "Renders star shaped lines over halo"
+ * MaterialHalo.ring -> use_ring:   boolean  "Renders rings over halo"
+ * MaterialHalo.shaded -> use_shading:   boolean  "Lets halo receive light and shadows from external objects"
+ * MaterialHalo.soft -> use_soft:   boolean  "Softens the edges of halos at intersections with other geometry"
+ * MaterialHalo.star -> use_star:   boolean  "Renders halo as a star"
+ * MaterialHalo.texture -> use_texture:   boolean  "Gives halo a texture"
+ * MaterialHalo.vertex_normal -> use_vertex_normal:   boolean  "Uses the vertex normal to specify the dimension of the halo"
+ * MaterialPhysics.damp -> damping:   float  "Damping of the spring force, when inside the physics distance area"
+ * MaterialPhysics.distance -> distance:   float  "Distance of the physics area"
+ * MaterialPhysics.elasticity -> elasticity:   float  "Elasticity of collisions"
+ * MaterialPhysics.force -> force:   float  "Upward spring force, when inside the physics distance area"
+ * MaterialPhysics.friction -> friction:   float  "Coulomb friction coefficient, when inside the physics distance area"
+ * MaterialPhysics.align_to_normal -> use_normal_align:   boolean  "Align dynamic game objects along the surface normal, when inside the physics distance area"
+ * MaterialRaytraceMirror.depth -> depth:   int  "Maximum allowed number of light inter-reflections"
+ * MaterialRaytraceMirror.distance -> distance:   float  "Maximum distance of reflected rays. Reflections further than this range fade to sky color or material color"
+ * MaterialRaytraceMirror.fade_to -> fade_to:   enum  "The color that rays with no intersection within the Max Distance take. Material color can be best for indoor scenes, sky color for outdoor"
+ * MaterialRaytraceMirror.fresnel -> fresnel:   float  "Power of Fresnel for mirror reflection"
+ * MaterialRaytraceMirror.fresnel_factor -> fresnel_factor:   float  "Blending factor for Fresnel"
+ * MaterialRaytraceMirror.gloss_anisotropic -> gloss_anisotropic:   float  "The shape of the reflection, from 0.0 (circular) to 1.0 (fully stretched along the tangent"
+ * MaterialRaytraceMirror.gloss_factor -> gloss_factor:   float  "The shininess of the reflection. Values < 1.0 give diffuse, blurry reflections"
+ * MaterialRaytraceMirror.gloss_samples -> gloss_samples:   int  "Number of cone samples averaged for blurry reflections"
+ * MaterialRaytraceMirror.gloss_threshold -> gloss_threshold:   float  "Threshold for adaptive sampling. If a sample contributes less than this amount (as a percentage), sampling is stopped"
+ * MaterialRaytraceMirror.reflect_factor -> reflect_factor:   float  "Sets the amount mirror reflection for raytrace"
+ * MaterialRaytraceMirror.enabled -> use:   boolean  "Enable raytraced reflections"
+ * MaterialRaytraceTransparency.depth -> depth:   int  "Maximum allowed number of light inter-refractions"
+ * MaterialRaytraceTransparency.limit -> depth_max:   float  "Maximum depth for light to travel through the transparent material before becoming fully filtered (0.0 is disabled)"
+ * MaterialRaytraceTransparency.falloff -> falloff:   float  "Falloff power for transmissivity filter effect (1.0 is linear)"
+ * MaterialRaytraceTransparency.filter -> filter:   float  "Amount to blend in the materials diffuse color in raytraced transparency (simulating absorption)"
+ * MaterialRaytraceTransparency.fresnel -> fresnel:   float  "Power of Fresnel for transparency (Ray or ZTransp)"
+ * MaterialRaytraceTransparency.fresnel_factor -> fresnel_factor:   float  "Blending factor for Fresnel"
+ * MaterialRaytraceTransparency.gloss_factor -> gloss_factor:   float  "The clarity of the refraction. Values < 1.0 give diffuse, blurry refractions"
+ * MaterialRaytraceTransparency.gloss_samples -> gloss_samples:   int  "Number of cone samples averaged for blurry refractions"
+ * MaterialRaytraceTransparency.gloss_threshold -> gloss_threshold:   float  "Threshold for adaptive sampling. If a sample contributes less than this amount (as a percentage), sampling is stopped"
+ * MaterialRaytraceTransparency.ior -> ior:   float  "Sets angular index of refraction for raytraced refraction"
+ * MaterialSlot.link -> link:   enum  "Link material to object or the objects data"
+ * MaterialSlot.material -> material:   pointer  "Material datablock used by this material slot"
+ * MaterialSlot.name -> name:   string,  "(read-only)    Material slot name"
+ * MaterialStrand.blend_distance -> blend_distance:   float  "Worldspace distance over which to blend in the surface normal"
+ * MaterialStrand.root_size -> root_size:   float  "Start size of strands in pixels or Blender units"
+ * MaterialStrand.shape -> shape:   float  "Positive values make strands rounder, negative makes strands spiky"
+ * MaterialStrand.min_size -> size_min:   float  "Minimum size of strands in pixels"
+ * MaterialStrand.tip_size -> tip_size:   float  "End size of strands in pixels or Blender units"
+ * MaterialStrand.blender_units -> use_blender_units:   boolean  "Use Blender units for widths instead of pixels"
+ * MaterialStrand.surface_diffuse -> use_surface_diffuse:   boolean  "Make diffuse shading more similar to shading the surface"
+ * MaterialStrand.tangent_shading -> use_tangent_shading:   boolean  "Uses direction of strands as normal for tangent-shading"
+ * MaterialStrand.uv_layer -> uv_layer:   string  "Name of UV layer to override"
+ * MaterialStrand.width_fade -> width_fade:   float  "Transparency along the width of the strand"
+ * MaterialSubsurfaceScattering.back -> back:   float  "Back scattering weight"
+ * MaterialSubsurfaceScattering.color -> color:   float[3]  "Scattering color"
+ * MaterialSubsurfaceScattering.color_factor -> color_factor:   float  "Blend factor for SSS colors"
+ * MaterialSubsurfaceScattering.error_tolerance -> error_threshold:   float  "Error tolerance (low values are slower and higher quality)"
+ * MaterialSubsurfaceScattering.front -> front:   float  "Front scattering weight"
+ * MaterialSubsurfaceScattering.ior -> ior:   float  "Index of refraction (higher values are denser)"
+ * MaterialSubsurfaceScattering.radius -> radius:   float[3]  "Mean red/green/blue scattering path length"
+ * MaterialSubsurfaceScattering.scale -> scale:   float  "Object scale factor"
+ * MaterialSubsurfaceScattering.texture_factor -> texture_factor:   float  "Texture scatting blend factor"
+ * MaterialSubsurfaceScattering.enabled -> use:   boolean  "Enable diffuse subsurface scatting effects in a material"
+ * MaterialVolume.asymmetry -> asymmetry:   float  "Back scattering (-1.0) to Forward scattering (1.0) and the range in between"
+ * MaterialVolume.cache_resolution -> cache_resolution:   int  "Resolution of the voxel grid, low resolutions are faster, high resolutions use more memory"
+ * MaterialVolume.density -> density:   float  "The base density of the volume"
+ * MaterialVolume.density_scale -> density_scale:   float  "Multiplier for the materials density"
+ * MaterialVolume.depth_cutoff -> depth_threshold:   float  "Stop ray marching early if transmission drops below this luminance - higher values give speedups in dense volumes at the expense of accuracy"
+ * MaterialVolume.emission -> emission:   float  "Amount of light that gets emitted by the volume"
+ * MaterialVolume.emission_color -> emission_color:   float[3]  "NO DESCRIPTION"
+ * MaterialVolume.lighting_mode -> light_mode:   enum  "Method of shading, attenuating, and scattering light through the volume"
+ * MaterialVolume.ms_diffusion -> ms_diffusion:   float  "Diffusion factor, the strength of the blurring effect"
+ * MaterialVolume.ms_intensity -> ms_intensity:   float  "Multiplier for multiple scattered light energy"
+ * MaterialVolume.ms_spread -> ms_spread:   float  "Proportional distance over which the light is diffused"
+ * MaterialVolume.reflection -> reflection:   float  "Multiplier to make out-scattered light brighter or darker (non-physically correct)"
+ * MaterialVolume.reflection_color -> reflection_color:   float[3]  "Colour of light scattered out of the volume (does not affect transmission)"
+ * MaterialVolume.scattering -> scattering:   float  "Amount of light that gets scattered out by the volume - the more out-scattering, the shallower the light will penetrate"
+ * MaterialVolume.step_calculation -> step_method:   enum  "Method of calculating the steps through the volume"
+ * MaterialVolume.step_size -> step_size:   float  "Distance between subsequent volume depth samples"
+ * MaterialVolume.transmission_color -> transmission_color:   float[3]  "Result color of the volume, after other light has been scattered/absorbed"
+ * MaterialVolume.external_shadows -> use_external_shadows:   boolean  "Receive shadows from sources outside the volume (temporary)"
+ * MaterialVolume.light_cache -> use_light_cache:   boolean  "Pre-calculate the shading information into a voxel grid, speeds up shading at slightly less accuracy"
+ * Menu.bl_idname -> bl_idname:   string  "If this is set, the menu gets a custom ID, otherwise it takes the name of the class used to define the panel. For example, if the class name is OBJECT_MT_hello, and bl_idname is not set by the script, then bl_idname = OBJECT_MT_hello"
+ * Menu.bl_label -> bl_label:   string  "The menu label"
+ * Menu.layout -> layout:   pointer,  "(read-only)    Defines the structure of the menu in the UI."
+ * MeshColor.color1 -> color1:   float[3]  "NO DESCRIPTION"
+ * MeshColor.color2 -> color2:   float[3]  "NO DESCRIPTION"
+ * MeshColor.color3 -> color3:   float[3]  "NO DESCRIPTION"
+ * MeshColor.color4 -> color4:   float[3]  "NO DESCRIPTION"
+ * MeshColorLayer.active -> active:   boolean  "Sets the layer as active for display and editing"
+ * MeshColorLayer.active_render -> active_render:   boolean  "Sets the layer as active for rendering"
+ * MeshColorLayer.data -> data:   collection,  "(read-only)"
+ * MeshColorLayer.name -> name:   string  "NO DESCRIPTION"
+ * MeshEdge.bevel_weight -> bevel_weight:   float  "Weight used by the Bevel modifier"
+ * MeshEdge.crease -> crease:   float  "Weight used by the Subsurf modifier for creasing"
+ * MeshEdge.hide -> hide:   boolean  "NO DESCRIPTION"
+ * MeshEdge.index -> index:   int,  "(read-only)    Index number of the vertex"
+ * MeshEdge.fgon -> is_fgon:   boolean,  "(read-only)    Fgon edge"
+ * MeshEdge.loose -> is_loose:   boolean,  "(read-only)    Loose edge"
+ * MeshEdge.select -> select:   boolean  "NO DESCRIPTION"
+ * MeshEdge.seam -> use_seam:   boolean  "Seam edge for UV unwrapping"
+ * MeshEdge.sharp -> use_sharp:   boolean  "Sharp edge for the EdgeSplit modifier"
+ * MeshEdge.verts -> vertices:   int[2]  "Vertex indices"
+ * MeshFace.area -> area:   float,  "(read-only)    read only area of the face"
+ * MeshFace.hide -> hide:   boolean  "NO DESCRIPTION"
+ * MeshFace.index -> index:   int,  "(read-only)    Index number of the vertex"
+ * MeshFace.material_index -> material_index:   int  "NO DESCRIPTION"
+ * MeshFace.normal -> normal:   float[3],  "(read-only)    local space unit length normal vector for this face"
+ * MeshFace.select -> select:   boolean  "NO DESCRIPTION"
+ * MeshFace.smooth -> use_smooth:   boolean  "NO DESCRIPTION"
+ * MeshFace.verts -> vertices:   int[4]  "Vertex indices"
+ * MeshFace.verts_raw -> vertices_raw:   int[4]  "Fixed size vertex indices array"
+ * MeshFaces.active -> active:   int  "The active face for this mesh"
+ * MeshFaces.active_tface -> active_tface:   pointer,  "(read-only)    Active Texture Face"
+ * MeshFloatProperty.value -> value:   float  "NO DESCRIPTION"
+ * MeshFloatPropertyLayer.data -> data:   collection,  "(read-only)"
+ * MeshFloatPropertyLayer.name -> name:   string  "NO DESCRIPTION"
+ * MeshIntProperty.value -> value:   int  "NO DESCRIPTION"
+ * MeshIntPropertyLayer.data -> data:   collection,  "(read-only)"
+ * MeshIntPropertyLayer.name -> name:   string  "NO DESCRIPTION"
+ * MeshSticky.co -> co:   float[2]  "Sticky texture coordinate location"
+ * MeshStringProperty.value -> value:   string  "NO DESCRIPTION"
+ * MeshStringPropertyLayer.data -> data:   collection,  "(read-only)"
+ * MeshStringPropertyLayer.name -> name:   string  "NO DESCRIPTION"
+ * MeshTextureFace.transp -> alpha_mode:   enum  "Transparency blending mode"
+ * MeshTextureFace.invisible -> hide:   boolean  "Make face invisible"
+ * MeshTextureFace.image -> image:   pointer  "NO DESCRIPTION"
+ * MeshTextureFace.uv_pinned -> pin_uv:   boolean[4]  "NO DESCRIPTION"
+ * MeshTextureFace.select_uv -> select_uv:   boolean[4]  "NO DESCRIPTION"
+ * MeshTextureFace.alpha_sort -> use_alpha_sort:   boolean  "Enable sorting of faces for correct alpha drawing (slow, use Clip Alpha instead when possible)"
+ * MeshTextureFace.billboard -> use_billboard:   boolean  "Billboard with Z-axis constraint"
+ * MeshTextureFace.text -> use_bitmap_text:   boolean  "Enable bitmap text on face"
+ * MeshTextureFace.shared -> use_blend_shared:   boolean  "Blend vertex colors across face when vertices are shared"
+ * MeshTextureFace.collision -> use_collision:   boolean  "Use face for collision and ray-sensor detection"
+ * MeshTextureFace.halo -> use_halo:   boolean  "Screen aligned billboard"
+ * MeshTextureFace.light -> use_light:   boolean  "Use light for face"
+ * MeshTextureFace.object_color -> use_object_color:   boolean  "Use ObColor instead of vertex colors"
+ * MeshTextureFace.shadow -> use_shadow_face:   boolean  "Face is used for shadow"
+ * MeshTextureFace.tex -> use_texture:   boolean  "Render face with texture"
+ * MeshTextureFace.twoside -> use_twoside:   boolean  "Render face two-sided"
+ * MeshTextureFace.uv -> uv:   float[8]  "NO DESCRIPTION"
+ * MeshTextureFace.uv1 -> uv1:   float[2]  "NO DESCRIPTION"
+ * MeshTextureFace.uv2 -> uv2:   float[2]  "NO DESCRIPTION"
+ * MeshTextureFace.uv3 -> uv3:   float[2]  "NO DESCRIPTION"
+ * MeshTextureFace.uv4 -> uv4:   float[2]  "NO DESCRIPTION"
+ * MeshTextureFace.uv_raw -> uv_raw:   float[8]  "Fixed size UV coordinates array"
+ * MeshTextureFaceLayer.active -> active:   boolean  "Sets the layer as active for display and editing"
+ * MeshTextureFaceLayer.active_clone -> active_clone:   boolean  "Sets the layer as active for cloning"
+ * MeshTextureFaceLayer.active_render -> active_render:   boolean  "Sets the layer as active for rendering"
+ * MeshTextureFaceLayer.data -> data:   collection,  "(read-only)"
+ * MeshTextureFaceLayer.name -> name:   string  "NO DESCRIPTION"
+ * MeshVertex.bevel_weight -> bevel_weight:   float  "Weight used by the Bevel modifier Only Vertices option"
+ * MeshVertex.co -> co:   float[3]  "NO DESCRIPTION"
+ * MeshVertex.groups -> groups:   collection,  "(read-only)    Weights for the vertex groups this vertex is member of"
+ * MeshVertex.hide -> hide:   boolean  "NO DESCRIPTION"
+ * MeshVertex.index -> index:   int,  "(read-only)    Index number of the vertex"
+ * MeshVertex.normal -> normal:   float[3]  "Vertex Normal"
+ * MeshVertex.select -> select:   boolean  "NO DESCRIPTION"
+ * MetaElement.location -> co:   float[3]  "NO DESCRIPTION"
+ * MetaElement.hide -> hide:   boolean  "Hide element"
+ * MetaElement.radius -> radius:   float  "NO DESCRIPTION"
+ * MetaElement.rotation -> rotation:   float[4]  "NO DESCRIPTION"
+ * MetaElement.size_x -> size_x:   float  "Size of element, use of components depends on element type"
+ * MetaElement.size_y -> size_y:   float  "Size of element, use of components depends on element type"
+ * MetaElement.size_z -> size_z:   float  "Size of element, use of components depends on element type"
+ * MetaElement.stiffness -> stiffness:   float  "Stiffness defines how much of the element to fill"
+ * MetaElement.type -> type:   enum  "Metaball types"
+ * MetaElement.negative -> use_negative:   boolean  "Set metaball as negative one"
+ * Modifier.name -> name:   string  "Modifier name"
+ * Modifier.expanded -> show_expanded:   boolean  "Set modifier expanded in the user interface"
+ * Modifier.editmode -> show_in_editmode:   boolean  "Use modifier while in the edit mode"
+ * Modifier.on_cage -> show_on_cage:   boolean  "Enable direct editing of modifier control cage"
+ * Modifier.realtime -> show_viewport:   boolean  "Realtime display of a modifier"
+ * Modifier.type -> type:   enum,  "(read-only)"
+ * Modifier.render -> use_render:   boolean  "Use modifier during rendering"
+ * Modifier|ArmatureModifier.invert -> invert_vertex_group:   boolean  "Invert vertex group influence"
+ * Modifier|ArmatureModifier.object -> object:   pointer  "Armature object to deform with"
+ * Modifier|ArmatureModifier.use_bone_envelopes -> use_bone_envelopes:   boolean  "NO DESCRIPTION"
+ * Modifier|ArmatureModifier.quaternion -> use_deform_preserve_volume:   boolean  "Deform rotation interpolation with quaternions"
+ * Modifier|ArmatureModifier.multi_modifier -> use_multi_modifier:   boolean  "Use same input as previous modifier, and mix results using overall vgroup"
+ * Modifier|ArmatureModifier.use_vertex_groups -> use_vertex_groups:   boolean  "NO DESCRIPTION"
+ * Modifier|ArmatureModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|ArrayModifier.constant_offset_displacement -> constant_offset_displace:   float[3]  "NO DESCRIPTION"
+ * Modifier|ArrayModifier.count -> count:   int  "Number of duplicates to make"
+ * Modifier|ArrayModifier.curve -> curve:   pointer  "Curve object to fit array length to"
+ * Modifier|ArrayModifier.end_cap -> end_cap:   pointer  "Mesh object to use as an end cap"
+ * Modifier|ArrayModifier.length -> fit_length:   float  "Length to fit array within"
+ * Modifier|ArrayModifier.fit_type -> fit_type:   enum  "Array length calculation method"
+ * Modifier|ArrayModifier.merge_distance -> merge_threshold:   float  "Limit below which to merge vertices"
+ * Modifier|ArrayModifier.offset_object -> offset_object:   pointer  "NO DESCRIPTION"
+ * Modifier|ArrayModifier.relative_offset_displacement -> relative_offset_displace:   float[3]  "NO DESCRIPTION"
+ * Modifier|ArrayModifier.start_cap -> start_cap:   pointer  "Mesh object to use as a start cap"
+ * Modifier|ArrayModifier.constant_offset -> use_constant_offset:   boolean  "Add a constant offset"
+ * Modifier|ArrayModifier.merge_end_vertices -> use_merge_vertices_cap:   boolean  "Merge vertices in first and last duplicates"
+ * Modifier|ArrayModifier.merge_adjacent_vertices -> use_merge_vertices:   boolean  "Merge vertices in adjacent duplicates"
+ * Modifier|ArrayModifier.add_offset_object -> use_object_offset:   boolean  "Add another objects transformation to the total offset"
+ * Modifier|ArrayModifier.relative_offset -> use_relative_offset:   boolean  "Add an offset relative to the objects bounding box"
+ * Modifier|BevelModifier.angle -> angle_limit:   float  "Angle above which to bevel edges"
+ * Modifier|BevelModifier.edge_weight_method -> edge_weight_method:   enum  "What edge weight to use for weighting a vertex"
+ * Modifier|BevelModifier.limit_method -> limit_method:   enum  "NO DESCRIPTION"
+ * Modifier|BevelModifier.only_vertices -> use_only_vertices:   boolean  "Bevel verts/corners, not edges"
+ * Modifier|BevelModifier.width -> width:   float  "Bevel value/amount"
+ * Modifier|BooleanModifier.object -> object:   pointer  "Mesh object to use for Boolean operation"
+ * Modifier|BooleanModifier.operation -> operation:   enum  "NO DESCRIPTION"
+ * Modifier|BuildModifier.length -> frame_duration:   float  "Specify the total time the build effect requires"
+ * Modifier|BuildModifier.frame_start -> frame_start:   float  "Specify the start frame of the effect"
+ * Modifier|BuildModifier.seed -> seed:   int  "Specify the seed for random if used"
+ * Modifier|BuildModifier.randomize -> use_random_order:   boolean  "Randomize the faces or edges during build"
+ * Modifier|CastModifier.cast_type -> cast_type:   enum  "NO DESCRIPTION"
+ * Modifier|CastModifier.factor -> factor:   float  "NO DESCRIPTION"
+ * Modifier|CastModifier.object -> object:   pointer  "Control object: if available, its location determines the center of the effect"
+ * Modifier|CastModifier.radius -> radius:   float  "Only deform vertices within this distance from the center of the effect (leave as 0 for infinite.)"
+ * Modifier|CastModifier.size -> size:   float  "Size of projection shape (leave as 0 for auto.)"
+ * Modifier|CastModifier.from_radius -> use_radius_as_size:   boolean  "Use radius as size of projection shape (0 = auto)"
+ * Modifier|CastModifier.use_transform -> use_transform:   boolean  "Use object transform to control projection shape"
+ * Modifier|CastModifier.x -> use_x:   boolean  "NO DESCRIPTION"
+ * Modifier|CastModifier.y -> use_y:   boolean  "NO DESCRIPTION"
+ * Modifier|CastModifier.z -> use_z:   boolean  "NO DESCRIPTION"
+ * Modifier|CastModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|ClothModifier.collision_settings -> collision_settings:   pointer,  "(read-only)"
+ * Modifier|ClothModifier.point_cache -> point_cache:   pointer,  "(read-only)"
+ * Modifier|ClothModifier.settings -> settings:   pointer,  "(read-only)"
+ * Modifier|CollisionModifier.settings -> settings:   pointer,  "(read-only)"
+ * Modifier|CurveModifier.deform_axis -> deform_axis:   enum  "The axis that the curve deforms along"
+ * Modifier|CurveModifier.object -> object:   pointer  "Curve object to deform with"
+ * Modifier|CurveModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|DecimateModifier.face_count -> face_count:   int,  "(read-only)    The current number of faces in the decimated mesh"
+ * Modifier|DecimateModifier.ratio -> ratio:   float  "Defines the ratio of triangles to reduce to"
+ * Modifier|DisplaceModifier.direction -> direction:   enum  "NO DESCRIPTION"
+ * Modifier|DisplaceModifier.midlevel -> mid_level:   float  "Material value that gives no displacement"
+ * Modifier|DisplaceModifier.strength -> strength:   float  "NO DESCRIPTION"
+ * Modifier|DisplaceModifier.texture -> texture:   pointer  "NO DESCRIPTION"
+ * Modifier|DisplaceModifier.texture_coordinate_object -> texture_coordinate_object:   pointer  "NO DESCRIPTION"
+ * Modifier|DisplaceModifier.texture_coordinates -> texture_coords:   enum  "NO DESCRIPTION"
+ * Modifier|DisplaceModifier.uv_layer -> uv_layer:   string  "UV layer name"
+ * Modifier|DisplaceModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|EdgeSplitModifier.split_angle -> split_angle:   float  "Angle above which to split edges"
+ * Modifier|EdgeSplitModifier.use_edge_angle -> use_edge_angle:   boolean  "Split edges with high angle between faces"
+ * Modifier|EdgeSplitModifier.use_sharp -> use_edge_sharp:   boolean  "Split edges that are marked as sharp"
+ * Modifier|ExplodeModifier.protect -> protect:   float  "Clean vertex group edges"
+ * Modifier|ExplodeModifier.alive -> show_alive:   boolean  "Show mesh when particles are alive"
+ * Modifier|ExplodeModifier.dead -> show_dead:   boolean  "Show mesh when particles are dead"
+ * Modifier|ExplodeModifier.unborn -> show_unborn:   boolean  "Show mesh when particles are unborn"
+ * Modifier|ExplodeModifier.split_edges -> use_edge_split:   boolean  "Split face edges for nicer shrapnel"
+ * Modifier|ExplodeModifier.size -> use_size:   boolean  "Use particle size for the shrapnel"
+ * Modifier|ExplodeModifier.vertex_group -> vertex_group:   string  "NO DESCRIPTION"
+ * Modifier|FluidSimulationModifier.settings -> settings:   pointer,  "(read-only)    Settings for how this object is used in the fluid simulation"
+ * Modifier|HookModifier.falloff -> falloff:   float  "If not zero, the distance from the hook where influence ends"
+ * Modifier|HookModifier.force -> force:   float  "Relative force of the hook"
+ * Modifier|HookModifier.object -> object:   pointer  "Parent Object for hook, also recalculates and clears offset"
+ * Modifier|HookModifier.subtarget -> subtarget:   string  "Name of Parent Bone for hook (if applicable), also recalculates and clears offset"
+ * Modifier|HookModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|LatticeModifier.object -> object:   pointer  "Lattice object to deform with"
+ * Modifier|LatticeModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|MaskModifier.armature -> armature:   pointer  "Armature to use as source of bones to mask"
+ * Modifier|MaskModifier.invert -> invert_vertex_group:   boolean  "Use vertices that are not part of region defined"
+ * Modifier|MaskModifier.mode -> mode:   enum  "NO DESCRIPTION"
+ * Modifier|MaskModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|MeshDeformModifier.invert -> invert_vertex_group:   boolean  "Invert vertex group influence"
+ * Modifier|MeshDeformModifier.is_bound -> is_bound:   boolean,  "(read-only)    Whether geometry has been bound to control cage"
+ * Modifier|MeshDeformModifier.object -> object:   pointer  "Mesh object to deform with"
+ * Modifier|MeshDeformModifier.precision -> precision:   int  "The grid size for binding"
+ * Modifier|MeshDeformModifier.dynamic -> use_dynamic_bind:   boolean  "Recompute binding dynamically on top of other deformers (slower and more memory consuming.)"
+ * Modifier|MeshDeformModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|MirrorModifier.merge_limit -> merge_threshold:   float  "Distance from axis within which mirrored vertices are merged"
+ * Modifier|MirrorModifier.mirror_object -> mirror_object:   pointer  "Object to use as mirror"
+ * Modifier|MirrorModifier.clip -> use_clip:   boolean  "Prevents vertices from going through the mirror during transform"
+ * Modifier|MirrorModifier.mirror_u -> use_mirror_u:   boolean  "Mirror the U texture coordinate around the 0.5 point"
+ * Modifier|MirrorModifier.mirror_v -> use_mirror_v:   boolean  "Mirror the V texture coordinate around the 0.5 point"
+ * Modifier|MirrorModifier.mirror_vertex_groups -> use_mirror_vertex_groups:   boolean  "Mirror vertex groups (e.g. .R->.L)"
+ * Modifier|MirrorModifier.x -> use_x:   boolean  "Enable X axis mirror"
+ * Modifier|MirrorModifier.y -> use_y:   boolean  "Enable Y axis mirror"
+ * Modifier|MirrorModifier.z -> use_z:   boolean  "Enable Z axis mirror"
+ * Modifier|MultiresModifier.filepath -> filepath:   string  "Path to external displacements file"
+ * Modifier|MultiresModifier.external -> is_external:   boolean,  "(read-only)    Store multires displacements outside the .blend file, to save memory"
+ * Modifier|MultiresModifier.levels -> levels:   int  "Number of subdivisions to use in the viewport"
+ * Modifier|MultiresModifier.render_levels -> render_levels:   int  "NO DESCRIPTION"
+ * Modifier|MultiresModifier.sculpt_levels -> sculpt_levels:   int  "Number of subdivisions to use in sculpt mode"
+ * Modifier|MultiresModifier.optimal_display -> show_only_control_edges:   boolean  "Skip drawing/rendering of interior subdivided edges"
+ * Modifier|MultiresModifier.subdivision_type -> subdivision_type:   enum  "Selects type of subdivision algorithm"
+ * Modifier|MultiresModifier.total_levels -> total_levels:   int,  "(read-only)    Number of subdivisions for which displacements are stored"
+ * Modifier|ParticleInstanceModifier.axis -> axis:   enum  "Pole axis for rotation"
+ * Modifier|ParticleInstanceModifier.object -> object:   pointer  "Object that has the particle system"
+ * Modifier|ParticleInstanceModifier.particle_system_number -> particle_system_index:   int  "NO DESCRIPTION"
+ * Modifier|ParticleInstanceModifier.position -> position:   float  "Position along path"
+ * Modifier|ParticleInstanceModifier.random_position -> random_position:   float  "Randomize position along path"
+ * Modifier|ParticleInstanceModifier.alive -> use_alive:   boolean  "Show instances when particles are alive"
+ * Modifier|ParticleInstanceModifier.children -> use_children:   boolean  "Create instances from child particles"
+ * Modifier|ParticleInstanceModifier.dead -> use_dead:   boolean  "Show instances when particles are dead"
+ * Modifier|ParticleInstanceModifier.normal -> use_normal:   boolean  "Create instances from normal particles"
+ * Modifier|ParticleInstanceModifier.use_path -> use_path:   boolean  "Create instances along particle paths"
+ * Modifier|ParticleInstanceModifier.keep_shape -> use_preserve_shape:   boolean  "Dont stretch the object"
+ * Modifier|ParticleInstanceModifier.size -> use_size:   boolean  "Use particle size to scale the instances"
+ * Modifier|ParticleInstanceModifier.unborn -> use_unborn:   boolean  "Show instances when particles are unborn"
+ * Modifier|ParticleSystemModifier.particle_system -> particle_system:   pointer,  "(read-only)    Particle System that this modifier controls"
+ * Modifier|ScrewModifier.angle -> angle:   float  "Angle of revolution"
+ * Modifier|ScrewModifier.axis -> axis:   enum  "Screw axis"
+ * Modifier|ScrewModifier.iterations -> iterations:   int  "Number of times to apply the screw operation"
+ * Modifier|ScrewModifier.object -> object:   pointer  "Object to define the screw axis"
+ * Modifier|ScrewModifier.render_steps -> render_steps:   int  "Number of steps in the revolution"
+ * Modifier|ScrewModifier.screw_offset -> screw_offset:   float  "Offset the revolution along its axis"
+ * Modifier|ScrewModifier.steps -> steps:   int  "Number of steps in the revolution"
+ * Modifier|ScrewModifier.use_normal_calculate -> use_normal_calculate:   boolean  "Calculate the order of edges (needed for meshes, but not curves)"
+ * Modifier|ScrewModifier.use_normal_flip -> use_normal_flip:   boolean  "Flip normals of lathed faces"
+ * Modifier|ScrewModifier.use_object_screw_offset -> use_object_screw_offset:   boolean  "Use the distance between the objects to make a screw"
+ * Modifier|ShrinkwrapModifier.auxiliary_target -> auxiliary_target:   pointer  "Additional mesh target to shrink to"
+ * Modifier|ShrinkwrapModifier.offset -> offset:   float  "Distance to keep from the target"
+ * Modifier|ShrinkwrapModifier.subsurf_levels -> subsurf_levels:   int  "Number of subdivisions that must be performed before extracting vertices positions and normals"
+ * Modifier|ShrinkwrapModifier.target -> target:   pointer  "Mesh target to shrink to"
+ * Modifier|ShrinkwrapModifier.cull_back_faces -> use_cull_back_faces:   boolean  "Stop vertices from projecting to a back face on the target"
+ * Modifier|ShrinkwrapModifier.cull_front_faces -> use_cull_front_faces:   boolean  "Stop vertices from projecting to a front face on the target"
+ * Modifier|ShrinkwrapModifier.keep_above_surface -> use_keep_above_surface:   boolean  "NO DESCRIPTION"
+ * Modifier|ShrinkwrapModifier.negative -> use_negative_direction:   boolean  "Allow vertices to move in the negative direction of axis"
+ * Modifier|ShrinkwrapModifier.positive -> use_positive_direction:   boolean  "Allow vertices to move in the positive direction of axis"
+ * Modifier|ShrinkwrapModifier.x -> use_project_x:   boolean  "NO DESCRIPTION"
+ * Modifier|ShrinkwrapModifier.y -> use_project_y:   boolean  "NO DESCRIPTION"
+ * Modifier|ShrinkwrapModifier.z -> use_project_z:   boolean  "NO DESCRIPTION"
+ * Modifier|ShrinkwrapModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|ShrinkwrapModifier.mode -> wrap_method:   enum  "NO DESCRIPTION"
+ * Modifier|SimpleDeformModifier.mode -> deform_method:   enum  "NO DESCRIPTION"
+ * Modifier|SimpleDeformModifier.factor -> factor:   float  "NO DESCRIPTION"
+ * Modifier|SimpleDeformModifier.limits -> limits:   float[2]  "Lower/Upper limits for deform"
+ * Modifier|SimpleDeformModifier.lock_x_axis -> lock_x:   boolean  "NO DESCRIPTION"
+ * Modifier|SimpleDeformModifier.lock_y_axis -> lock_y:   boolean  "NO DESCRIPTION"
+ * Modifier|SimpleDeformModifier.origin -> origin:   pointer  "Origin of modifier space coordinates"
+ * Modifier|SimpleDeformModifier.relative -> use_relative:   boolean  "Sets the origin of deform space to be relative to the object"
+ * Modifier|SimpleDeformModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|SmokeModifier.coll_settings -> coll_settings:   pointer,  "(read-only)"
+ * Modifier|SmokeModifier.domain_settings -> domain_settings:   pointer,  "(read-only)"
+ * Modifier|SmokeModifier.flow_settings -> flow_settings:   pointer,  "(read-only)"
+ * Modifier|SmokeModifier.smoke_type -> type:   enum  "NO DESCRIPTION"
+ * Modifier|SmoothModifier.factor -> factor:   float  "NO DESCRIPTION"
+ * Modifier|SmoothModifier.repeat -> iterations:   int  "NO DESCRIPTION"
+ * Modifier|SmoothModifier.x -> use_x:   boolean  "NO DESCRIPTION"
+ * Modifier|SmoothModifier.y -> use_y:   boolean  "NO DESCRIPTION"
+ * Modifier|SmoothModifier.z -> use_z:   boolean  "NO DESCRIPTION"
+ * Modifier|SmoothModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|SoftBodyModifier.point_cache -> point_cache:   pointer,  "(read-only)"
+ * Modifier|SoftBodyModifier.settings -> settings:   pointer,  "(read-only)"
+ * Modifier|SolidifyModifier.edge_crease_inner -> edge_crease_inner:   float  "Assign a crease to inner edges"
+ * Modifier|SolidifyModifier.edge_crease_outer -> edge_crease_outer:   float  "Assign a crease to outer edges"
+ * Modifier|SolidifyModifier.edge_crease_rim -> edge_crease_rim:   float  "Assign a crease to the edges making up the rim"
+ * Modifier|SolidifyModifier.invert -> invert_vertex_group:   boolean  "Invert the vertex group influence"
+ * Modifier|SolidifyModifier.offset -> offset:   float  "Offset the thickness from the center"
+ * Modifier|SolidifyModifier.thickness -> thickness:   float  "Thickness of the shell"
+ * Modifier|SolidifyModifier.use_even_offset -> use_even_offset:   boolean  "Maintain thickness by adjusting for sharp corners (slow, disable when not needed)"
+ * Modifier|SolidifyModifier.use_quality_normals -> use_quality_normals:   boolean  "Calculate normals which result in more even thickness (slow, disable when not needed)"
+ * Modifier|SolidifyModifier.use_rim -> use_rim:   boolean  "Create edge loops between the inner and outer surfaces on face edges (slow, disable when not needed)"
+ * Modifier|SolidifyModifier.use_rim_material -> use_rim_material:   boolean  "Use in the next material for rim faces"
+ * Modifier|SolidifyModifier.vertex_group -> vertex_group:   string  "Vertex group name"
+ * Modifier|SubsurfModifier.levels -> levels:   int  "Number of subdivisions to perform"
+ * Modifier|SubsurfModifier.render_levels -> render_levels:   int  "Number of subdivisions to perform when rendering"
+ * Modifier|SubsurfModifier.optimal_display -> show_only_control_edges:   boolean  "Skip drawing/rendering of interior subdivided edges"
+ * Modifier|SubsurfModifier.subdivision_type -> subdivision_type:   enum  "Selects type of subdivision algorithm"
+ * Modifier|SubsurfModifier.subsurf_uv -> use_subsurf_uv:   boolean  "Use subsurf to subdivide UVs"
+ * Modifier|UVProjectModifier.aspect_x -> aspect_x:   float  "NO DESCRIPTION"
+ * Modifier|UVProjectModifier.aspect_y -> aspect_y:   float  "NO DESCRIPTION"
+ * Modifier|UVProjectModifier.image -> image:   pointer  "NO DESCRIPTION"
+ * Modifier|UVProjectModifier.num_projectors -> projector_count:   int  "Number of projectors to use"
+ * Modifier|UVProjectModifier.projectors -> projectors:   collection,  "(read-only)"
+ * Modifier|UVProjectModifier.scale_x -> scale_x:   float  "NO DESCRIPTION"
+ * Modifier|UVProjectModifier.scale_y -> scale_y:   float  "NO DESCRIPTION"
+ * Modifier|UVProjectModifier.override_image -> use_image_override:   boolean  "Override faces current images with the given image"
+ * Modifier|UVProjectModifier.uv_layer -> uv_layer:   string  "UV layer name"
+ * Modifier|WaveModifier.damping_time -> damping_time:   float  "NO DESCRIPTION"
+ * Modifier|WaveModifier.falloff_radius -> falloff_radius:   float  "NO DESCRIPTION"
+ * Modifier|WaveModifier.height -> height:   float  "NO DESCRIPTION"
+ * Modifier|WaveModifier.lifetime -> lifetime:   float  "NO DESCRIPTION"
+ * Modifier|WaveModifier.narrowness -> narrowness:   float  "NO DESCRIPTION"
+ * Modifier|WaveModifier.speed -> speed:   float  "NO DESCRIPTION"
+ * Modifier|WaveModifier.start_position_object -> start_position_object:   pointer  "NO DESCRIPTION"
+ * Modifier|WaveModifier.start_position_x -> start_position_x:   float  "NO DESCRIPTION"
+ * Modifier|WaveModifier.start_position_y -> start_position_y:   float  "NO DESCRIPTION"
+ * Modifier|WaveModifier.texture -> texture:   pointer  "Texture for modulating the wave"
+ * Modifier|WaveModifier.texture_coordinates -> texture_coords:   enum  "Texture coordinates used for modulating input"
+ * Modifier|WaveModifier.texture_coordinates_object -> texture_coords_object:   pointer  "NO DESCRIPTION"
+ * Modifier|WaveModifier.time_offset -> time_offset:   float  "Either the starting frame (for positive speed) or ending frame (for negative speed.)"
+ * Modifier|WaveModifier.cyclic -> use_cyclic:   boolean  "Cyclic wave effect"
+ * Modifier|WaveModifier.normals -> use_normal:   boolean  "Displace along normals"
+ * Modifier|WaveModifier.x_normal -> use_normal_x:   boolean  "Enable displacement along the X normal"
+ * Modifier|WaveModifier.y_normal -> use_normal_y:   boolean  "Enable displacement along the Y normal"
+ * Modifier|WaveModifier.z_normal -> use_normal_z:   boolean  "Enable displacement along the Z normal"
+ * Modifier|WaveModifier.x -> use_x:   boolean  "X axis motion"
+ * Modifier|WaveModifier.y -> use_y:   boolean  "Y axis motion"
+ * Modifier|WaveModifier.uv_layer -> uv_layer:   string  "UV layer name"
+ * Modifier|WaveModifier.vertex_group -> vertex_group:   string  "Vertex group name for modulating the wave"
+ * Modifier|WaveModifier.width -> width:   float  "NO DESCRIPTION"
+ * MotionPath.frame_end -> frame_end:   int,  "(read-only)    End frame of the stored range"
+ * MotionPath.frame_start -> frame_start:   int,  "(read-only)    Starting frame of the stored range"
+ * MotionPath.editing -> is_modified:   boolean  "Path is being edited"
+ * MotionPath.length -> length:   int,  "(read-only)    Number of frames cached"
+ * MotionPath.points -> points:   collection,  "(read-only)    Cached positions per frame"
+ * MotionPath.use_bone_head -> use_bone_head:   boolean,  "(read-only)    For PoseBone paths, use the bone head location when calculating this path"
+ * MotionPathVert.co -> co:   float[3]  "NO DESCRIPTION"
+ * MotionPathVert.select -> select:   boolean  "Path point is selected for editing"
+ * NlaStrip.action -> action:   pointer  "Action referenced by this strip"
NlaStrip.action_frame_end -> action_frame_end:   float  "NO DESCRIPTION"
NlaStrip.action_frame_start -> action_frame_start:   float  "NO DESCRIPTION"
+ * NlaStrip.active -> active:   boolean,  "(read-only)    NLA Strip is active"
+ * NlaStrip.blend_in -> blend_in:   float  "Number of frames at start of strip to fade in influence"
+ * NlaStrip.blend_out -> blend_out:   float  "NO DESCRIPTION"
+ * NlaStrip.blending -> blend_type:   enum  "Method used for combining strips result with accumulated result"
+ * NlaStrip.extrapolation -> extrapolation:   enum  "Action to take for gaps past the strip extents"
+ * NlaStrip.fcurves -> fcurves:   collection,  "(read-only)    F-Curves for controlling the strips influence and timing"
+ * NlaStrip.frame_end -> frame_end:   float  "NO DESCRIPTION"
+ * NlaStrip.frame_start -> frame_start:   float  "NO DESCRIPTION"
+ * NlaStrip.influence -> influence:   float  "Amount the strip contributes to the current result"
+ * NlaStrip.modifiers -> modifiers:   collection,  "(read-only)    Modifiers affecting all the F-Curves in the referenced Action"
+ * NlaStrip.mute -> mute:   boolean  "NLA Strip is not evaluated"
+ * NlaStrip.name -> name:   string  "NO DESCRIPTION"
+ * NlaStrip.repeat -> repeat:   float  "Number of times to repeat the action range"
+ * NlaStrip.scale -> scale:   float  "Scaling factor for action"
+ * NlaStrip.select -> select:   boolean  "NLA Strip is selected"
+ * NlaStrip.strip_time -> strip_time:   float  "Frame of referenced Action to evaluate"
+ * NlaStrip.strips -> strips:   collection,  "(read-only)    NLA Strips that this strip acts as a container for (if it is of type Meta)"
+ * NlaStrip.type -> type:   enum,  "(read-only)    Type of NLA Strip"
+ * NlaStrip.animated_influence -> use_animated_influence:   boolean  "Influence setting is controlled by an F-Curve rather than automatically determined"
+ * NlaStrip.animated_time -> use_animated_time:   boolean  "Strip time is controlled by an F-Curve rather than automatically determined"
+ * NlaStrip.animated_time_cyclic -> use_animated_time_cyclic:   boolean  "Cycle the animated time within the action start & end"
+ * NlaStrip.auto_blending -> use_auto_blend:   boolean  "Number of frames for Blending In/Out is automatically determined from overlapping strips"
+ * NlaStrip.reversed -> use_reverse:   boolean  "NLA Strip is played back in reverse order (only when timing is automatically determined)"
+ * NlaTrack.active -> active:   boolean,  "(read-only)    NLA Track is active"
+ * NlaTrack.solo -> is_solo:   boolean,  "(read-only)    NLA Track is evaluated itself (i.e. active Action and all other NLA Tracks in the same AnimData block are disabled)"
+ * NlaTrack.lock -> lock:   boolean  "NLA Track is locked"
+ * NlaTrack.mute -> mute:   boolean  "NLA Track is not evaluated"
+ * NlaTrack.name -> name:   string  "NO DESCRIPTION"
+ * NlaTrack.select -> select:   boolean  "NLA Track is selected"
+ * NlaTrack.strips -> strips:   collection,  "(read-only)    NLA Strips on this NLA-track"
+ * Node.inputs -> inputs:   collection,  "(read-only)"
+ * Node.location -> location:   float[2]  "NO DESCRIPTION"
+ * Node.name -> name:   string  "Node name"
+ * Node.outputs -> outputs:   collection,  "(read-only)"
+ * Node|CompositorNode.type -> type:   enum,  "(read-only)"
+ * Node|CompositorNode|CompositorNodeAlphaOver.premul -> premul:   float  "Mix Factor"
+ * Node|CompositorNode|CompositorNodeAlphaOver.convert_premul -> use_premultiply:   boolean  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeBilateralblur.iterations -> iterations:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeBilateralblur.sigma_color -> sigma_color:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeBilateralblur.sigma_space -> sigma_space:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeBlur.factor -> factor:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeBlur.factor_x -> factor_x:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeBlur.factor_y -> factor_y:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeBlur.filter_type -> filter_type:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeBlur.sizex -> size_x:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeBlur.sizey -> size_y:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeBlur.bokeh -> use_bokeh:   boolean  "Uses circular filter (slower)"
+ * Node|CompositorNode|CompositorNodeBlur.gamma -> use_gamma_correction:   boolean  "Applies filter on gamma corrected values"
+ * Node|CompositorNode|CompositorNodeBlur.relative -> use_relative:   boolean  "Use relative (percent) values to define blur radius"
+ * Node|CompositorNode|CompositorNodeChannelMatte.color_space -> color_space:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeChannelMatte.limit_channel -> limit_channel:   enum  "Limit by this channels value"
+ * Node|CompositorNode|CompositorNodeChannelMatte.high -> limit_max:   float  "Values higher than this setting are 100% opaque"
+ * Node|CompositorNode|CompositorNodeChannelMatte.algorithm -> limit_method:   enum  "Algorithm to use to limit channel"
+ * Node|CompositorNode|CompositorNodeChannelMatte.low -> limit_min:   float  "Values lower than this setting are 100% keyed"
+ * Node|CompositorNode|CompositorNodeChannelMatte.channel -> matte_channel:   enum  "Channel used to determine matte"
+ * Node|CompositorNode|CompositorNodeChromaMatte.gain -> gain:   float  "Alpha gain"
+ * Node|CompositorNode|CompositorNodeChromaMatte.lift -> lift:   float  "Alpha lift"
+ * Node|CompositorNode|CompositorNodeChromaMatte.shadow_adjust -> shadow_adjust:   float  "Adjusts the brightness of any shadows captured"
+ * Node|CompositorNode|CompositorNodeChromaMatte.cutoff -> threshold:   float  "Tolerance below which colors will be considered as exact matches"
+ * Node|CompositorNode|CompositorNodeChromaMatte.acceptance -> tolerance:   float  "Tolerance for a color to be considered a keying color"
+ * Node|CompositorNode|CompositorNodeColorBalance.correction_formula -> correction_method:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeColorBalance.gain -> gain:   float[3]  "Correction for Highlights"
+ * Node|CompositorNode|CompositorNodeColorBalance.gamma -> gamma:   float[3]  "Correction for Midtones"
+ * Node|CompositorNode|CompositorNodeColorBalance.lift -> lift:   float[3]  "Correction for Shadows"
+ * Node|CompositorNode|CompositorNodeColorBalance.offset -> offset:   float[3]  "Correction for Shadows"
+ * Node|CompositorNode|CompositorNodeColorBalance.power -> power:   float[3]  "Correction for Midtones"
+ * Node|CompositorNode|CompositorNodeColorBalance.slope -> slope:   float[3]  "Correction for Highlights"
+ * Node|CompositorNode|CompositorNodeColorMatte.h -> color_hue:   float  "Hue tolerance for colors to be considered a keying color"
+ * Node|CompositorNode|CompositorNodeColorMatte.s -> color_saturation:   float  "Saturation Tolerance for the color"
+ * Node|CompositorNode|CompositorNodeColorMatte.v -> color_value:   float  "Value Tolerance for the color"
+ * Node|CompositorNode|CompositorNodeColorSpill.channel -> channel:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeColorSpill.limit_channel -> limit_channel:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeColorSpill.algorithm -> limit_method:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeColorSpill.ratio -> ratio:   float  "Scale limit by value"
+ * Node|CompositorNode|CompositorNodeColorSpill.unspill_blue -> unspill_blue:   float  "Blue spillmap scale"
+ * Node|CompositorNode|CompositorNodeColorSpill.unspill_green -> unspill_green:   float  "Green spillmap scale"
+ * Node|CompositorNode|CompositorNodeColorSpill.unspill_red -> unspill_red:   float  "Red spillmap scale"
+ * Node|CompositorNode|CompositorNodeColorSpill.unspill -> use_unspill:   boolean  "Compensate all channels (diffenrently) by hand"
+ * Node|CompositorNode|CompositorNodeCrop.x2 -> max_x:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeCrop.y2 -> max_y:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeCrop.x1 -> min_x:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeCrop.y1 -> min_y:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeCrop.crop_size -> use_crop_size:   boolean  "Whether to crop the size of the input image"
+ * Node|CompositorNode|CompositorNodeCurveRGB.mapping -> mapping:   pointer,  "(read-only)"
+ * Node|CompositorNode|CompositorNodeCurveVec.mapping -> mapping:   pointer,  "(read-only)"
+ * Node|CompositorNode|CompositorNodeDBlur.angle -> angle:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeDBlur.center_x -> center_x:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeDBlur.center_y -> center_y:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeDBlur.distance -> distance:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeDBlur.iterations -> iterations:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeDBlur.spin -> spin:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeDBlur.wrap -> use_wrap:   boolean  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeDBlur.zoom -> zoom:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeDefocus.angle -> angle:   int  "Bokeh shape rotation offset in degrees"
+ * Node|CompositorNode|CompositorNodeDefocus.max_blur -> blur_max:   float  "blur limit, maximum CoC radius, 0=no limit"
+ * Node|CompositorNode|CompositorNodeDefocus.bokeh -> bokeh:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeDefocus.f_stop -> f_stop:   float  "Amount of focal blur, 128=infinity=perfect focus, half the value doubles the blur radius"
+ * Node|CompositorNode|CompositorNodeDefocus.samples -> samples:   int  "Number of samples (16=grainy, higher=less noise)"
+ * Node|CompositorNode|CompositorNodeDefocus.threshold -> threshold:   float  "CoC radius threshold, prevents background bleed on in-focus midground, 0=off"
+ * Node|CompositorNode|CompositorNodeDefocus.gamma_correction -> use_gamma_correction:   boolean  "Enable gamma correction before and after main process"
+ * Node|CompositorNode|CompositorNodeDefocus.preview -> use_preview:   boolean  "Enable sampling mode, useful for preview when using low samplecounts"
+ * Node|CompositorNode|CompositorNodeDefocus.use_zbuffer -> use_zbuffer:   boolean  "Disable when using an image as input instead of actual zbuffer (auto enabled if node not image based, eg. time node)"
+ * Node|CompositorNode|CompositorNodeDefocus.z_scale -> z_scale:   float  "Scales the Z input when not using a zbuffer, controls maximum blur designated by the color white or input value 1"
+ * Node|CompositorNode|CompositorNodeDiffMatte.falloff -> falloff:   float  "Color distances below this additional threshold are partially keyed"
+ * Node|CompositorNode|CompositorNodeDiffMatte.tolerance -> tolerance:   float  "Color distances below this threshold are keyed"
+ * Node|CompositorNode|CompositorNodeDilateErode.distance -> distance:   int  "Distance to grow/shrink (number of iterations)"
+ * Node|CompositorNode|CompositorNodeDistanceMatte.falloff -> falloff:   float  "Color distances below this additional threshold are partially keyed"
+ * Node|CompositorNode|CompositorNodeDistanceMatte.tolerance -> tolerance:   float  "Color distances below this threshold are keyed"
+ * Node|CompositorNode|CompositorNodeFilter.filter_type -> filter_type:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeFlip.axis -> axis:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeGlare.angle_offset -> angle_offset:   float  "Streak angle offset in degrees"
+ * Node|CompositorNode|CompositorNodeGlare.color_modulation -> color_modulation:   float  "Amount of Color Modulation, modulates colors of streaks and ghosts for a spectral dispersion effect"
+ * Node|CompositorNode|CompositorNodeGlare.fade -> fade:   float  "Streak fade-out factor"
+ * Node|CompositorNode|CompositorNodeGlare.glare_type -> glare_type:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeGlare.iterations -> iterations:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeGlare.mix -> mix:   float  "-1 is original image only, 0 is exact 50/50 mix, 1 is processed image only"
+ * Node|CompositorNode|CompositorNodeGlare.quality -> quality:   enum  "If not set to high quality, the effect will be applied to a low-res copy of the source image"
+ * Node|CompositorNode|CompositorNodeGlare.size -> size:   int  "Glow/glare size (not actual size; relative to initial size of bright area of pixels)"
+ * Node|CompositorNode|CompositorNodeGlare.streaks -> streaks:   int  "Total number of streaks"
+ * Node|CompositorNode|CompositorNodeGlare.threshold -> threshold:   float  "The glare filter will only be applied to pixels brighter than this value"
+ * Node|CompositorNode|CompositorNodeGlare.rotate_45 -> use_rotate_45:   boolean  "Simple star filter: add 45 degree rotation offset"
+ * Node|CompositorNode|CompositorNodeHueCorrect.mapping -> mapping:   pointer,  "(read-only)"
+ * Node|CompositorNode|CompositorNodeHueSat.hue -> color_hue:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeHueSat.sat -> color_saturation:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeHueSat.val -> color_value:   float  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeIDMask.index -> index:   int  "Pass index number to convert to alpha"
+ * Node|CompositorNode|CompositorNodeImage.frames -> frame_duration:   int  "Number of images used in animation"
+ * Node|CompositorNode|CompositorNodeImage.offset -> frame_offset:   int  "Offsets the number of the frame to use in the animation"
+ * Node|CompositorNode|CompositorNodeImage.start -> frame_start:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeImage.image -> image:   pointer  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeImage.layer -> layer:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeImage.auto_refresh -> use_auto_refresh:   boolean  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeImage.cyclic -> use_cyclic:   boolean  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeInvert.alpha -> invert_alpha:   boolean  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeInvert.rgb -> invert_rgb:   boolean  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeLensdist.fit -> use_fit:   boolean  "For positive distortion factor only: scale image such that black areas are not visible"
+ * Node|CompositorNode|CompositorNodeLensdist.jitter -> use_jitter:   boolean  "Enable/disable jittering; faster, but also noisier"
+ * Node|CompositorNode|CompositorNodeLensdist.projector -> use_projector:   boolean  "Enable/disable projector mode. Effect is applied in horizontal direction only"
+ * Node|CompositorNode|CompositorNodeLevels.channel -> channel:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeLumaMatte.high -> high:   float  "Values higher than this setting are 100% opaque"
+ * Node|CompositorNode|CompositorNodeLumaMatte.low -> low:   float  "Values lower than this setting are 100% keyed"
+ * Node|CompositorNode|CompositorNodeMapUV.alpha -> alpha:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeMapValue.max -> max:   float[1]  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeMapValue.min -> min:   float[1]  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeMapValue.offset -> offset:   float[1]  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeMapValue.size -> size:   float[1]  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeMapValue.use_max -> use_max:   boolean  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeMapValue.use_min -> use_min:   boolean  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeMath.operation -> operation:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeMixRGB.blend_type -> blend_type:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeMixRGB.alpha -> use_alpha:   boolean  "Include alpha of second input in this operation"
+ * Node|CompositorNode|CompositorNodeOutputFile.exr_codec -> exr_codec:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeOutputFile.filepath -> filepath:   string  "Output path for the image, same functionality as render output."
+ * Node|CompositorNode|CompositorNodeOutputFile.frame_end -> frame_end:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeOutputFile.frame_start -> frame_start:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeOutputFile.image_type -> image_type:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeOutputFile.quality -> quality:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeOutputFile.exr_half -> use_exr_half:   boolean  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodePremulKey.mapping -> mapping:   enum  "Conversion between premultiplied alpha and key alpha"
+ * Node|CompositorNode|CompositorNodeRLayers.layer -> layer:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeRLayers.scene -> scene:   pointer  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeRotate.filter -> filter_type:   enum  "Method to use to filter rotation"
+ * Node|CompositorNode|CompositorNodeScale.space -> space:   enum  "Coordinate space to scale relative to"
+ * Node|CompositorNode|CompositorNodeSplitViewer.axis -> axis:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeSplitViewer.factor -> factor:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeTexture.node_output -> node_output:   int  "For node-based textures, which output node to use"
+ * Node|CompositorNode|CompositorNodeTexture.texture -> texture:   pointer  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeTime.curve -> curve:   pointer,  "(read-only)"
+ * Node|CompositorNode|CompositorNodeTime.end -> frame_end:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeTime.start -> frame_start:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeTonemap.adaptation -> adaptation:   float  "If 0, global; if 1, based on pixel intensity"
+ * Node|CompositorNode|CompositorNodeTonemap.contrast -> contrast:   float  "Set to 0 to use estimate from input image"
+ * Node|CompositorNode|CompositorNodeTonemap.correction -> correction:   float  "If 0, same for all channels; if 1, each independent"
+ * Node|CompositorNode|CompositorNodeTonemap.gamma -> gamma:   float  "If not used, set to 1"
+ * Node|CompositorNode|CompositorNodeTonemap.intensity -> intensity:   float  "If less than zero, darkens image; otherwise, makes it brighter"
+ * Node|CompositorNode|CompositorNodeTonemap.key -> key:   float  "The value the average luminance is mapped to"
+ * Node|CompositorNode|CompositorNodeTonemap.offset -> offset:   float  "Normally always 1, but can be used as an extra control to alter the brightness curve"
+ * Node|CompositorNode|CompositorNodeTonemap.tonemap_type -> type:   enum  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeValToRGB.color_ramp -> color_ramp:   pointer,  "(read-only)"
+ * Node|CompositorNode|CompositorNodeVecBlur.factor -> factor:   float  "Scaling factor for motion vectors; actually shutter speed in frames"
+ * Node|CompositorNode|CompositorNodeVecBlur.samples -> samples:   int  "NO DESCRIPTION"
+ * Node|CompositorNode|CompositorNodeVecBlur.max_speed -> speed_max:   int  "Maximum speed, or zero for none"
+ * Node|CompositorNode|CompositorNodeVecBlur.min_speed -> speed_min:   int  "Minimum speed for a pixel to be blurred; used to separate background from foreground"
+ * Node|CompositorNode|CompositorNodeVecBlur.curved -> use_curved:   boolean  "Interpolate between frames in a bezier curve, rather than linearly"
+ * Node|NodeGroup.nodetree -> nodetree:   pointer  "NO DESCRIPTION"
+ * Node|ShaderNode.type -> type:   enum,  "(read-only)"
+ * Node|ShaderNode|ShaderNodeExtendedMaterial.invert_normal -> invert_normal:   boolean  "Material Node uses inverted normal"
+ * Node|ShaderNode|ShaderNodeExtendedMaterial.material -> material:   pointer  "NO DESCRIPTION"
+ * Node|ShaderNode|ShaderNodeExtendedMaterial.diffuse -> use_diffuse:   boolean  "Material Node outputs Diffuse"
+ * Node|ShaderNode|ShaderNodeExtendedMaterial.specular -> use_specular:   boolean  "Material Node outputs Specular"
+ * Node|ShaderNode|ShaderNodeGeometry.color_layer -> color_layer:   string  "NO DESCRIPTION"
+ * Node|ShaderNode|ShaderNodeGeometry.uv_layer -> uv_layer:   string  "NO DESCRIPTION"
+ * Node|ShaderNode|ShaderNodeMapping.location -> location:   float[3]  "Location offset for the input coordinate"
+ * Node|ShaderNode|ShaderNodeMapping.maximum -> max:   float[3]  "Maximum value to clamp coordinate to"
+ * Node|ShaderNode|ShaderNodeMapping.minimum -> min:   float[3]  "Minimum value to clamp coordinate to"
+ * Node|ShaderNode|ShaderNodeMapping.rotation -> rotation:   float[3]  "Rotation offset for the input coordinate"
+ * Node|ShaderNode|ShaderNodeMapping.scale -> scale:   float[3]  "Scale adjustment for the input coordinate"
+ * Node|ShaderNode|ShaderNodeMapping.clamp_maximum -> use_max:   boolean  "Clamp the output coordinate to a maximum value"
+ * Node|ShaderNode|ShaderNodeMapping.clamp_minimum -> use_min:   boolean  "Clamp the output coordinate to a minimum value"
+ * Node|ShaderNode|ShaderNodeMaterial.invert_normal -> invert_normal:   boolean  "Material Node uses inverted normal"
+ * Node|ShaderNode|ShaderNodeMaterial.material -> material:   pointer  "NO DESCRIPTION"
+ * Node|ShaderNode|ShaderNodeMaterial.diffuse -> use_diffuse:   boolean  "Material Node outputs Diffuse"
+ * Node|ShaderNode|ShaderNodeMaterial.specular -> use_specular:   boolean  "Material Node outputs Specular"
+ * Node|ShaderNode|ShaderNodeMath.operation -> operation:   enum  "NO DESCRIPTION"
+ * Node|ShaderNode|ShaderNodeMixRGB.blend_type -> blend_type:   enum  "NO DESCRIPTION"
+ * Node|ShaderNode|ShaderNodeMixRGB.alpha -> use_alpha:   boolean  "Include alpha of second input in this operation"
+ * Node|ShaderNode|ShaderNodeRGBCurve.mapping -> mapping:   pointer,  "(read-only)"
+ * Node|ShaderNode|ShaderNodeTexture.node_output -> node_output:   int  "For node-based textures, which output node to use"
+ * Node|ShaderNode|ShaderNodeTexture.texture -> texture:   pointer  "NO DESCRIPTION"
+ * Node|ShaderNode|ShaderNodeValToRGB.color_ramp -> color_ramp:   pointer,  "(read-only)"
+ * Node|ShaderNode|ShaderNodeVectorCurve.mapping -> mapping:   pointer,  "(read-only)"
+ * Node|ShaderNode|ShaderNodeVectorMath.operation -> operation:   enum  "NO DESCRIPTION"
+ * Node|TextureNode.type -> type:   enum,  "(read-only)"
+ * Node|TextureNode|TextureNodeBricks.offset -> offset:   float  "NO DESCRIPTION"
+ * Node|TextureNode|TextureNodeBricks.offset_frequency -> offset_frequency:   int  "Offset every N rows"
+ * Node|TextureNode|TextureNodeBricks.squash -> squash:   float  "NO DESCRIPTION"
+ * Node|TextureNode|TextureNodeBricks.squash_frequency -> squash_frequency:   int  "Squash every N rows"
+ * Node|TextureNode|TextureNodeCurveRGB.mapping -> mapping:   pointer,  "(read-only)"
+ * Node|TextureNode|TextureNodeCurveTime.curve -> curve:   pointer,  "(read-only)"
+ * Node|TextureNode|TextureNodeCurveTime.end -> frame_end:   int  "NO DESCRIPTION"
+ * Node|TextureNode|TextureNodeCurveTime.start -> frame_start:   int  "NO DESCRIPTION"
+ * Node|TextureNode|TextureNodeImage.image -> image:   pointer  "NO DESCRIPTION"
+ * Node|TextureNode|TextureNodeMath.operation -> operation:   enum  "NO DESCRIPTION"
+ * Node|TextureNode|TextureNodeMixRGB.blend_type -> blend_type:   enum  "NO DESCRIPTION"
+ * Node|TextureNode|TextureNodeMixRGB.alpha -> use_alpha:   boolean  "Include alpha of second input in this operation"
+ * Node|TextureNode|TextureNodeOutput.output_name -> filepath:   string  "NO DESCRIPTION"
+ * Node|TextureNode|TextureNodeTexture.node_output -> node_output:   int  "For node-based textures, which output node to use"
+ * Node|TextureNode|TextureNodeTexture.texture -> texture:   pointer  "NO DESCRIPTION"
+ * Node|TextureNode|TextureNodeValToRGB.color_ramp -> color_ramp:   pointer,  "(read-only)"
+ * ObjectBase.layers -> layers:   boolean[20]  "Layers the object base is on"
+ * ObjectBase.object -> object:   pointer,  "(read-only)    Object this base links to"
+ * ObjectBase.select -> select:   boolean  "Object base selection state"
+ * ObjectConstraints.active -> active:   pointer  "Active Object constraint"
+ * Operator.bl_description -> bl_description:   string  "NO DESCRIPTION"
+ * Operator.bl_idname -> bl_idname:   string  "NO DESCRIPTION"
+ * Operator.bl_label -> bl_label:   string  "NO DESCRIPTION"
+ * Operator.bl_options -> bl_options:   enum  "Options for this operator type"
+ * Operator.has_reports -> has_reports:   boolean,  "(read-only)    Operator has a set of reports (warnings and errors) from last execution"
+ * Operator.layout -> layout:   pointer,  "(read-only)"
+ * Operator.name -> name:   string,  "(read-only)"
+ * Operator.properties -> properties:   pointer,  "(read-only)"
+ * OperatorTypeMacro.properties -> properties:   pointer,  "(read-only)"
+ * PackedFile.size -> size:   int,  "(read-only)    Size of packed file in bytes"
+ * Paint.brush -> brush:   pointer  "Active Brush"
+ * Paint.show_brush -> show_brush:   boolean  "NO DESCRIPTION"
+ * Paint.show_brush_on_surface -> show_brush_on_surface:   boolean  "NO DESCRIPTION"
+ * Paint.fast_navigate -> show_low_resolution:   boolean  "For multires, show low resolution while navigating the view"
+ * Paint|ImagePaint.invert_stencil -> invert_stencil:   boolean  "Invert the stencil layer"
+ * Paint|ImagePaint.normal_angle -> normal_angle:   int  "Paint most on faces pointing towards the view according to this angle"
+ * Paint|ImagePaint.screen_grab_size -> screen_grab_size:   int[2]  "Size to capture the image for re-projecting"
+ * Paint|ImagePaint.seam_bleed -> seam_bleed:   int  "Extend paint beyond the faces UVs to reduce seams (in pixels, slower)"
+ * Paint|ImagePaint.show_brush -> show_brush:   boolean  "Enables brush shape while not drawing"
+ * Paint|ImagePaint.show_brush_draw -> show_brush_draw:   boolean  "Enables brush shape while drawing"
+ * Paint|ImagePaint.use_backface_cull -> use_backface_culling:   boolean  "Ignore faces pointing away from the view (faster)"
+ * Paint|ImagePaint.use_clone_layer -> use_clone_layer:   boolean  "Use another UV layer as clone source, otherwise use 3D the cursor as the source"
+ * Paint|ImagePaint.use_normal_falloff -> use_normal_falloff:   boolean  "Paint most on faces pointing towards the view"
+ * Paint|ImagePaint.use_occlude -> use_occlude:   boolean  "Only paint onto the faces directly under the brush (slower)"
+ * Paint|ImagePaint.use_projection -> use_projection:   boolean  "Use projection painting for improved consistency in the brush strokes"
+ * Paint|ImagePaint.use_stencil_layer -> use_stencil_layer:   boolean  "Set the mask layer from the UV layer buttons"
+ * Paint|Sculpt.lock_x -> lock_x:   boolean  "Disallow changes to the X axis of vertices"
+ * Paint|Sculpt.lock_y -> lock_y:   boolean  "Disallow changes to the Y axis of vertices"
+ * Paint|Sculpt.lock_z -> lock_z:   boolean  "Disallow changes to the Z axis of vertices"
+ * Paint|Sculpt.radial_symm -> radial_symmetry:   int[3]  "Number of times to copy strokes across the surface"
+ * Paint|Sculpt.use_openmp -> use_multithread:   boolean  "Take advantage of multiple CPU cores to improve sculpting performance"
+ * Paint|Sculpt.use_symmetry_feather -> use_symmetry_feather:   boolean  "Reduce the strength of the brush where it overlaps symmetrical daubs"
+ * Paint|Sculpt.symmetry_x -> use_symmetry_x:   boolean  "Mirror brush across the X axis"
+ * Paint|Sculpt.symmetry_y -> use_symmetry_y:   boolean  "Mirror brush across the Y axis"
+ * Paint|Sculpt.symmetry_z -> use_symmetry_z:   boolean  "Mirror brush across the Z axis"
+ * Paint|VertexPaint.all_faces -> use_all_faces:   boolean  "Paint on all faces inside brush"
+ * Paint|VertexPaint.normals -> use_normal:   boolean  "Applies the vertex normal before painting"
+ * Paint|VertexPaint.spray -> use_spray:   boolean  "Keep applying paint effect while holding mouse"
+ * Panel.bl_context -> bl_context:   string  "The context in which the panel belongs to. (TODO: explain the possible combinations bl_context/bl_region_type/bl_space_type)"
+ * Panel.bl_idname -> bl_idname:   string  "If this is set, the panel gets a custom ID, otherwise it takes the name of the class used to define the panel. For example, if the class name is OBJECT_PT_hello, and bl_idname is not set by the script, then bl_idname = OBJECT_PT_hello"
+ * Panel.bl_label -> bl_label:   string  "The panel label, shows up in the panel header at the right of the triangle used to collapse the panel."
+ * Panel.bl_region_type -> bl_region_type:   enum  "The region where the panel is going to be used in."
+ * Panel.bl_show_header -> bl_show_header:   boolean  "If set to True, the panel shows a header, which contains a clickable arrow to collapse the panel and the label (see bl_label)."
+ * Panel.bl_space_type -> bl_space_type:   enum  "The space where the panel is going to be used in."
+ * Panel.bl_default_closed -> bl_use_closed:   boolean  "Defines if the panel has to be open or collapsed at the time of its creation. Note that once the panel has been created with bl_default_closed = True, at reload (F8) it stays open."
+ * Panel.layout -> layout:   pointer,  "(read-only)    Defines the structure of the panel in the UI."
TODO SHOULD THIS BE HERE * Panel.text -> text:   string  "XXX todo"
+ * Particle.alive_state -> alive_state:   enum  "NO DESCRIPTION"
+ * Particle.angular_velocity -> angular_velocity:   float[3]  "NO DESCRIPTION"
+ * Particle.birthtime -> birth_time:   float  "NO DESCRIPTION"
+ * Particle.die_time -> die_time:   float  "NO DESCRIPTION"
+ * Particle.hair -> hair:   collection,  "(read-only)"
+ * Particle.is_existing -> is_exist:   boolean,  "(read-only)"
+ * Particle.is_visible -> is_visible:   boolean,  "(read-only)"
+ * Particle.keys -> keys:   collection,  "(read-only)"
+ * Particle.lifetime -> life_time:   float  "NO DESCRIPTION"
+ * Particle.location -> location:   float[3]  "NO DESCRIPTION"
+ * Particle.prev_angular_velocity -> prev_angular_velocity:   float[3]  "NO DESCRIPTION"
+ * Particle.prev_location -> prev_location:   float[3]  "NO DESCRIPTION"
+ * Particle.prev_rotation -> prev_rotation:   float[4]  "NO DESCRIPTION"
+ * Particle.prev_velocity -> prev_velocity:   float[3]  "NO DESCRIPTION"
+ * Particle.rotation -> rotation:   float[4]  "NO DESCRIPTION"
+ * Particle.size -> size:   float  "NO DESCRIPTION"
+ * Particle.velocity -> velocity:   float[3]  "NO DESCRIPTION"
+ * ParticleBrush.count -> count:   int  "Particle count"
+ * ParticleBrush.curve -> curve:   pointer,  "(read-only)"
+ * ParticleBrush.length_mode -> length_mode:   enum  "NO DESCRIPTION"
+ * ParticleBrush.puff_mode -> puff_mode:   enum  "NO DESCRIPTION"
+ * ParticleBrush.size -> size:   int  "Brush size"
+ * ParticleBrush.steps -> steps:   int  "Brush steps"
+ * ParticleBrush.strength -> strength:   float  "Brush strength"
+ * ParticleBrush.use_puff_volume -> use_puff_volume:   boolean  "Apply puff to unselected end-points, (helps maintain hair volume when puffing root)"
+ * ParticleDupliWeight.count -> count:   int  "The number of times this object is repeated with respect to other objects"
+ * ParticleDupliWeight.name -> name:   string,  "(read-only)    Particle dupliobject name"
+ * ParticleEdit.brush -> brush:   pointer,  "(read-only)"
+ * ParticleEdit.add_keys -> default_key_count:   int  "How many keys to make new particles with"
+ * ParticleEdit.draw_step -> draw_step:   int  "How many steps to draw the path with"
+ * ParticleEdit.emitter_distance -> emitter_distance:   float  "Distance to keep particles away from the emitter"
+ * ParticleEdit.fade_frames -> fade_frames:   int  "How many frames to fade"
+ * ParticleEdit.hair -> is_hair:   boolean,  "(read-only)    Editing hair"
+ * ParticleEdit.editable -> is_valid:   boolean,  "(read-only)    A valid edit mode exists"
+ * ParticleEdit.object -> object:   pointer,  "(read-only)    The edited object"
+ * ParticleEdit.selection_mode -> select_mode:   enum  "Particle select and display mode"
+ * ParticleEdit.draw_particles -> show_particles:   boolean  "Draw actual particles"
+ * ParticleEdit.tool -> tool:   enum  "NO DESCRIPTION"
+ * ParticleEdit.type -> type:   enum  "NO DESCRIPTION"
+ * ParticleEdit.auto_velocity -> use_auto_velocity:   boolean  "Calculate point velocities automatically"
+ * ParticleEdit.add_interpolate -> use_default_interpolate:   boolean  "Interpolate new particles from the existing ones"
+ * ParticleEdit.emitter_deflect -> use_emitter_deflect:   boolean  "Keep paths from intersecting the emitter"
+ * ParticleEdit.fade_time -> use_fade_time:   boolean  "Fade paths and keys further away from current frame"
+ * ParticleEdit.keep_lengths -> use_preserve_length:   boolean  "Keep path lengths constant"
+ * ParticleEdit.keep_root -> use_preserve_root:   boolean  "Keep root keys unmodified"
+ * ParticleHairKey.location -> location:   float[3]  "Location of the hair key in object space"
+ * ParticleHairKey.location_hairspace -> location_hair_space:   float[3]  "Location of the hair key in its internal coordinate system, relative to the emitting face"
+ * ParticleHairKey.time -> time:   float  "Relative time of key over hair length"
+ * ParticleHairKey.weight -> weight:   float  "Weight for cloth simulation"
+ * ParticleKey.angular_velocity -> angular_velocity:   float[3]  "Key angular velocity"
+ * ParticleKey.location -> location:   float[3]  "Key location"
+ * ParticleKey.rotation -> rotation:   float[4]  "Key rotation quaterion"
+ * ParticleKey.time -> time:   float  "Time of key over the simulation"
+ * ParticleKey.velocity -> velocity:   float[3]  "Key velocity"
+ * ParticleSystem.active_particle_target -> active_particle_target:   pointer,  "(read-only)"
+ * ParticleSystem.active_particle_target_index -> active_particle_target_index:   int  "NO DESCRIPTION"
+ * ParticleSystem.billboard_normal_uv -> billboard_normal_uv:   string  "UV Layer to control billboard normals"
+ * ParticleSystem.billboard_split_uv -> billboard_split_uv:   string  "UV Layer to control billboard splitting"
+ * ParticleSystem.billboard_time_index_uv -> billboard_time_index_uv:   string  "UV Layer to control billboard time index (X-Y)"
+ * ParticleSystem.child_particles -> child_particles:   collection,  "(read-only)    Child particles generated by the particle system"
+ * ParticleSystem.cloth -> cloth:   pointer,  "(read-only)    Cloth dynamics for hair"
+ * ParticleSystem.multiple_caches -> has_multiple_caches:   boolean,  "(read-only)    Particle system has multiple point caches"
+ * ParticleSystem.vertex_group_clump_negate -> invert_vertex_group_clump:   boolean  "Negate the effect of the clump vertex group"
+ * ParticleSystem.vertex_group_density_negate -> invert_vertex_group_density:   boolean  "Negate the effect of the density vertex group"
+ * ParticleSystem.vertex_group_field_negate -> invert_vertex_group_field:   boolean  "Negate the effect of the field vertex group"
+ * ParticleSystem.vertex_group_kink_negate -> invert_vertex_group_kink:   boolean  "Negate the effect of the kink vertex group"
+ * ParticleSystem.vertex_group_length_negate -> invert_vertex_group_length:   boolean  "Negate the effect of the length vertex group"
+ * ParticleSystem.vertex_group_rotation_negate -> invert_vertex_group_rotation:   boolean  "Negate the effect of the rotation vertex group"
+ * ParticleSystem.vertex_group_roughness1_negate -> invert_vertex_group_roughness_1:   boolean  "Negate the effect of the roughness 1 vertex group"
+ * ParticleSystem.vertex_group_roughness2_negate -> invert_vertex_group_roughness_2:   boolean  "Negate the effect of the roughness 2 vertex group"
+ * ParticleSystem.vertex_group_roughness_end_negate -> invert_vertex_group_roughness_end:   boolean  "Negate the effect of the roughness end vertex group"
+ * ParticleSystem.vertex_group_size_negate -> invert_vertex_group_size:   boolean  "Negate the effect of the size vertex group"
+ * ParticleSystem.vertex_group_tangent_negate -> invert_vertex_group_tangent:   boolean  "Negate the effect of the tangent vertex group"
+ * ParticleSystem.vertex_group_velocity_negate -> invert_vertex_group_velocity:   boolean  "Negate the effect of the velocity vertex group"
+ * ParticleSystem.editable -> is_editable:   boolean,  "(read-only)    Particle system can be edited in particle mode"
+ * ParticleSystem.edited -> is_edited:   boolean,  "(read-only)    Particle system has been edited in particle mode"
+ * ParticleSystem.global_hair -> is_global_hair:   boolean,  "(read-only)    Hair keys are in global coordinate space"
+ * ParticleSystem.name -> name:   string  "Particle system name"
+ * ParticleSystem.parent -> parent:   pointer  "Use this objects coordinate system instead of global coordinate system"
+ * ParticleSystem.particles -> particles:   collection,  "(read-only)    Particles generated by the particle system"
+ * ParticleSystem.point_cache -> point_cache:   pointer,  "(read-only)"
+ * ParticleSystem.reactor_target_object -> reactor_target_object:   pointer  "For reactor systems, the object that has the target particle system (empty if same object)"
+ * ParticleSystem.reactor_target_particle_system -> reactor_target_particle_system:   int  "For reactor systems, index of particle system on the target object"
+ * ParticleSystem.seed -> seed:   int  "Offset in the random number table, to get a different randomized result"
+ * ParticleSystem.settings -> settings:   pointer  "Particle system settings"
+ * ParticleSystem.targets -> targets:   collection,  "(read-only)    Target particle systems"
+ * ParticleSystem.hair_dynamics -> use_hair_dynamics:   boolean  "Enable hair dynamics using cloth simulation"
+ * ParticleSystem.keyed_timing -> use_keyed_timing:   boolean  "Use key times"
+ * ParticleSystem.vertex_group_clump -> vertex_group_clump:   string  "Vertex group to control clump"
+ * ParticleSystem.vertex_group_density -> vertex_group_density:   string  "Vertex group to control density"
+ * ParticleSystem.vertex_group_field -> vertex_group_field:   string  "Vertex group to control field"
+ * ParticleSystem.vertex_group_kink -> vertex_group_kink:   string  "Vertex group to control kink"
+ * ParticleSystem.vertex_group_length -> vertex_group_length:   string  "Vertex group to control length"
+ * ParticleSystem.vertex_group_rotation -> vertex_group_rotation:   string  "Vertex group to control rotation"
+ * ParticleSystem.vertex_group_roughness1 -> vertex_group_rough_1:   string  "Vertex group to control roughness 1"
+ * ParticleSystem.vertex_group_roughness2 -> vertex_group_rough_2:   string  "Vertex group to control roughness 2"
+ * ParticleSystem.vertex_group_roughness_end -> vertex_group_rough_end:   string  "Vertex group to control roughness end"
+ * ParticleSystem.vertex_group_size -> vertex_group_size:   string  "Vertex group to control size"
+ * ParticleSystem.vertex_group_tangent -> vertex_group_tangent:   string  "Vertex group to control tangent"
+ * ParticleSystem.vertex_group_velocity -> vertex_group_velocity:   string  "Vertex group to control velocity"
+ * ParticleTarget.mode -> alliance:   enum  "NO DESCRIPTION"
+ * ParticleTarget.duration -> duration:   float  "NO DESCRIPTION"
+ * ParticleTarget.valid -> is_valid:   boolean  "Keyed particles target is valid"
+ * ParticleTarget.name -> name:   string,  "(read-only)    Particle target name"
+ * ParticleTarget.object -> object:   pointer  "The object that has the target particle system (empty if same object)"
+ * ParticleTarget.system -> system:   int  "The index of particle system on the target object"
+ * ParticleTarget.time -> time:   float  "NO DESCRIPTION"
+ * PointCache.active_point_cache_index -> active_point_cache_index:   int  "NO DESCRIPTION"
+ * PointCache.filepath -> filepath:   string  "Cache file path"
+ * PointCache.frame_end -> frame_end:   int  "Frame on which the simulation stops"
+ * PointCache.frame_start -> frame_start:   int  "Frame on which the simulation starts"
+ * PointCache.step -> frame_step:   int  "Number of frames between cached frames"
+ * PointCache.frames_skipped -> frames_skipped:   boolean,  "(read-only)"
+ * PointCache.index -> index:   int  "Index number of cache files"
+ * PointCache.info -> info:   string,  "(read-only)    Info on current cache status"
+ * PointCache.baked -> is_baked:   boolean,  "(read-only)"
+ * PointCache.baking -> is_baking:   boolean,  "(read-only)"
+ * PointCache.outdated -> is_outdated:   boolean,  "(read-only)"
+ * PointCache.name -> name:   string  "Cache name"
+ * PointCache.point_cache_list -> point_caches:   collection,  "(read-only)    Point cache list"
+ * PointCache.disk_cache -> use_disk_cache:   boolean  "Save cache files to disk (.blend file must be saved first)"
+ * PointCache.external -> use_external:   boolean  "Read cache from an external location"
+ * PointCache.use_library_path -> use_library_path:   boolean  "Use this files path when library linked into another file."
+ * PointCache.quick_cache -> use_quick_cache:   boolean  "Update simulation with cache steps"
+ * PointDensity.color_ramp -> color_ramp:   pointer,  "(read-only)"
+ * PointDensity.color_source -> color_source:   enum  "Data to derive color results from"
+ * PointDensity.falloff -> falloff:   enum  "Method of attenuating density by distance from the point"
+ * PointDensity.falloff_softness -> falloff_soft:   float  "Softness of the soft falloff option"
+ * PointDensity.noise_basis -> noise_basis:   enum  "Noise formula used for turbulence"
+ * PointDensity.object -> object:   pointer  "Object to take point data from"
+ * PointDensity.particle_cache -> particle_cache_coords:   enum  "Co-ordinate system to cache particles in"
+ * PointDensity.particle_system -> particle_system:   pointer  "Particle System to render as points"
+ * PointDensity.point_source -> point_source:   enum  "Point data to use as renderable point density"
+ * PointDensity.radius -> radius:   float  "Radius from the shaded sample to look for points within"
+ * PointDensity.speed_scale -> speed_scale:   float  "Multiplier to bring particle speed within an acceptable range"
+ * PointDensity.turbulence_depth -> turbulence_depth:   int  "Level of detail in the added turbulent noise"
+ * PointDensity.turbulence_influence -> turbulence_influence:   enum  "Method for driving added turbulent noise"
+ * PointDensity.turbulence_size -> turbulence_scale:   float  "Scale of the added turbulent noise"
+ * PointDensity.turbulence_strength -> turbulence_strength:   float  "NO DESCRIPTION"
+ * PointDensity.turbulence -> use_turbulence:   boolean  "Add directed noise to the density at render-time"
+ * PointDensity.vertices_cache -> vertex_cache_coords:   enum  "Co-ordinate system to cache vertices in"
+ * Pose.active_bone_group -> active_bone_group:   pointer  "Active bone group for this pose"
+ * Pose.active_bone_group_index -> active_bone_group_index:   int  "Active index in bone groups array"
+ * Pose.animation_visualisation -> animation_visualisation:   pointer,  "(read-only)    Animation data for this datablock"
+ * Pose.bone_groups -> bone_groups:   collection,  "(read-only)    Groups of the bones"
+ * Pose.bones -> bones:   collection,  "(read-only)    Individual pose bones for the armature"
+ * Pose.ik_param -> ik_param:   pointer,  "(read-only)    Parameters for IK solver"
+ * Pose.ik_solver -> ik_solver:   enum  "Selection of IK solver for IK chain, current choice is 0 for Legacy, 1 for iTaSC"
+ * PoseBone.bone -> bone:   pointer,  "(read-only)    Bone associated with this PoseBone"
+ * PoseBone.bone_group -> bone_group:   pointer  "Bone Group this pose channel belongs to"
+ * PoseBone.bone_group_index -> bone_group_index:   int  "Bone Group this pose channel belongs to (0=no group)"
+ * PoseBone.child -> child:   pointer,  "(read-only)    Child of this pose bone"
+ * PoseBone.constraints -> constraints:   collection,  "(read-only)    Constraints that act on this PoseChannel"
+ * PoseBone.custom_shape -> custom_shape:   pointer  "Object that defines custom draw type for this bone"
+ * PoseBone.custom_shape_transform -> custom_shape_transform:   pointer  "Bone that defines the display transform of this custom shape"
+ * PoseBone.head -> head:   float[3],  "(read-only)    Location of head of the channels bone"
+ * PoseBone.ik_lin_weight -> ik_linear_weight:   float  "Weight of scale constraint for IK"
+ * PoseBone.ik_max_x -> ik_max_x:   float  "Maximum angles for IK Limit"
+ * PoseBone.ik_max_y -> ik_max_y:   float  "Maximum angles for IK Limit"
+ * PoseBone.ik_max_z -> ik_max_z:   float  "Maximum angles for IK Limit"
+ * PoseBone.ik_min_x -> ik_min_x:   float  "Minimum angles for IK Limit"
+ * PoseBone.ik_min_y -> ik_min_y:   float  "Minimum angles for IK Limit"
+ * PoseBone.ik_min_z -> ik_min_z:   float  "Minimum angles for IK Limit"
+ * PoseBone.ik_rot_weight -> ik_rotation_weight:   float  "Weight of rotation constraint for IK"
+ * PoseBone.ik_stiffness_x -> ik_stiffness_x:   float  "IK stiffness around the X axis"
+ * PoseBone.ik_stiffness_y -> ik_stiffness_y:   float  "IK stiffness around the Y axis"
+ * PoseBone.ik_stiffness_z -> ik_stiffness_z:   float  "IK stiffness around the Z axis"
+ * PoseBone.ik_stretch -> ik_stretch:   float  "Allow scaling of the bone for IK"
+ * PoseBone.has_ik -> is_in_ik_chain:   boolean,  "(read-only)    Is part of an IK chain"
+ * PoseBone.location -> location:   float[3]  "NO DESCRIPTION"
+NEGATE * PoseBone.ik_dof_x -> lock_ik_x:   boolean  "Allow movement around the X axis"
+ * PoseBone.ik_limit_x -> lock_ik_x:   boolean  "Limit movement around the X axis"
+NEGATE * PoseBone.ik_dof_y -> lock_ik_y:   boolean  "Allow movement around the Y axis"
+ * PoseBone.ik_limit_y -> lock_ik_y:   boolean  "Limit movement around the Y axis"
+NEGATE * PoseBone.ik_dof_z -> lock_ik_z:   boolean  "Allow movement around the Z axis"
+ * PoseBone.ik_limit_z -> lock_ik_z:   boolean  "Limit movement around the Z axis"
+ * PoseBone.lock_location -> lock_location:   boolean[3]  "Lock editing of location in the interface"
+ * PoseBone.lock_rotation -> lock_rotation:   boolean[3]  "Lock editing of rotation in the interface"
+ * PoseBone.lock_rotation_w -> lock_rotation_w:   boolean  "Lock editing of angle component of four-component rotations in the interface"
+ * PoseBone.lock_rotations_4d -> lock_rotations_4d:   boolean  "Lock editing of four component rotations by components (instead of as Eulers)"
+ * PoseBone.lock_scale -> lock_scale:   boolean[3]  "Lock editing of scale in the interface"
+ * PoseBone.matrix -> matrix:   float[16],  "(read-only)    Final 4x4 matrix for this channel"
+ * PoseBone.matrix_channel -> matrix_channel:   float[16],  "(read-only)    4x4 matrix, before constraints"
+ * PoseBone.matrix_local -> matrix_local:   float[16]  "Matrix representing the parent relative location, scale and rotation. Provides an alternative access to these properties."
+ * PoseBone.motion_path -> motion_path:   pointer,  "(read-only)    Motion Path for this element"
+ * PoseBone.name -> name:   string  "NO DESCRIPTION"
+ * PoseBone.parent -> parent:   pointer,  "(read-only)    Parent of this pose bone"
+ * PoseBone.rotation_axis_angle -> rotation_axis_angle:   float[4]  "Angle of Rotation for Axis-Angle rotation representation"
+ * PoseBone.rotation_euler -> rotation_euler:   float[3]  "Rotation in Eulers"
+ * PoseBone.rotation_mode -> rotation_mode:   enum  "NO DESCRIPTION"
+ * PoseBone.rotation_quaternion -> rotation_quaternion:   float[4]  "Rotation in Quaternions"
+ * PoseBone.scale -> scale:   float[3]  "NO DESCRIPTION"
+ * PoseBone.select -> select:   boolean  "NO DESCRIPTION"
+ * PoseBone.tail -> tail:   float[3],  "(read-only)    Location of tail of the channels bone"
+ * PoseBone.ik_lin_control -> use_ik_linear_control:   boolean  "Apply channel size as IK constraint if stretching is enabled"
+ * PoseBone.ik_rot_control -> use_ik_rotation_control:   boolean  "Apply channel rotation as IK constraint"
+ * PoseBoneConstraints.active -> active:   pointer  "Active PoseChannel constraint"
+ * Property.description -> description:   string,  "(read-only)    Description of the property for tooltips"
+ * Property.identifier -> identifier:   string,  "(read-only)    Unique name used in the code and scripting"
+ * Property.is_never_none -> is_never_none:   boolean,  "(read-only)    True when this value cant be set to None"
+ * Property.use_output -> is_output:   boolean,  "(read-only)    True when this property is an output value from an RNA function"
+ * Property.is_readonly -> is_readonly:   boolean,  "(read-only)    Property is editable through RNA"
+ * Property.registered -> is_registered:   boolean,  "(read-only)    Property is registered as part of type registration"
+ * Property.registered_optional -> is_registered_optional:   boolean,  "(read-only)    Property is optionally registered as part of type registration"
+ * Property.is_required -> is_required:   boolean,  "(read-only)    False when this property is an optional argument in an RNA function"
+ * Property.name -> name:   string,  "(read-only)    Human readable name"
+ * Property.srna -> srna:   pointer,  "(read-only)    Struct definition used for properties assigned to this item"
+ * Property.subtype -> subtype:   enum,  "(read-only)    Semantic interpretation of the property"
+ * Property.type -> type:   enum,  "(read-only)    Data type of the property"
+ * Property.unit -> unit:   enum,  "(read-only)    Type of units for this property"
+ * Property|BooleanProperty.array_length -> array_length:   int,  "(read-only)    Maximum length of the array, 0 means unlimited"
+ * Property|BooleanProperty.default -> default:   boolean,  "(read-only)    Default value for this number"
+ * Property|BooleanProperty.default_array -> default_array:   boolean[3],  "(read-only)    Default value for this array"
+ * Property|CollectionProperty.fixed_type -> fixed_type:   pointer,  "(read-only)    Fixed pointer type, empty if variable type"
+ * Property|EnumProperty.default -> default:   enum,  "(read-only)    Default value for this enum"
+ * Property|EnumProperty.items -> items:   collection,  "(read-only)    Possible values for the property"
+ * Property|FloatProperty.array_length -> array_length:   int,  "(read-only)    Maximum length of the array, 0 means unlimited"
+ * Property|FloatProperty.default -> default:   float,  "(read-only)    Default value for this number"
+ * Property|FloatProperty.default_array -> default_array:   float[3],  "(read-only)    Default value for this array"
+ * Property|FloatProperty.hard_max -> hard_max:   float,  "(read-only)    Maximum value used by buttons"
+ * Property|FloatProperty.hard_min -> hard_min:   float,  "(read-only)    Minimum value used by buttons"
+ * Property|FloatProperty.precision -> precision:   int,  "(read-only)    Number of digits after the dot used by buttons"
+ * Property|FloatProperty.soft_max -> soft_max:   float,  "(read-only)    Maximum value used by buttons"
+ * Property|FloatProperty.soft_min -> soft_min:   float,  "(read-only)    Minimum value used by buttons"
+ * Property|FloatProperty.step -> step:   float,  "(read-only)    Step size used by number buttons, for floats 1/100th of the step size"
+ * Property|IntProperty.array_length -> array_length:   int,  "(read-only)    Maximum length of the array, 0 means unlimited"
+ * Property|IntProperty.default -> default:   int,  "(read-only)    Default value for this number"
+ * Property|IntProperty.default_array -> default_array:   int[3],  "(read-only)    Default value for this array"
+ * Property|IntProperty.hard_max -> hard_max:   int,  "(read-only)    Maximum value used by buttons"
+ * Property|IntProperty.hard_min -> hard_min:   int,  "(read-only)    Minimum value used by buttons"
+ * Property|IntProperty.soft_max -> soft_max:   int,  "(read-only)    Maximum value used by buttons"
+ * Property|IntProperty.soft_min -> soft_min:   int,  "(read-only)    Minimum value used by buttons"
+ * Property|IntProperty.step -> step:   int,  "(read-only)    Step size used by number buttons, for floats 1/100th of the step size"
+ * Property|PointerProperty.fixed_type -> fixed_type:   pointer,  "(read-only)    Fixed pointer type, empty if variable type"
+ * Property|StringProperty.default -> default:   string,  "(read-only)    string default value"
+ * Property|StringProperty.max_length -> length_max:   int,  "(read-only)    Maximum length of the string, 0 means unlimited"
+ * RGBANodeSocket.default_value -> default_value:   float[4]  "Default value of the socket when no link is attached"
+ * RGBANodeSocket.name -> name:   string,  "(read-only)    Socket name"
+ * Region.height -> height:   int,  "(read-only)    Region height"
+ * Region.id -> id:   int,  "(read-only)    Unique ID for this region"
+ * Region.type -> type:   enum,  "(read-only)    Type of this region"
+ * Region.width -> width:   int,  "(read-only)    Region width"
+ * RegionView3D.lock_rotation -> lock_rotation:   boolean  "Lock view rotation in side views"
+ * RegionView3D.perspective_matrix -> perspective_matrix:   float[16],  "(read-only)    Current perspective matrix of the 3D region"
+ * RegionView3D.box_preview -> show_sync_view:   boolean  "Sync view position between side views"
+ * RegionView3D.box_clip -> use_box_clip:   boolean  "Clip objects based on whats visible in other side views"
+ * RegionView3D.view_distance -> view_distance:   float  "Distance to the view location"
+ * RegionView3D.view_location -> view_location:   float[3]  "View pivot location"
+ * RegionView3D.view_matrix -> view_matrix:   float[16],  "(read-only)    Current view matrix of the 3D region"
+ * RegionView3D.view_perspective -> view_perspective:   enum  "View Perspective"
+ * RegionView3D.view_rotation -> view_rotation:   float[4]  "Rotation in quaternions (keep normalized)"
+ * RenderEngine.bl_idname -> bl_idname:   string  "NO DESCRIPTION"
+ * RenderEngine.bl_label -> bl_label:   string  "NO DESCRIPTION"
+ * RenderEngine.bl_postprocess -> bl_use_postprocess:   boolean  "NO DESCRIPTION"
+ * RenderEngine.bl_preview -> bl_use_preview:   boolean  "NO DESCRIPTION"
+ * RenderLayer.pass_ao_exclude -> exclude_ambient_occlusion:   boolean,  "(read-only)    Exclude AO pass from combined"
+ * RenderLayer.pass_emit_exclude -> exclude_emit:   boolean,  "(read-only)    Exclude emission pass from combined"
+ * RenderLayer.pass_environment_exclude -> exclude_environment:   boolean,  "(read-only)    Exclude environment pass from combined"
+ * RenderLayer.pass_indirect_exclude -> exclude_indirect:   boolean,  "(read-only)    Exclude indirect pass from combined"
+ * RenderLayer.pass_reflection_exclude -> exclude_reflection:   boolean,  "(read-only)    Exclude raytraced reflection pass from combined"
+ * RenderLayer.pass_refraction_exclude -> exclude_refraction:   boolean,  "(read-only)    Exclude raytraced refraction pass from combined"
+ * RenderLayer.pass_shadow_exclude -> exclude_shadow:   boolean,  "(read-only)    Exclude shadow pass from combined"
+ * RenderLayer.pass_specular_exclude -> exclude_specular:   boolean,  "(read-only)    Exclude specular pass from combined"
+ * RenderLayer.zmask_negate -> invert_zmask:   boolean,  "(read-only)    For Zmask, only render what is behind solid z values instead of in front"
+ * RenderLayer.visible_layers -> layers:   boolean[20],  "(read-only)    Scene layers included in this render layer"
+ * RenderLayer.zmask_layers -> layers_zmask:   boolean[20],  "(read-only)    Zmask scene layers"
+ * RenderLayer.light_override -> light_override:   pointer,  "(read-only)    Group to override all other lights in this render layer"
+ * RenderLayer.material_override -> material_override:   pointer,  "(read-only)    Material to override all other materials in this render layer"
+ * RenderLayer.name -> name:   string,  "(read-only)    Render layer name"
+ * RenderLayer.passes -> passes:   collection,  "(read-only)"
+ * RenderLayer.rect -> rect:   float  "NO DESCRIPTION"
+ * RenderLayer.enabled -> use:   boolean,  "(read-only)    Disable or enable the render layer"
+ * RenderLayer.all_z -> use_all_z:   boolean,  "(read-only)    Fill in Z values for solid faces in invisible layers, for masking"
+ * RenderLayer.edge -> use_edge_enhance:   boolean,  "(read-only)    Render Edge-enhance in this Layer (only works for Solid faces)"
+ * RenderLayer.halo -> use_halo:   boolean,  "(read-only)    Render Halos in this Layer (on top of Solid)"
+ * RenderLayer.pass_ao -> use_pass_ambient_occlusion:   boolean,  "(read-only)    Deliver AO pass"
+ * RenderLayer.pass_color -> use_pass_color:   boolean,  "(read-only)    Deliver shade-less color pass"
+ * RenderLayer.pass_combined -> use_pass_combined:   boolean,  "(read-only)    Deliver full combined RGBA buffer"
+ * RenderLayer.pass_diffuse -> use_pass_diffuse:   boolean,  "(read-only)    Deliver diffuse pass"
+ * RenderLayer.pass_emit -> use_pass_emit:   boolean,  "(read-only)    Deliver emission pass"
+ * RenderLayer.pass_environment -> use_pass_environment:   boolean,  "(read-only)    Deliver environment lighting pass"
+ * RenderLayer.pass_indirect -> use_pass_indirect:   boolean,  "(read-only)    Deliver indirect lighting pass"
+ * RenderLayer.pass_mist -> use_pass_mist:   boolean,  "(read-only)    Deliver mist factor pass (0.0-1.0)"
+ * RenderLayer.pass_normal -> use_pass_normal:   boolean,  "(read-only)    Deliver normal pass"
+ * RenderLayer.pass_object_index -> use_pass_object_index:   boolean,  "(read-only)    Deliver object index pass"
+ * RenderLayer.pass_reflection -> use_pass_reflection:   boolean,  "(read-only)    Deliver raytraced reflection pass"
+ * RenderLayer.pass_refraction -> use_pass_refraction:   boolean,  "(read-only)    Deliver raytraced refraction pass"
+ * RenderLayer.pass_shadow -> use_pass_shadow:   boolean,  "(read-only)    Deliver shadow pass"
+ * RenderLayer.pass_specular -> use_pass_specular:   boolean,  "(read-only)    Deliver specular pass"
+ * RenderLayer.pass_uv -> use_pass_uv:   boolean,  "(read-only)    Deliver texture UV pass"
+ * RenderLayer.pass_vector -> use_pass_vector:   boolean,  "(read-only)    Deliver speed vector pass"
+ * RenderLayer.pass_z -> use_pass_z:   boolean,  "(read-only)    Deliver Z values pass"
+ * RenderLayer.sky -> use_sky:   boolean,  "(read-only)    Render Sky in this Layer"
+ * RenderLayer.solid -> use_solid:   boolean,  "(read-only)    Render Solid faces in this Layer"
+ * RenderLayer.strand -> use_strand:   boolean,  "(read-only)    Render Strands in this Layer"
+ * RenderLayer.zmask -> use_zmask:   boolean,  "(read-only)    Only render whats in front of the solid z values"
+ * RenderLayer.ztransp -> use_ztransp:   boolean,  "(read-only)    Render Z-Transparent faces in this Layer (On top of Solid and Halos)"
+ * RenderPass.channel_id -> channel_id:   string,  "(read-only)"
+ * RenderPass.channels -> channels:   int,  "(read-only)"
+ * RenderPass.name -> name:   string,  "(read-only)"
+ * RenderPass.rect -> rect:   float  "NO DESCRIPTION"
+ * RenderPass.type -> type:   enum,  "(read-only)"
+ * RenderResult.layers -> layers:   collection,  "(read-only)"
+ * RenderResult.resolution_x -> resolution_x:   int,  "(read-only)"
+ * RenderResult.resolution_y -> resolution_y:   int,  "(read-only)"
+ * RenderSettings.active_layer_index -> active_layer_index:   int  "Active index in render layer array"
+ * RenderSettings.alpha_mode -> alpha_mode:   enum  "Representation of alpha information in the RGBA pixels"
+ * RenderSettings.antialiasing_samples -> antialiasing_samples:   enum  "Amount of anti-aliasing samples per pixel"
+ * RenderSettings.bake_aa_mode -> bake_aa_mode:   enum  "NO DESCRIPTION"
+ * RenderSettings.bake_bias -> bake_bias:   float  "Bias towards faces further away from the object (in blender units)"
+ * RenderSettings.bake_distance -> bake_distance:   float  "Maximum distance from active object to other object (in blender units"
+ * RenderSettings.bake_margin -> bake_margin:   int  "Amount of pixels to extend the baked result with, as post process filter"
+ * RenderSettings.bake_normal_space -> bake_normal_space:   enum  "Choose normal space for baking"
+ * RenderSettings.bake_quad_split -> bake_quad_split:   enum  "Choose the method used to split a quad into 2 triangles for baking"
+ * RenderSettings.bake_type -> bake_type:   enum  "Choose shading information to bake into the image"
+ * RenderSettings.border_max_x -> border_max_x:   float  "Sets maximum X value for the render border"
+ * RenderSettings.border_max_y -> border_max_y:   float  "Sets maximum Y value for the render border"
+ * RenderSettings.border_min_x -> border_min_x:   float  "Sets minimum X value to for the render border"
+ * RenderSettings.border_min_y -> border_min_y:   float  "Sets minimum Y value for the render border"
+ * RenderSettings.cineon_black -> cineon_black:   int  "Log conversion reference blackpoint"
+ * RenderSettings.cineon_gamma -> cineon_gamma:   float  "Log conversion gamma"
+ * RenderSettings.cineon_white -> cineon_white:   int  "Log conversion reference whitepoint"
+ * RenderSettings.color_mode -> color_mode:   enum  "Choose BW for saving greyscale images, RGB for saving red, green and blue channels, AND RGBA for saving red, green, blue + alpha channels"
+ * RenderSettings.display_mode -> display_mode:   enum  "Select where rendered images will be displayed"
+ * RenderSettings.dither_intensity -> dither_intensity:   float  "Amount of dithering noise added to the rendered image to break up banding"
+ * RenderSettings.edge_color -> edge_color:   float[3]  "NO DESCRIPTION"
+ * RenderSettings.edge_threshold -> edge_threshold:   int  "Threshold for drawing outlines on geometry edges"
+ * RenderSettings.engine -> engine:   enum  "Engine to use for rendering"
+ * RenderSettings.field_order -> field_order:   enum  "Order of video fields. Select which lines get rendered first, to create smooth motion for TV output"
+ * RenderSettings.file_extension -> file_extension:   string,  "(read-only)    The file extension used for saving renders"
+ * RenderSettings.file_format -> file_format:   enum  "File format to save the rendered images as"
+ * RenderSettings.file_quality -> file_quality:   int  "Quality of JPEG images, AVI Jpeg and SGI movies, Compression for PNGs"
+ * RenderSettings.output_path -> filepath:   string  "Directory/name to save animations, # characters defines the position and length of frame numbers"
+ * RenderSettings.filter_size -> filter_size:   float  "Pixel width over which the reconstruction filter combines samples"
+ * RenderSettings.fps -> fps:   int  "Framerate, expressed in frames per second"
+ * RenderSettings.fps_base -> fps_base:   float  "Framerate base"
+ * RenderSettings.multiple_engines -> has_multiple_engines:   boolean,  "(read-only)    More than one rendering engine is available"
+ * RenderSettings.is_movie_format -> is_movie_format:   boolean,  "(read-only)    When true the format is a movie"
+ * RenderSettings.layers -> layers:   collection,  "(read-only)"
+ * RenderSettings.motion_blur_samples -> motion_blur_samples:   int  "Number of scene samples to take with motion blur"
+ * RenderSettings.motion_blur_shutter -> motion_blur_shutter:   float  "Time taken in frames between shutter open and close"
+ * RenderSettings.octree_resolution -> octree_resolution:   enum  "Resolution of raytrace accelerator. Use higher resolutions for larger scenes"
+ * RenderSettings.parts_x -> parts_x:   int  "Number of horizontal tiles to use while rendering"
+ * RenderSettings.parts_y -> parts_y:   int  "Number of vertical tiles to use while rendering"
+ * RenderSettings.pixel_aspect_x -> pixel_aspect_x:   float  "Horizontal aspect ratio - for anamorphic or non-square pixel output"
+ * RenderSettings.pixel_aspect_y -> pixel_aspect_y:   float  "Vertical aspect ratio - for anamorphic or non-square pixel output"
+ * RenderSettings.pixel_filter -> pixel_filter_type:   enum  "Reconstruction filter used for combining anti-aliasing samples"
+ * RenderSettings.raytrace_structure -> raytrace_method:   enum  "Type of raytrace accelerator structure"
+ * RenderSettings.resolution_percentage -> resolution_percentage:   int  "Percentage scale for render resolution"
+ * RenderSettings.resolution_x -> resolution_x:   int  "Number of horizontal pixels in the rendered image"
+ * RenderSettings.resolution_y -> resolution_y:   int  "Number of vertical pixels in the rendered image"
+ * RenderSettings.sequencer_gl_preview -> sequencer_gl_preview:   enum  "Method to draw in the sequencer view"
+ * RenderSettings.sequencer_gl_render -> sequencer_gl_render:   enum  "Method to draw in the sequencer view"
+ * RenderSettings.simplify_ao_sss -> simplify_ao_sss:   float  "Global approximate AA and SSS quality factor"
+ * RenderSettings.simplify_child_particles -> simplify_child_particles:   float  "Global child particles percentage"
+ * RenderSettings.simplify_shadow_samples -> simplify_shadow_samples:   int  "Global maximum shadow samples"
+ * RenderSettings.simplify_subdivision -> simplify_subdivision:   int  "Global maximum subdivision level"
+ * RenderSettings.stamp_background -> stamp_background:   float[4]  "Color to use behind stamp text"
+ * RenderSettings.stamp_font_size -> stamp_font_size:   int  "Size of the font used when rendering stamp text"
+ * RenderSettings.stamp_foreground -> stamp_foreground:   float[4]  "Color to use for stamp text"
+ * RenderSettings.stamp_note_text -> stamp_note_text:   string  "Custom text to appear in the stamp note"
+ * RenderSettings.threads -> threads:   int  "Number of CPU threads to use simultaneously while rendering (for multi-core/CPU systems)"
+ * RenderSettings.threads_mode -> threads_mode:   enum  "Determine the amount of render threads used"
+ * RenderSettings.render_antialiasing -> use_antialiasing:   boolean  "Render and combine multiple samples per pixel to prevent jagged edges"
+ * RenderSettings.backbuf -> use_backbuf:   boolean  "Render backbuffer image"
+ * RenderSettings.bake_active -> use_bake_active_to_selected:   boolean  "Bake shading on the surface of selected objects to the active object"
+ * RenderSettings.bake_enable_aa -> use_bake_antialiasing:   boolean  "Enables Anti-aliasing"
+ * RenderSettings.bake_clear -> use_bake_clear:   boolean  "Clear Images before baking"
+ * RenderSettings.bake_normalized -> use_bake_normalize:   boolean  "With displacement normalize to the distance, with ambient occlusion normalize without using material settings"
+ * RenderSettings.use_border -> use_border:   boolean  "Render a user-defined border region, within the frame size. Note, this disables save_buffers and full_sample"
+ * RenderSettings.cineon_log -> use_cineon_log:   boolean  "Convert to logarithmic color space"
+ * RenderSettings.color_management -> use_color_management:   boolean  "Use linear workflow - gamma corrected imaging pipeline"
+ * RenderSettings.use_compositing -> use_compositing:   boolean  "Process the render result through the compositing pipeline, if compositing nodes are enabled"
+ * RenderSettings.crop_to_border -> use_crop_to_border:   boolean  "Crop the rendered frame to the defined border size"
+ * RenderSettings.edge -> use_edge_enhance:   boolean  "Create a toon outline around the edges of geometry"
+ * RenderSettings.use_envmaps -> use_envmaps:   boolean  "Calculate environment maps while rendering"
+ * RenderSettings.fields -> use_fields:   boolean  "Render image to two fields per frame, for interlaced TV output"
+ * RenderSettings.fields_still -> use_fields_still:   boolean  "Disable the time difference between fields"
+ * RenderSettings.use_file_extension -> use_file_extension:   boolean  "Add the file format extensions to the rendered file name (eg: filename + .jpg)"
+ * RenderSettings.free_image_textures -> use_free_image_textures:   boolean  "Free all image texture from memory after render, to save memory before compositing"
+ * RenderSettings.free_unused_nodes -> use_free_unused_nodes:   boolean  "Free Nodes that are not used while compositing, to save memory"
+ * RenderSettings.full_sample -> use_full_sample:   boolean  "Save for every anti-aliasing sample the entire RenderLayer results. This solves anti-aliasing issues with compositing"
+ * RenderSettings.use_game_engine -> use_game_engine:   boolean,  "(read-only)    Current rendering engine is a game engine"
+ * RenderSettings.use_instances -> use_instances:   boolean  "Instance support leads to effective memory reduction when using duplicates"
+ * RenderSettings.use_local_coords -> use_local_coords:   boolean  "Vertex coordinates are stored localy on each primitive. Increases memory usage, but may have impact on speed"
+ * RenderSettings.motion_blur -> use_motion_blur:   boolean  "Use multi-sampled 3D scene motion blur"
+ * RenderSettings.use_overwrite -> use_overwrite:   boolean  "Overwrite existing files while rendering"
+ * RenderSettings.use_placeholder -> use_placeholder:   boolean  "Create empty placeholder files while rendering frames (similar to Unix touch)"
+ * RenderSettings.use_radiosity -> use_radiosity:   boolean  "Calculate radiosity in a pre-process before rendering"
+ * RenderSettings.use_raytracing -> use_raytrace:   boolean  "Pre-calculate the raytrace accelerator and render raytracing effects"
+ * RenderSettings.save_buffers -> use_save_buffers:   boolean  "Save tiles for all RenderLayers and SceneNodes to files in the temp directory (saves memory, required for Full Sample)"
+ * RenderSettings.use_sequencer -> use_sequencer:   boolean  "Process the render (and composited) result through the video sequence editor pipeline, if sequencer strips exist"
+ * RenderSettings.use_sequencer_gl_preview -> use_sequencer_gl_preview:   boolean  "NO DESCRIPTION"
+ * RenderSettings.use_sequencer_gl_render -> use_sequencer_gl_render:   boolean  "NO DESCRIPTION"
+ * RenderSettings.use_shadows -> use_shadows:   boolean  "Calculate shadows while rendering"
+ * RenderSettings.use_simplify -> use_simplify:   boolean  "Enable simplification of scene for quicker preview renders"
+ * RenderSettings.simplify_triangulate -> use_simplify_triangulate:   boolean  "Disables non-planer quads being triangulated"
+ * RenderSettings.single_layer -> use_single_layer:   boolean  "Only render the active layer"
+ * RenderSettings.use_sss -> use_sss:   boolean  "Calculate sub-surface scattering in materials rendering"
+ * RenderSettings.render_stamp -> use_stamp:   boolean  "Render the stamp info text in the rendered image"
+ * RenderSettings.stamp_camera -> use_stamp_camera:   boolean  "Include the name of the active camera in image metadata"
+ * RenderSettings.stamp_date -> use_stamp_date:   boolean  "Include the current date in image metadata"
+ * RenderSettings.stamp_filename -> use_stamp_filename:   boolean  "Include the filename of the .blend file in image metadata"
+ * RenderSettings.stamp_frame -> use_stamp_frame:   boolean  "Include the frame number in image metadata"
+ * RenderSettings.stamp_marker -> use_stamp_marker:   boolean  "Include the name of the last marker in image metadata"
+ * RenderSettings.stamp_note -> use_stamp_note:   boolean  "Include a custom note in image metadata"
+ * RenderSettings.stamp_render_time -> use_stamp_render_time:   boolean  "Include the render time in the stamp image"
+ * RenderSettings.stamp_scene -> use_stamp_scene:   boolean  "Include the name of the active scene in image metadata"
+ * RenderSettings.stamp_sequencer_strip -> use_stamp_sequencer_strip:   boolean  "Include the name of the foreground sequence strip in image metadata"
+ * RenderSettings.stamp_time -> use_stamp_time:   boolean  "Include the render frame as HH:MM:SS.FF in image metadata"
+ * RenderSettings.use_textures -> use_textures:   boolean  "Use textures to affect material properties"
+ * RenderSettings.tiff_bit -> use_tiff_16bit:   boolean  "Save TIFF with 16 bits per channel"
+ * SPHFluidSettings.buoyancy -> buoyancy:   float  "NO DESCRIPTION"
+ * SPHFluidSettings.fluid_radius -> fluid_radius:   float  "Fluid interaction Radius"
+ * SPHFluidSettings.rest_density -> rest_density:   float  "Density"
+ * SPHFluidSettings.rest_length -> rest_length:   float  "The Spring Rest Length (factor of interaction radius)"
+ * SPHFluidSettings.spring_k -> spring_force:   float  "Spring force constant"
+ * SPHFluidSettings.stiffness_k -> stiffness:   float  "Constant K - Stiffness"
+ * SPHFluidSettings.stiffness_knear -> stiffness_near:   float  "Repulsion factor: stiffness_knear"
+ * SPHFluidSettings.viscosity_beta -> viscosity_beta:   float  "Square viscosity factor"
+ * SPHFluidSettings.viscosity_omega -> viscosity_omega:   float  "Linear viscosity"
+ * SceneBases.active -> active:   pointer  "Active object base in the scene"
+ * SceneGameData.activity_culling_box_radius -> activity_culling_box_radius:   float  "Radius of the activity bubble, in Manhattan length. Objects outside the box are activity-culled"
+ * SceneGameData.depth -> depth:   int  "Displays bit depth of full screen display"
+ * SceneGameData.dome_angle -> dome_angle:   int  "Field of View of the Dome - it only works in mode Fisheye and Truncated"
+ * SceneGameData.dome_buffer_resolution -> dome_buffer_resolution:   float  "Buffer Resolution - decrease it to increase speed"
+ * SceneGameData.dome_mode -> dome_mode:   enum  "Dome physical configurations"
+ * SceneGameData.dome_tesselation -> dome_tesselation:   int  "Tessellation level - check the generated mesh in wireframe mode"
+ * SceneGameData.dome_text -> dome_text:   pointer  "Custom Warp Mesh data file"
+ * SceneGameData.dome_tilt -> dome_tilt:   int  "Camera rotation in horizontal axis"
+ * SceneGameData.fps -> fps:   int  "The nominal number of game frames per second. Physics fixed timestep = 1/fps, independently of actual frame rate"
+ * SceneGameData.framing_color -> frame_color:   float[3]  "Set colour of the bars"
+ * SceneGameData.framing_type -> frame_type:   enum  "Select the type of Framing you want"
+ * SceneGameData.frequency -> frequency:   int  "Displays clock frequency of fullscreen display"
+ * SceneGameData.logic_step_max -> logic_step_max:   int  "Sets the maximum number of logic frame per game frame if graphics slows down the game, higher value allows better synchronization with physics"
+ * SceneGameData.material_mode -> material_mode:   enum  "Material mode to use for rendering"
+ * SceneGameData.occlusion_culling_resolution -> occlusion_culling_resolution:   float  "The size of the occlusion buffer in pixel, use higher value for better precision (slower)"
+ * SceneGameData.physics_engine -> physics_engine:   enum  "Physics engine used for physics simulation in the game engine"
+ * SceneGameData.physics_gravity -> physics_gravity:   float  "Gravitational constant used for physics simulation in the game engine"
+ * SceneGameData.physics_step_max -> physics_step_max:   int  "Sets the maximum number of physics step per game frame if graphics slows down the game, higher value allows physics to keep up with realtime"
+ * SceneGameData.physics_step_sub -> physics_step_sub:   int  "Sets the number of simulation substep per physic timestep, higher value give better physics precision"
+ * SceneGameData.resolution_x -> resolution_x:   int  "Number of horizontal pixels in the screen"
+ * SceneGameData.resolution_y -> resolution_y:   int  "Number of vertical pixels in the screen"
+ * SceneGameData.show_debug_properties -> show_debug_properties:   boolean  "Show properties marked for debugging while the game runs"
+ * SceneGameData.show_framerate_profile -> show_framerate_profile:   boolean  "Show framerate and profiling information while the game runs"
+ * SceneGameData.fullscreen -> show_fullscreen:   boolean  "Starts player in a new fullscreen display"
+ * SceneGameData.show_physics_visualization -> show_physics_visualization:   boolean  "Show a visualization of physics bounds and interactions"
+ * SceneGameData.stereo -> stereo:   enum  "NO DESCRIPTION"
+ * SceneGameData.eye_separation -> stereo_eye_separation:   float  "Set the distance between the eyes - the camera focal length/30 should be fine"
+ * SceneGameData.stereo_mode -> stereo_mode:   enum  "Stereographic techniques"
+ * SceneGameData.activity_culling -> use_activity_culling:   boolean  "Activity culling is enabled"
+ * SceneGameData.use_animation_record -> use_animation_record:   boolean  "Record animation to fcurves"
+ * SceneGameData.auto_start -> use_auto_start:   boolean  "Automatically start game at load time"
+ * SceneGameData.use_deprecation_warnings -> use_deprecation_warnings:   boolean  "Print warnings when using deprecated features in the python API"
+ * SceneGameData.use_display_lists -> use_display_lists:   boolean  "Use display lists to speed up rendering by keeping geometry on the GPU"
+ * SceneGameData.use_frame_rate -> use_frame_rate:   boolean  "Respect the frame rate rather than rendering as many frames as possible"
+ * SceneGameData.glsl_extra_textures -> use_glsl_extra_textures:   boolean  "Use extra textures like normal or specular maps for GLSL rendering"
+ * SceneGameData.glsl_lights -> use_glsl_lights:   boolean  "Use lights for GLSL rendering"
+ * SceneGameData.glsl_nodes -> use_glsl_nodes:   boolean  "Use nodes for GLSL rendering"
+ * SceneGameData.glsl_ramps -> use_glsl_ramps:   boolean  "Use ramps for GLSL rendering"
+ * SceneGameData.glsl_shaders -> use_glsl_shaders:   boolean  "Use shaders for GLSL rendering"
+ * SceneGameData.glsl_shadows -> use_glsl_shadows:   boolean  "Use shadows for GLSL rendering"
+ * SceneGameData.use_occlusion_culling -> use_occlusion_culling:   boolean  "Use optimized Bullet DBVT tree for view frustum and occlusion culling"
+ * SceneObjects.active -> active:   pointer  "Active object for this scene"
+ * SceneRenderLayer.pass_ao_exclude -> exclude_ambient_occlusion:   boolean  "Exclude AO pass from combined"
+ * SceneRenderLayer.pass_emit_exclude -> exclude_emit:   boolean  "Exclude emission pass from combined"
+ * SceneRenderLayer.pass_environment_exclude -> exclude_environment:   boolean  "Exclude environment pass from combined"
+ * SceneRenderLayer.pass_indirect_exclude -> exclude_indirect:   boolean  "Exclude indirect pass from combined"
+ * SceneRenderLayer.pass_reflection_exclude -> exclude_reflection:   boolean  "Exclude raytraced reflection pass from combined"
+ * SceneRenderLayer.pass_refraction_exclude -> exclude_refraction:   boolean  "Exclude raytraced refraction pass from combined"
+ * SceneRenderLayer.pass_shadow_exclude -> exclude_shadow:   boolean  "Exclude shadow pass from combined"
+ * SceneRenderLayer.pass_specular_exclude -> exclude_specular:   boolean  "Exclude specular pass from combined"
+ * SceneRenderLayer.zmask_negate -> invert_zmask:   boolean  "For Zmask, only render what is behind solid z values instead of in front"
+ * SceneRenderLayer.visible_layers -> layers:   boolean[20]  "Scene layers included in this render layer"
+ * SceneRenderLayer.zmask_layers -> layers_zmask:   boolean[20]  "Zmask scene layers"
+ * SceneRenderLayer.light_override -> light_override:   pointer  "Group to override all other lights in this render layer"
+ * SceneRenderLayer.material_override -> material_override:   pointer  "Material to override all other materials in this render layer"
+ * SceneRenderLayer.name -> name:   string  "Render layer name"
+ * SceneRenderLayer.enabled -> use:   boolean  "Disable or enable the render layer"
+ * SceneRenderLayer.all_z -> use_all_z:   boolean  "Fill in Z values for solid faces in invisible layers, for masking"
+ * SceneRenderLayer.edge -> use_edge_enhance:   boolean  "Render Edge-enhance in this Layer (only works for Solid faces)"
+ * SceneRenderLayer.halo -> use_halo:   boolean  "Render Halos in this Layer (on top of Solid)"
+ * SceneRenderLayer.pass_ao -> use_pass_ambient_occlusion:   boolean  "Deliver AO pass"
+ * SceneRenderLayer.pass_color -> use_pass_color:   boolean  "Deliver shade-less color pass"
+ * SceneRenderLayer.pass_combined -> use_pass_combined:   boolean  "Deliver full combined RGBA buffer"
+ * SceneRenderLayer.pass_diffuse -> use_pass_diffuse:   boolean  "Deliver diffuse pass"
+ * SceneRenderLayer.pass_emit -> use_pass_emit:   boolean  "Deliver emission pass"
+ * SceneRenderLayer.pass_environment -> use_pass_environment:   boolean  "Deliver environment lighting pass"
+ * SceneRenderLayer.pass_indirect -> use_pass_indirect:   boolean  "Deliver indirect lighting pass"
+ * SceneRenderLayer.pass_mist -> use_pass_mist:   boolean  "Deliver mist factor pass (0.0-1.0)"
+ * SceneRenderLayer.pass_normal -> use_pass_normal:   boolean  "Deliver normal pass"
+ * SceneRenderLayer.pass_object_index -> use_pass_object_index:   boolean  "Deliver object index pass"
+ * SceneRenderLayer.pass_reflection -> use_pass_reflection:   boolean  "Deliver raytraced reflection pass"
+ * SceneRenderLayer.pass_refraction -> use_pass_refraction:   boolean  "Deliver raytraced refraction pass"
+ * SceneRenderLayer.pass_shadow -> use_pass_shadow:   boolean  "Deliver shadow pass"
+ * SceneRenderLayer.pass_specular -> use_pass_specular:   boolean  "Deliver specular pass"
+ * SceneRenderLayer.pass_uv -> use_pass_uv:   boolean  "Deliver texture UV pass"
+ * SceneRenderLayer.pass_vector -> use_pass_vector:   boolean  "Deliver speed vector pass"
+ * SceneRenderLayer.pass_z -> use_pass_z:   boolean  "Deliver Z values pass"
+ * SceneRenderLayer.sky -> use_sky:   boolean  "Render Sky in this Layer"
+ * SceneRenderLayer.solid -> use_solid:   boolean  "Render Solid faces in this Layer"
+ * SceneRenderLayer.strand -> use_strand:   boolean  "Render Strands in this Layer"
+ * SceneRenderLayer.zmask -> use_zmask:   boolean  "Only render whats in front of the solid z values"
+ * SceneRenderLayer.ztransp -> use_ztransp:   boolean  "Render Z-Transparent faces in this Layer (On top of Solid and Halos)"
+ * Scopes.accuracy -> accuracy:   float  "Proportion of original image source pixel lines to sample"
+ * Scopes.histogram -> histogram:   pointer,  "(read-only)    Histogram for viewing image statistics"
+ * Scopes.use_full_resolution -> use_full_resolution:   boolean  "Sample every pixel of the image"
+ * Scopes.vectorscope_alpha -> vectorscope_alpha:   float  "Opacity of the points"
+ * Scopes.waveform_alpha -> waveform_alpha:   float  "Opacity of the points"
+ * Scopes.waveform_mode -> waveform_mode:   enum  "NO DESCRIPTION"
+ * Sensor.frequency -> frequency:   int  "Delay between repeated pulses(in logic tics, 0=no delay)"
+ * Sensor.invert -> invert:   boolean  "Invert the level(output) of this sensor"
+ * Sensor.name -> name:   string  "Sensor name"
+ * Sensor.pinned -> pin:   boolean  "Display when not linked to a visible states controller"
+ * Sensor.expanded -> show_expanded:   boolean  "Set sensor expanded in the user interface"
+ * Sensor.type -> type:   enum  "NO DESCRIPTION"
+ * Sensor.level -> use_level:   boolean  "Level detector, trigger controllers of new states(only applicable upon logic state transition)"
+ * Sensor.pulse_false_level -> use_pulse_false_level:   boolean  "Activate FALSE level triggering (pulse mode)"
+ * Sensor.pulse_true_level -> use_pulse_true_level:   boolean  "Activate TRUE level triggering (pulse mode)"
+ * Sensor.tap -> use_tap:   boolean  "Trigger controllers only for an instant, even while the sensor remains true"
+ * Sensor|ActuatorSensor.actuator -> actuator:   string  "Actuator name, actuator active state modifications will be detected"
+ * Sensor|ArmatureSensor.bone -> bone:   string  "Identify the bone to check value from"
+ * Sensor|ArmatureSensor.constraint -> constraint:   string  "Identify the bone constraint to check value from"
+ * Sensor|ArmatureSensor.test_type -> test_type:   enum  "Type of value and test"
+ * Sensor|ArmatureSensor.value -> value:   float  "Specify value to be used in comparison"
+ * Sensor|CollisionSensor.material -> material:   string  "Only look for Objects with this material"
+ * Sensor|CollisionSensor.property -> property:   string  "Only look for Objects with this property"
+ * Sensor|CollisionSensor.collision_type -> use_material:   boolean  "Toggle collision on material or property"
+ * Sensor|CollisionSensor.pulse -> use_pulse:   boolean  "Changes to the set of colliding objects generates pulse"
+ * Sensor|DelaySensor.delay -> delay:   int  "Delay in number of logic tics before the positive trigger (default 60 per second)"
+ * Sensor|DelaySensor.duration -> duration:   int  "If >0, delay in number of logic tics before the negative trigger following the positive trigger"
+ * Sensor|DelaySensor.repeat -> use_repeat:   boolean  "Toggle repeat option. If selected, the sensor restarts after Delay+Dur logic tics"
+ * Sensor|JoystickSensor.axis_direction -> axis_direction:   enum  "The direction of the axis"
+ * Sensor|JoystickSensor.axis_number -> axis_number:   int  "Specify which axis pair to use, 1 is usually the main direction input"
+ * Sensor|JoystickSensor.axis_threshold -> axis_threshold:   int  "Specify the precision of the axis"
+ * Sensor|JoystickSensor.button_number -> button_number:   int  "Specify which button to use"
+ * Sensor|JoystickSensor.event_type -> event_type:   enum  "The type of event this joystick sensor is triggered on"
+ * Sensor|JoystickSensor.hat_direction -> hat_direction:   enum  "Specify hat direction"
+ * Sensor|JoystickSensor.hat_number -> hat_number:   int  "Specify which hat to use"
+ * Sensor|JoystickSensor.joystick_index -> joystick_index:   int  "Specify which joystick to use"
+ * Sensor|JoystickSensor.single_axis_number -> single_axis_number:   int  "Specify a single axis (verticle/horizontal/other) to detect"
+ * Sensor|JoystickSensor.all_events -> use_all_events:   boolean  "Triggered by all events on this joysticks current type (axis/button/hat)"
+ * Sensor|KeyboardSensor.key -> key:   enum  "NO DESCRIPTION"
+ * Sensor|KeyboardSensor.log -> log:   string  "Property that receive the keystrokes in case a string is logged"
+ * Sensor|KeyboardSensor.modifier_key -> modifier_key_1:   enum  "Modifier key code"
+ * Sensor|KeyboardSensor.second_modifier_key -> modifier_key_2:   enum  "Modifier key code"
+ * Sensor|KeyboardSensor.target -> target:   string  "Property that indicates whether to log keystrokes as a string"
+ * Sensor|KeyboardSensor.all_keys -> use_all_keys:   boolean  "Trigger this sensor on any keystroke"
+ * Sensor|MessageSensor.subject -> subject:   string  "Optional subject filter: only accept messages with this subject, or empty for all"
+ * Sensor|MouseSensor.mouse_event -> mouse_event:   enum  "Specify the type of event this mouse sensor should trigger on"
+ * Sensor|NearSensor.distance -> distance:   float  "Trigger distance"
+ * Sensor|NearSensor.property -> property:   string  "Only look for objects with this property"
+ * Sensor|NearSensor.reset_distance -> reset_distance:   float  "NO DESCRIPTION"
+ * Sensor|PropertySensor.evaluation_type -> evaluation_type:   enum  "Type of property evaluation"
+ * Sensor|PropertySensor.property -> property:   string  "NO DESCRIPTION"
+ * Sensor|PropertySensor.value -> value:   string  "Check for this value in types in Equal or Not Equal types"
+ * Sensor|PropertySensor.max_value -> value_max:   string  "Specify maximum value in Interval type"
+ * Sensor|PropertySensor.min_value -> value_min:   string  "Specify minimum value in Interval type"
+ * Sensor|RadarSensor.angle -> angle:   float  "Opening angle of the radar cone"
+ * Sensor|RadarSensor.axis -> axis:   enum  "Specify along which axis the radar cone is cast"
+ * Sensor|RadarSensor.distance -> distance:   float  "Depth of the radar cone"
+ * Sensor|RadarSensor.property -> property:   string  "Only look for Objects with this property"
+ * Sensor|RandomSensor.seed -> seed:   int  "Initial seed of the generator. (Choose 0 for not random)"
+ * Sensor|RaySensor.axis -> axis:   enum  "Specify along which axis the ray is cast"
+ * Sensor|RaySensor.material -> material:   string  "Only look for Objects with this material"
+ * Sensor|RaySensor.property -> property:   string  "Only look for Objects with this property"
+ * Sensor|RaySensor.range -> range:   float  "Sense objects no farther than this distance"
+ * Sensor|RaySensor.ray_type -> ray_type:   enum  "Toggle collision on material or property"
+ * Sensor|RaySensor.x_ray_mode -> use_x_ray:   boolean  "Toggle X-Ray option (see through objects that dont have the property)"
+ * Sensor|TouchSensor.material -> material:   pointer  "Only look for objects with this material"
+ * Sequence.blend_opacity -> blend_alpha:   float  "NO DESCRIPTION"
+ * Sequence.blend_mode -> blend_type:   enum  "NO DESCRIPTION"
+ * Sequence.channel -> channel:   int  "Y position of the sequence strip"
+ * Sequence.effect_fader -> effect_fader:   float  "NO DESCRIPTION"
+ * Sequence.frame_length -> frame_duration:   int,  "(read-only)    The length of the contents of this strip before the handles are applied"
+ * Sequence.frame_final_length -> frame_final_duration:   int  "The length of the contents of this strip before the handles are applied"
+ * Sequence.frame_final_end -> frame_final_end:   int  "End frame displayed in the sequence editor after offsets are applied"
+ * Sequence.frame_final_start -> frame_final_start:   int  "Start frame displayed in the sequence editor after offsets are applied, setting this is equivalent to moving the handle, not the actual start frame"
+ * Sequence.frame_offset_end -> frame_offset_end:   int,  "(read-only)"
+ * Sequence.frame_offset_start -> frame_offset_start:   int,  "(read-only)"
+ * Sequence.frame_start -> frame_start:   int  "NO DESCRIPTION"
+ * Sequence.frame_still_end -> frame_still_end:   int,  "(read-only)"
+ * Sequence.frame_still_start -> frame_still_start:   int,  "(read-only)"
+ * Sequence.lock -> lock:   boolean  "Lock strip so that it cant be transformed"
+ * Sequence.mute -> mute:   boolean  "NO DESCRIPTION"
+ * Sequence.name -> name:   string  "NO DESCRIPTION"
+ * Sequence.select -> select:   boolean  "NO DESCRIPTION"
+ * Sequence.select_left_handle -> select_left_handle:   boolean  "NO DESCRIPTION"
+ * Sequence.select_right_handle -> select_right_handle:   boolean  "NO DESCRIPTION"
+ * Sequence.speed_fader -> speed_fader:   float  "NO DESCRIPTION"
+ * Sequence.type -> type:   enum,  "(read-only)"
+ * Sequence.use_effect_default_fade -> use_default_fade:   boolean  "Fade effect using the built-in default (usually make transition as long as effect strip)"
+ * SequenceColorBalance.gain -> gain:   float[3]  "Color balance gain (highlights)"
+ * SequenceColorBalance.gamma -> gamma:   float[3]  "Color balance gamma (midtones)"
+ * SequenceColorBalance.inverse_gain -> invert_gain:   boolean  "NO DESCRIPTION"
+ * SequenceColorBalance.inverse_gamma -> invert_gamma:   boolean  "NO DESCRIPTION"
+ * SequenceColorBalance.inverse_lift -> invert_lift:   boolean  "NO DESCRIPTION"
+ * SequenceColorBalance.lift -> lift:   float[3]  "Color balance lift (shadows)"
+ * SequenceCrop.right -> max_x:   int  "NO DESCRIPTION"
+ * SequenceCrop.top -> max_y:   int  "NO DESCRIPTION"
+ * SequenceCrop.bottom -> min_x:   int  "NO DESCRIPTION"
+ * SequenceCrop.left -> min_y:   int  "NO DESCRIPTION"
+ * SequenceEditor.active_strip -> active_strip:   pointer  "NO DESCRIPTION"
+ * SequenceEditor.meta_stack -> meta_stack:   collection,  "(read-only)    Meta strip stack, last is currently edited meta strip"
+ * SequenceEditor.overlay_frame -> overlay_frame:   int  "Sequencers active strip"
+ * SequenceEditor.overlay_lock -> overlay_lock:   boolean  "NO DESCRIPTION"
+ * SequenceEditor.sequences -> sequences:   collection,  "(read-only)"
+ * SequenceEditor.sequences_all -> sequences_all:   collection,  "(read-only)"
+ * SequenceEditor.show_overlay -> show_overlay:   boolean  "Partial overlay ontop of the sequencer"
+ * SequenceElement.filename -> filename:   string  "NO DESCRIPTION"
+ * SequenceProxy.directory -> directory:   string  "Location to store the proxy files"
+ * SequenceProxy.filepath -> filepath:   string  "Location of custom proxy file"
+ * SequenceTransform.offset_x -> offset_x:   int  "NO DESCRIPTION"
+ * SequenceTransform.offset_y -> offset_y:   int  "NO DESCRIPTION"
+ * Sequence|EffectSequence.color_balance -> color_balance:   pointer,  "(read-only)"
+ * Sequence|EffectSequence.multiply_colors -> color_multiply:   float  "NO DESCRIPTION"
+ * Sequence|EffectSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
+ * Sequence|EffectSequence.crop -> crop:   pointer,  "(read-only)"
+ * Sequence|EffectSequence.proxy -> proxy:   pointer,  "(read-only)"
+ * Sequence|EffectSequence.strobe -> strobe:   float  "Only display every nth frame"
+ * Sequence|EffectSequence.transform -> transform:   pointer,  "(read-only)"
+ * Sequence|EffectSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
+ * Sequence|EffectSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
+ * Sequence|EffectSequence.de_interlace -> use_deinterlace:   boolean  "For video movies to remove fields"
+ * Sequence|EffectSequence.flip_x -> use_flip_x:   boolean  "Flip on the X axis"
+ * Sequence|EffectSequence.flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
+ * Sequence|EffectSequence.convert_float -> use_float:   boolean  "Convert input to float data"
+ * Sequence|EffectSequence.premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
+ * Sequence|EffectSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
+ * Sequence|EffectSequence.proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
+ * Sequence|EffectSequence.proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
+ * Sequence|EffectSequence.reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
+ * Sequence|EffectSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
+ * Sequence|EffectSequence|ColorSequence.color -> color:   float[3]  "NO DESCRIPTION"
+ * Sequence|EffectSequence|GlowSequence.blur_distance -> blur_radius:   float  "Radius of glow effect"
+ * Sequence|EffectSequence|GlowSequence.boost_factor -> boost_factor:   float  "Brightness multiplier"
+ * Sequence|EffectSequence|GlowSequence.clamp -> clamp:   float  "rightness limit of intensity"
+ * Sequence|EffectSequence|GlowSequence.quality -> quality:   int  "Accuracy of the blur effect"
+ * Sequence|EffectSequence|GlowSequence.threshold -> threshold:   float  "Minimum intensity to trigger a glow"
+ * Sequence|EffectSequence|GlowSequence.only_boost -> use_only_boost:   boolean  "Show the glow buffer only"
+ * Sequence|EffectSequence|PluginSequence.filename -> filename:   string,  "(read-only)"
+ * Sequence|EffectSequence|SpeedControlSequence.global_speed -> global_speed:   float  "NO DESCRIPTION"
+ * Sequence|EffectSequence|SpeedControlSequence.curve_compress_y -> use_curve_compress_y:   boolean  "Scale F-Curve value to get the target frame number, F-Curve value runs from 0.0 to 1.0"
+ * Sequence|EffectSequence|SpeedControlSequence.curve_velocity -> use_curve_velocity:   boolean  "Interpret the F-Curve value as a velocity instead of a frame number"
+ * Sequence|EffectSequence|SpeedControlSequence.frame_blending -> use_frame_blend:   boolean  "Blend two frames into the target for a smoother result"
+ * Sequence|EffectSequence|TransformSequence.interpolation -> interpolation:   enum  "NO DESCRIPTION"
+ * Sequence|EffectSequence|TransformSequence.rotation_start -> rotation_start:   float  "NO DESCRIPTION"
+ * Sequence|EffectSequence|TransformSequence.scale_start_x -> scale_start_x:   float  "NO DESCRIPTION"
+ * Sequence|EffectSequence|TransformSequence.scale_start_y -> scale_start_y:   float  "NO DESCRIPTION"
+ * Sequence|EffectSequence|TransformSequence.translate_start_x -> translate_start_x:   float  "NO DESCRIPTION"
+ * Sequence|EffectSequence|TransformSequence.translate_start_y -> translate_start_y:   float  "NO DESCRIPTION"
+ * Sequence|EffectSequence|TransformSequence.translation_unit -> translation_unit:   enum  "NO DESCRIPTION"
+ * Sequence|EffectSequence|TransformSequence.uniform_scale -> use_uniform_scale:   boolean  "Scale uniformly, preserving aspect ratio"
+ * Sequence|EffectSequence|WipeSequence.angle -> angle:   float  "Edge angle"
+ * Sequence|EffectSequence|WipeSequence.blur_width -> blur_width:   float  "Width of the blur edge, in percentage relative to the image size"
+ * Sequence|EffectSequence|WipeSequence.direction -> direction:   enum  "Wipe direction"
+ * Sequence|EffectSequence|WipeSequence.transition_type -> transition_type:   enum  "NO DESCRIPTION"
+ * Sequence|ImageSequence.animation_end_offset -> animation_offset_end:   int  "Animation end offset (trim end)"
+ * Sequence|ImageSequence.animation_start_offset -> animation_offset_start:   int  "Animation start offset (trim start)"
+ * Sequence|ImageSequence.color_balance -> color_balance:   pointer,  "(read-only)"
+ * Sequence|ImageSequence.multiply_colors -> color_multiply:   float  "NO DESCRIPTION"
+ * Sequence|ImageSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
+ * Sequence|ImageSequence.crop -> crop:   pointer,  "(read-only)"
+ * Sequence|ImageSequence.directory -> directory:   string  "NO DESCRIPTION"
+ * Sequence|ImageSequence.elements -> elements:   collection,  "(read-only)"
+ * Sequence|ImageSequence.proxy -> proxy:   pointer,  "(read-only)"
+ * Sequence|ImageSequence.strobe -> strobe:   float  "Only display every nth frame"
+ * Sequence|ImageSequence.transform -> transform:   pointer,  "(read-only)"
+ * Sequence|ImageSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
+ * Sequence|ImageSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
+ * Sequence|ImageSequence.de_interlace -> use_deinterlace:   boolean  "For video movies to remove fields"
+ * Sequence|ImageSequence.flip_x -> use_flip_x:   boolean  "Flip on the X axis"
+ * Sequence|ImageSequence.flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
+ * Sequence|ImageSequence.convert_float -> use_float:   boolean  "Convert input to float data"
+ * Sequence|ImageSequence.premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
+ * Sequence|ImageSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
+ * Sequence|ImageSequence.proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
+ * Sequence|ImageSequence.proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
+ * Sequence|ImageSequence.reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
+ * Sequence|ImageSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
+ * Sequence|MetaSequence.animation_end_offset -> animation_offset_end:   int  "Animation end offset (trim end)"
+ * Sequence|MetaSequence.animation_start_offset -> animation_offset_start:   int  "Animation start offset (trim start)"
+ * Sequence|MetaSequence.color_balance -> color_balance:   pointer,  "(read-only)"
+ * Sequence|MetaSequence.multiply_colors -> color_multiply:   float  "NO DESCRIPTION"
+ * Sequence|MetaSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
+ * Sequence|MetaSequence.crop -> crop:   pointer,  "(read-only)"
+ * Sequence|MetaSequence.proxy -> proxy:   pointer,  "(read-only)"
+ * Sequence|MetaSequence.sequences -> sequences:   collection,  "(read-only)"
+ * Sequence|MetaSequence.strobe -> strobe:   float  "Only display every nth frame"
+ * Sequence|MetaSequence.transform -> transform:   pointer,  "(read-only)"
+ * Sequence|MetaSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
+ * Sequence|MetaSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
+ * Sequence|MetaSequence.de_interlace -> use_deinterlace:   boolean  "For video movies to remove fields"
+ * Sequence|MetaSequence.flip_x -> use_flip_x:   boolean  "Flip on the X axis"
+ * Sequence|MetaSequence.flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
+ * Sequence|MetaSequence.convert_float -> use_float:   boolean  "Convert input to float data"
+ * Sequence|MetaSequence.premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
+ * Sequence|MetaSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
+ * Sequence|MetaSequence.proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
+ * Sequence|MetaSequence.proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
+ * Sequence|MetaSequence.reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
+ * Sequence|MetaSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
+ * Sequence|MovieSequence.animation_end_offset -> animation_offset_end:   int  "Animation end offset (trim end)"
+ * Sequence|MovieSequence.animation_start_offset -> animation_offset_start:   int  "Animation start offset (trim start)"
+ * Sequence|MovieSequence.color_balance -> color_balance:   pointer,  "(read-only)"
+ * Sequence|MovieSequence.multiply_colors -> color_multiply:   float  "NO DESCRIPTION"
+ * Sequence|MovieSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
+ * Sequence|MovieSequence.crop -> crop:   pointer,  "(read-only)"
+ * Sequence|MovieSequence.filepath -> filepath:   string  "NO DESCRIPTION"
+ * Sequence|MovieSequence.mpeg_preseek -> mpeg_preseek:   int  "For MPEG movies, preseek this many frames"
+ * Sequence|MovieSequence.proxy -> proxy:   pointer,  "(read-only)"
+ * Sequence|MovieSequence.strobe -> strobe:   float  "Only display every nth frame"
+ * Sequence|MovieSequence.transform -> transform:   pointer,  "(read-only)"
+ * Sequence|MovieSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
+ * Sequence|MovieSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
+ * Sequence|MovieSequence.de_interlace -> use_deinterlace:   boolean  "For video movies to remove fields"
+ * Sequence|MovieSequence.flip_x -> use_flip_x:   boolean  "Flip on the X axis"
+ * Sequence|MovieSequence.flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
+ * Sequence|MovieSequence.convert_float -> use_float:   boolean  "Convert input to float data"
+ * Sequence|MovieSequence.premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
+ * Sequence|MovieSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
+ * Sequence|MovieSequence.proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
+ * Sequence|MovieSequence.proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
+ * Sequence|MovieSequence.reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
+ * Sequence|MovieSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
+ * Sequence|MulticamSequence.animation_end_offset -> animation_offset_end:   int  "Animation end offset (trim end)"
+ * Sequence|MulticamSequence.animation_start_offset -> animation_offset_start:   int  "Animation start offset (trim start)"
+ * Sequence|MulticamSequence.color_balance -> color_balance:   pointer,  "(read-only)"
+ * Sequence|MulticamSequence.multiply_colors -> color_multiply:   float  "NO DESCRIPTION"
+ * Sequence|MulticamSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
+ * Sequence|MulticamSequence.crop -> crop:   pointer,  "(read-only)"
+ * Sequence|MulticamSequence.multicam_source -> multicam_source:   int  "NO DESCRIPTION"
+ * Sequence|MulticamSequence.proxy -> proxy:   pointer,  "(read-only)"
+ * Sequence|MulticamSequence.strobe -> strobe:   float  "Only display every nth frame"
+ * Sequence|MulticamSequence.transform -> transform:   pointer,  "(read-only)"
+ * Sequence|MulticamSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
+ * Sequence|MulticamSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
+ * Sequence|MulticamSequence.de_interlace -> use_deinterlace:   boolean  "For video movies to remove fields"
+ * Sequence|MulticamSequence.flip_x -> use_flip_x:   boolean  "Flip on the X axis"
+ * Sequence|MulticamSequence.flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
+ * Sequence|MulticamSequence.convert_float -> use_float:   boolean  "Convert input to float data"
+ * Sequence|MulticamSequence.premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
+ * Sequence|MulticamSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
+ * Sequence|MulticamSequence.proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
+ * Sequence|MulticamSequence.proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
+ * Sequence|MulticamSequence.reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
+ * Sequence|MulticamSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
+ * Sequence|SceneSequence.animation_end_offset -> animation_offset_end:   int  "Animation end offset (trim end)"
+ * Sequence|SceneSequence.animation_start_offset -> animation_offset_start:   int  "Animation start offset (trim start)"
+ * Sequence|SceneSequence.color_balance -> color_balance:   pointer,  "(read-only)"
+ * Sequence|SceneSequence.multiply_colors -> color_multiply:   float  "NO DESCRIPTION"
+ * Sequence|SceneSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
+ * Sequence|SceneSequence.crop -> crop:   pointer,  "(read-only)"
+ * Sequence|SceneSequence.proxy -> proxy:   pointer,  "(read-only)"
+ * Sequence|SceneSequence.scene -> scene:   pointer  "Scene that this sequence uses"
+ * Sequence|SceneSequence.scene_camera -> scene_camera:   pointer  "Override the scenes active camera"
+ * Sequence|SceneSequence.strobe -> strobe:   float  "Only display every nth frame"
+ * Sequence|SceneSequence.transform -> transform:   pointer,  "(read-only)"
+ * Sequence|SceneSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
+ * Sequence|SceneSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
+ * Sequence|SceneSequence.de_interlace -> use_deinterlace:   boolean  "For video movies to remove fields"
+ * Sequence|SceneSequence.flip_x -> use_flip_x:   boolean  "Flip on the X axis"
+ * Sequence|SceneSequence.flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
+ * Sequence|SceneSequence.convert_float -> use_float:   boolean  "Convert input to float data"
+ * Sequence|SceneSequence.premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
+ * Sequence|SceneSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
+ * Sequence|SceneSequence.proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
+ * Sequence|SceneSequence.proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
+ * Sequence|SceneSequence.reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
+ * Sequence|SceneSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
+ * Sequence|SoundSequence.animation_end_offset -> animation_offset_end:   int  "Animation end offset (trim end)"
+ * Sequence|SoundSequence.animation_start_offset -> animation_offset_start:   int  "Animation start offset (trim start)"
+ * Sequence|SoundSequence.attenuation -> attenuation:   float  "Attenuation in dezibel"
+ * Sequence|SoundSequence.filepath -> filepath:   string  "NO DESCRIPTION"
+ * Sequence|SoundSequence.sound -> sound:   pointer,  "(read-only)    Sound datablock used by this sequence"
+ * Sequence|SoundSequence.volume -> volume:   float  "Playback volume of the sound"
+ * ShapeKey.data -> data:   collection,  "(read-only)"
+ * ShapeKey.frame -> frame:   float,  "(read-only)    Frame for absolute keys"
+ * ShapeKey.interpolation -> interpolation:   enum  "Interpolation type"
+ * ShapeKey.mute -> mute:   boolean  "Mute this shape key"
+ * ShapeKey.name -> name:   string  "NO DESCRIPTION"
+ * ShapeKey.relative_key -> relative_key:   pointer  "Shape used as a relative key"
+ * ShapeKey.slider_max -> slider_max:   float  "Maximum for slider"
+ * ShapeKey.slider_min -> slider_min:   float  "Minimum for slider"
+ * ShapeKey.value -> value:   float  "Value of shape key at the current frame"
+ * ShapeKey.vertex_group -> vertex_group:   string  "Vertex weight group, to blend with basis shape"
+ * ShapeKeyBezierPoint.co -> co:   float[3]  "NO DESCRIPTION"
+ * ShapeKeyBezierPoint.handle_1_co -> handle_left:   float[3]  "NO DESCRIPTION"
+ * ShapeKeyBezierPoint.handle_2_co -> handle_right:   float[3]  "NO DESCRIPTION"
+ * ShapeKeyCurvePoint.co -> co:   float[3]  "NO DESCRIPTION"
+ * ShapeKeyCurvePoint.tilt -> tilt:   float  "NO DESCRIPTION"
+ * ShapeKeyPoint.co -> co:   float[3]  "NO DESCRIPTION"
TODO BETTER NAME * SmokeDomainSettings.alpha -> alpha:   float  "Higher value results in sinking smoke"
+ * SmokeDomainSettings.amplify -> amplify:   int  "Enhance the resolution of smoke by this factor using noise"
TODO BETTER NAME * SmokeDomainSettings.beta -> beta:   float  "Higher value results in faster rising smoke"
+ * SmokeDomainSettings.smoke_domain_colli -> collision_extents:   enum  "Selects which domain border will be treated as collision object."
+ * SmokeDomainSettings.coll_group -> collision_group:   pointer  "Limit collisions to this group"
+ * SmokeDomainSettings.dissolve_speed -> dissolve_speed:   int  "Dissolve Speed"
+ * SmokeDomainSettings.eff_group -> eff_group:   pointer  "Limit effectors to this group"
+ * SmokeDomainSettings.effector_weights -> effector_weights:   pointer,  "(read-only)"
+ * SmokeDomainSettings.fluid_group -> fluid_group:   pointer  "Limit fluid objects to this group"
+ * SmokeDomainSettings.noise_type -> noise_type:   enum  "Noise method which is used for creating the high resolution"
+ * SmokeDomainSettings.smoke_cache_high_comp -> point_cache_compress_high_type:   enum  "Compression method to be used"
+ * SmokeDomainSettings.smoke_cache_comp -> point_cache_compress_type:   enum  "Compression method to be used"
+ * SmokeDomainSettings.point_cache_high -> point_cache_high:   pointer,  "(read-only)"
+ * SmokeDomainSettings.point_cache_low -> point_cache_low:   pointer,  "(read-only)"
+ * SmokeDomainSettings.maxres -> resolution_max:   int  "Maximal resolution used in the fluid domain"
+ * SmokeDomainSettings.viewhighres -> show_high_resolution:   boolean  "Show high resolution (using amplification)"
+ * SmokeDomainSettings.smoothemitter -> smooth_emitter:   boolean  "Smoothens emitted smoke to avoid blockiness."
+ * SmokeDomainSettings.strength -> strength:   float  "Strength of wavelet noise"
+ * SmokeDomainSettings.time_scale -> time_scale:   float  "Adjust simulation speed."
+ * SmokeDomainSettings.dissolve_smoke -> use_dissolve_smoke:   boolean  "Enable smoke to disappear over time"
+ * SmokeDomainSettings.dissolve_smoke_log -> use_dissolve_smoke_log:   boolean  "Using 1/x"
+ * SmokeDomainSettings.highres -> use_high_resolution:   boolean  "Enable high resolution (using amplification)"
+ * SmokeDomainSettings.vorticity -> vorticity:   float  "Amount of turbulence/rotation in fluid."
+ * SmokeFlowSettings.density -> density:   float  "NO DESCRIPTION"
+ * SmokeFlowSettings.initial_velocity -> initial_velocity:   boolean  "Smoke inherits its velocity from the emitter particle"
+ * SmokeFlowSettings.psys -> particle_system:   pointer  "Particle systems emitted from the object"
+ * SmokeFlowSettings.temperature -> temperature:   float  "Temperature difference to ambient temperature"
+ * SmokeFlowSettings.absolute -> use_absolute:   boolean  "Only allows given density value in emitter area."
+NEGATE * SmokeFlowSettings.outflow -> use_outflow:   boolean  "Deletes smoke from simulation"
+ * SmokeFlowSettings.velocity_multiplier -> velocity_factor:   float  "Multiplier to adjust velocity passed to smoke"
+ * SoftBodySettings.aero -> aero:   float  "Make edges sail"
+ * SoftBodySettings.aerodynamics_type -> aerodynamics_type:   enum  "Method of calculating aerodynamic interaction"
+ * SoftBodySettings.ball_damp -> ball_damp:   float  "Blending to inelastic collision"
+ * SoftBodySettings.ball_size -> ball_size:   float  "Absolute ball size or factor if not manual adjusted"
+ * SoftBodySettings.ball_stiff -> ball_stiff:   float  "Ball inflating pressure"
+ * SoftBodySettings.bending -> bend:   float  "Bending Stiffness"
+ * SoftBodySettings.choke -> choke:   int  "Viscosity inside collision target"
+ * SoftBodySettings.collision_type -> collision_type:   enum  "Choose Collision Type"
+ * SoftBodySettings.damp -> damping:   float  "Edge spring friction"
+ * SoftBodySettings.effector_weights -> effector_weights:   pointer,  "(read-only)"
+ * SoftBodySettings.error_limit -> error_threshold:   float  "The Runge-Kutta ODE solver error limit, low value gives more precision, high values speed"
+ * SoftBodySettings.friction -> friction:   float  "General media friction for point movements"
+ * SoftBodySettings.fuzzy -> fuzzy:   int  "Fuzziness while on collision, high values make collsion handling faster but less stable"
+ * SoftBodySettings.goal_default -> goal_default:   float  "Default Goal (vertex target position) value, when no Vertex Group used"
+ * SoftBodySettings.goal_friction -> goal_friction:   float  "Goal (vertex target position) friction"
+ * SoftBodySettings.goal_max -> goal_max:   float  "Goal maximum, vertex weights are scaled to match this range"
+ * SoftBodySettings.goal_min -> goal_min:   float  "Goal minimum, vertex weights are scaled to match this range"
+ * SoftBodySettings.goal_spring -> goal_spring:   float  "Goal (vertex target position) spring stiffness"
+ * SoftBodySettings.goal_vertex_group -> goal_vertex_group:   string  "Control point weight values"
+ * SoftBodySettings.gravity -> gravity:   float  "Apply gravitation to point movement"
+ * SoftBodySettings.lcom -> location_mass_center:   float[3]  "Location of Center of mass"
+ * SoftBodySettings.mass -> mass:   float  "General Mass value"
+ * SoftBodySettings.mass_vertex_group -> mass_vertex_group:   string  "Control point mass values"
+ * SoftBodySettings.plastic -> plastic:   float  "Permanent deform"
+ * SoftBodySettings.pull -> pull:   float  "Edge spring stiffness when longer than rest length"
+ * SoftBodySettings.push -> push:   float  "Edge spring stiffness when shorter than rest length"
+ * SoftBodySettings.lrot -> rotation_estimate:   float[9]  "Estimated rotation matrix"
+ * SoftBodySettings.lscale -> scale_estimate:   float[9]  "Estimated scale matrix"
+ * SoftBodySettings.shear -> shear:   float  "Shear Stiffness"
+ * SoftBodySettings.speed -> speed:   float  "Tweak timing for physics to control frequency and speed"
+ * SoftBodySettings.spring_length -> spring_length:   float  "Alter spring length to shrink/blow up (unit %) 0 to disable"
+ * SoftBodySettings.spring_vertex_group -> spring_vertex_group:   string  "Control point spring strength values"
+ * SoftBodySettings.maxstep -> step_max:   int  "Maximal # solver steps/frame"
+ * SoftBodySettings.minstep -> step_min:   int  "Minimal # solver steps/frame"
+ * SoftBodySettings.auto_step -> use_auto_step:   boolean  "Use velocities for automagic step sizes"
+ * SoftBodySettings.diagnose -> use_diagnose:   boolean  "Turn on SB diagnose console prints"
+ * SoftBodySettings.edge_collision -> use_edge_collision:   boolean  "Edges collide too"
+ * SoftBodySettings.use_edges -> use_edges:   boolean  "Use Edges as springs"
+ * SoftBodySettings.estimate_matrix -> use_estimate_matrix:   boolean  "estimate matrix .. split to COM , ROT ,SCALE"
+ * SoftBodySettings.face_collision -> use_face_collision:   boolean  "Faces collide too, can be very slow"
+ * SoftBodySettings.use_goal -> use_goal:   boolean  "Define forces for vertices to stick to animated position"
+ * SoftBodySettings.self_collision -> use_self_collision:   boolean  "Enable naive vertex ball self collision"
+ * SoftBodySettings.stiff_quads -> use_stiff_quads:   boolean  "Adds diagonal springs on 4-gons"
+ * Space.type -> type:   enum,  "(read-only)    Space data type"
+ * SpaceUVEditor.cursor_location -> cursor_location:   float[2]  "2D cursor location for this view"
+ * SpaceUVEditor.draw_stretch_type -> draw_stretch_type:   enum  "Type of stretch to draw"
+ * SpaceUVEditor.edge_draw_type -> edge_draw_type:   enum  "Draw type for drawing UV edges"
+ * SpaceUVEditor.constrain_to_image_bounds -> lock_bounds:   boolean  "Constraint to stay within the image bounds while editing"
+ * SpaceUVEditor.pivot -> pivot_point:   enum  "Rotation/Scaling Pivot"
+ * SpaceUVEditor.draw_modified_edges -> show_modified_edges:   boolean  "Draw edges after modifiers are applied"
+ * SpaceUVEditor.normalized_coordinates -> show_normalized_coords:   boolean  "Display UV coordinates from 0.0 to 1.0 rather than in pixels"
+ * SpaceUVEditor.draw_other_objects -> show_other_objects:   boolean  "Draw other selected objects that share the same image"
+ * SpaceUVEditor.draw_smooth_edges -> show_smooth_edges:   boolean  "Draw UV edges anti-aliased"
+ * SpaceUVEditor.draw_stretch -> show_stretch:   boolean  "Draw faces colored according to the difference in shape between UVs and their 3D coordinates (blue for low distortion, red for high distortion)"
+ * SpaceUVEditor.sticky_selection_mode -> sticky_select_mode:   enum  "Automatically select also UVs sharing the same vertex as the ones being selected"
+ * SpaceUVEditor.live_unwrap -> use_live_unwrap:   boolean  "Continuously unwrap the selected UV island while transforming pinned vertices"
+ * SpaceUVEditor.snap_to_pixels -> use_snap_to_pixels:   boolean  "Snap UVs to pixel locations while editing"
+ * Space|SpaceConsole.console_type -> console_type:   enum  "Console type"
+ * Space|SpaceConsole.font_size -> font_size:   int  "Font size to use for displaying the text"
+ * Space|SpaceConsole.history -> history:   collection,  "(read-only)    Command history"
+ * Space|SpaceConsole.language -> language:   string  "Command line prompt language"
+ * Space|SpaceConsole.prompt -> prompt:   string  "Command line prompt"
+ * Space|SpaceConsole.scrollback -> scrollback:   collection,  "(read-only)    Command output"
+ * Space|SpaceConsole.selection_end -> select_end:   int  "NO DESCRIPTION"
+ * Space|SpaceConsole.selection_start -> select_start:   int  "NO DESCRIPTION"
+ * Space|SpaceConsole.show_report_debug -> show_report_debug:   boolean  "Display debug reporting info"
+ * Space|SpaceConsole.show_report_error -> show_report_error:   boolean  "Display error text"
+ * Space|SpaceConsole.show_report_info -> show_report_info:   boolean  "Display general information"
+ * Space|SpaceConsole.show_report_operator -> show_report_operator:   boolean  "Display the operator log"
+ * Space|SpaceConsole.show_report_warn -> show_report_warning:   boolean  "Display warnings"
+ * Space|SpaceDopeSheetEditor.action -> action:   pointer  "Action displayed and edited in this space"
+ * Space|SpaceDopeSheetEditor.autosnap -> auto_snap:   enum  "Automatic time snapping settings for transformations"
+ * Space|SpaceDopeSheetEditor.dopesheet -> dopesheet:   pointer,  "(read-only)    Settings for filtering animation data"
+ * Space|SpaceDopeSheetEditor.mode -> mode:   enum  "Editing context being displayed"
+ * Space|SpaceDopeSheetEditor.show_cframe_indicator -> show_frame_indicator:   boolean  "Show frame number beside the current frame indicator line"
+ * Space|SpaceDopeSheetEditor.show_seconds -> show_seconds:   boolean,  "(read-only)    Show timing in seconds not frames"
+ * Space|SpaceDopeSheetEditor.show_sliders -> show_sliders:   boolean  "Show sliders beside F-Curve channels"
+ * Space|SpaceDopeSheetEditor.automerge_keyframes -> use_auto_merge_keyframes:   boolean  "Automatically merge nearby keyframes"
+ * Space|SpaceDopeSheetEditor.use_marker_sync -> use_marker_sync:   boolean  "Sync Markers with keyframe edits"
+ * Space|SpaceDopeSheetEditor.realtime_updates -> use_realtime_update:   boolean  "When transforming keyframes, changes to the animation data are flushed to other views"
+ * Space|SpaceFileBrowser.params -> params:   pointer,  "(read-only)    Parameters and Settings for the Filebrowser"
+ * Space|SpaceGraphEditor.autosnap -> auto_snap:   enum  "Automatic time snapping settings for transformations"
+ * Space|SpaceGraphEditor.cursor_value -> cursor_position_y:   float  "Graph Editor 2D-Value cursor - Y-Value component"
+ * Space|SpaceGraphEditor.dopesheet -> dopesheet:   pointer,  "(read-only)    Settings for filtering animation data"
+ * Space|SpaceGraphEditor.has_ghost_curves -> has_ghost_curves:   boolean  "Graph Editor instance has some ghost curves stored"
+ * Space|SpaceGraphEditor.mode -> mode:   enum  "Editing context being displayed"
+ * Space|SpaceGraphEditor.pivot_point -> pivot_point:   enum  "Pivot center for rotation/scaling"
+ * Space|SpaceGraphEditor.show_cursor -> show_cursor:   boolean  "Show 2D cursor"
+ * Space|SpaceGraphEditor.show_cframe_indicator -> show_frame_indicator:   boolean  "Show frame number beside the current frame indicator line"
+ * Space|SpaceGraphEditor.show_handles -> show_handles:   boolean  "Show handles of Bezier control points"
+ * Space|SpaceGraphEditor.show_seconds -> show_seconds:   boolean,  "(read-only)    Show timing in seconds not frames"
+ * Space|SpaceGraphEditor.show_sliders -> show_sliders:   boolean  "Show sliders beside F-Curve channels"
+ * Space|SpaceGraphEditor.automerge_keyframes -> use_auto_merge_keyframes:   boolean  "Automatically merge nearby keyframes"
+ * Space|SpaceGraphEditor.only_selected_curves_handles -> use_only_selected_curves_handles:   boolean  "Only keyframes of selected F-Curves are visible and editable"
+ * Space|SpaceGraphEditor.only_selected_keyframe_handles -> use_only_selected_keyframe_handles:   boolean  "Only show and edit handles of selected keyframes"
+ * Space|SpaceGraphEditor.realtime_updates -> use_realtime_update:   boolean  "When transforming keyframes, changes to the animation data are flushed to other views"
+ * Space|SpaceImageEditor.curves -> curves:   pointer,  "(read-only)    Color curve mapping to use for displaying the image"
+ * Space|SpaceImageEditor.draw_channels -> draw_channels:   enum  "Channels of the image to draw"
+ * Space|SpaceImageEditor.grease_pencil -> grease_pencil:   pointer  "Grease pencil data for this space"
+ * Space|SpaceImageEditor.image -> image:   pointer  "Image displayed and edited in this space"
+ * Space|SpaceImageEditor.image_user -> image_user:   pointer,  "(read-only)    Parameters defining which layer, pass and frame of the image is displayed"
+ * Space|SpaceImageEditor.sample_histogram -> sample_histogram:   pointer,  "(read-only)    Sampled colors along line"
+ * Space|SpaceImageEditor.scopes -> scopes:   pointer,  "(read-only)    Scopes to visualize image statistics."
+ * Space|SpaceImageEditor.show_paint -> show_paint:   boolean,  "(read-only)    Show paint related properties"
+ * Space|SpaceImageEditor.show_render -> show_render:   boolean,  "(read-only)    Show render related properties"
+ * Space|SpaceImageEditor.draw_repeated -> show_repeat:   boolean  "Draw the image repeated outside of the main view"
+ * Space|SpaceImageEditor.show_uvedit -> show_uvedit:   boolean,  "(read-only)    Show UV editing related properties"
+ * Space|SpaceImageEditor.use_grease_pencil -> use_grease_pencil:   boolean  "Display and edit the grease pencil freehand annotations overlay"
+ * Space|SpaceImageEditor.image_painting -> use_image_paint:   boolean  "Enable image painting mode"
+ * Space|SpaceImageEditor.image_pin -> use_image_pin:   boolean  "Display current image regardless of object selection"
+ * Space|SpaceImageEditor.update_automatically -> use_realtime_update:   boolean  "Update other affected window spaces automatically to reflect changes during interactive operations such as transform"
+ * Space|SpaceImageEditor.uv_editor -> uv_editor:   pointer,  "(read-only)    UV editor settings"
+ * Space|SpaceLogicEditor.actuators_show_active_objects -> show_actuators_active_object:   boolean  "Show actuators of active object"
+ * Space|SpaceLogicEditor.actuators_show_active_states -> show_actuators_active_states:   boolean  "Show only actuators connected to active states"
+ * Space|SpaceLogicEditor.actuators_show_linked_controller -> show_actuators_linked_controller:   boolean  "Show linked objects to the actuator"
+ * Space|SpaceLogicEditor.actuators_show_selected_objects -> show_actuators_selected_objects:   boolean  "Show actuators of all selected objects"
+ * Space|SpaceLogicEditor.controllers_show_active_objects -> show_controllers_active_object:   boolean  "Show controllers of active object"
+ * Space|SpaceLogicEditor.controllers_show_linked_controller -> show_controllers_linked_controller:   boolean  "Show linked objects to sensor/actuator"
+ * Space|SpaceLogicEditor.controllers_show_selected_objects -> show_controllers_selected_objects:   boolean  "Show controllers of all selected objects"
+ * Space|SpaceLogicEditor.sensors_show_active_objects -> show_sensors_active_object:   boolean  "Show sensors of active object"
+ * Space|SpaceLogicEditor.sensors_show_active_states -> show_sensors_active_states:   boolean  "Show only sensors connected to active states"
+ * Space|SpaceLogicEditor.sensors_show_linked_controller -> show_sensors_linked_controller:   boolean  "Show linked objects to the controller"
+ * Space|SpaceLogicEditor.sensors_show_selected_objects -> show_sensors_selected_objects:   boolean  "Show sensors of all selected objects"
+ * Space|SpaceNLA.autosnap -> auto_snap:   enum  "Automatic time snapping settings for transformations"
+ * Space|SpaceNLA.dopesheet -> dopesheet:   pointer,  "(read-only)    Settings for filtering animation data"
+ * Space|SpaceNLA.show_cframe_indicator -> show_frame_indicator:   boolean  "Show frame number beside the current frame indicator line"
+ * Space|SpaceNLA.show_seconds -> show_seconds:   boolean,  "(read-only)    Show timing in seconds not frames"
+ * Space|SpaceNLA.show_strip_curves -> show_strip_curves:   boolean  "Show influence curves on strips"
+ * Space|SpaceNLA.realtime_updates -> use_realtime_update:   boolean  "When transforming strips, changes to the animation data are flushed to other views"
+ * Space|SpaceNodeEditor.id -> id:   pointer,  "(read-only)    Datablock whose nodes are being edited"
+ * Space|SpaceNodeEditor.id_from -> id_from:   pointer,  "(read-only)    Datablock from which the edited datablock is linked"
+ * Space|SpaceNodeEditor.nodetree -> nodetree:   pointer,  "(read-only)    Node tree being displayed and edited"
+ * Space|SpaceNodeEditor.backdrop -> show_backdrop:   boolean  "Use active Viewer Node output as backdrop for compositing nodes"
+ * Space|SpaceNodeEditor.texture_type -> texture_type:   enum  "Type of data to take texture from"
+ * Space|SpaceNodeEditor.tree_type -> tree_type:   enum  "Node tree type to display and edit"
+ * Space|SpaceOutliner.display_mode -> display_mode:   enum  "Type of information to display"
+ * Space|SpaceOutliner.display_filter -> filter_text:   string  "Live search filtering string"
+ * Space|SpaceOutliner.show_restriction_columns -> show_restrict_columns:   boolean  "Show column"
+ * Space|SpaceOutliner.match_case_sensitive -> use_filter_case_sensitive:   boolean  "Only use case sensitive matches of search string"
+ * Space|SpaceOutliner.match_complete -> use_filter_complete:   boolean  "Only use complete matches of search string"
+ * Space|SpaceProperties.align -> align:   enum  "Arrangement of the panels"
+ * Space|SpaceProperties.context -> context:   enum  "Type of active data to display and edit"
+ * Space|SpaceProperties.pin_id -> pin_id:   pointer  "NO DESCRIPTION"
+ * Space|SpaceProperties.brush_texture -> show_brush_texture:   boolean  "Show brush textures"
+ * Space|SpaceProperties.use_pin_id -> use_pin_id:   boolean  "Use the pinned context"
+ * Space|SpaceSequenceEditor.display_channel -> display_channel:   int  "The channel number shown in the image preview. 0 is the result of all strips combined"
+ * Space|SpaceSequenceEditor.display_mode -> display_mode:   enum  "The view mode to use for displaying sequencer output"
+ * Space|SpaceSequenceEditor.draw_overexposed -> draw_overexposed:   int  "Show overexposed areas with zebra stripes"
+ * Space|SpaceSequenceEditor.grease_pencil -> grease_pencil:   pointer,  "(read-only)    Grease pencil data for this space"
+ * Space|SpaceSequenceEditor.offset_x -> offset_x:   float  "Offsets image horizontally from the view center"
+ * Space|SpaceSequenceEditor.offset_y -> offset_y:   float  "Offsets image horizontally from the view center"
+ * Space|SpaceSequenceEditor.proxy_render_size -> proxy_render_size:   enum  "Draw preview using full resolution or different proxy resolutions"
+ * Space|SpaceSequenceEditor.show_cframe_indicator -> show_frame_indicator:   boolean  "Show frame number beside the current frame indicator line"
+ * Space|SpaceSequenceEditor.draw_frames -> show_frames:   boolean  "Draw frames rather than seconds"
+ * Space|SpaceSequenceEditor.draw_safe_margin -> show_safe_margin:   boolean  "Draw title safe margins in preview"
+ * Space|SpaceSequenceEditor.separate_color_preview -> show_separate_color:   boolean  "Separate color channels in preview"
+ * Space|SpaceSequenceEditor.use_grease_pencil -> use_grease_pencil:   boolean  "Display and edit the grease pencil freehand annotations overlay"
+ * Space|SpaceSequenceEditor.use_marker_sync -> use_marker_sync:   boolean  "Transform markers as well as strips"
+ * Space|SpaceSequenceEditor.view_type -> view_type:   enum  "The type of the Sequencer view (sequencer, preview or both)"
+ * Space|SpaceSequenceEditor.zoom -> zoom:   float  "Display zoom level"
+ * Space|SpaceTextEditor.find_text -> find_text:   string  "Text to search for with the find tool"
+ * Space|SpaceTextEditor.font_size -> font_size:   int  "Font size to use for displaying the text"
+ * Space|SpaceTextEditor.replace_text -> replace_text:   string  "Text to replace selected text with using the replace tool"
Space|SpaceTextEditor.show_line_highlight -> show_line_highlight:   boolean  "Highlight the current line"
+ * Space|SpaceTextEditor.show_line_numbers -> show_line_numbers:   boolean  "Show line numbers next to the text"
+ * Space|SpaceTextEditor.show_syntax_highlight -> show_syntax_highlight:   boolean  "Syntax highlight for scripting"
+ * Space|SpaceTextEditor.show_word_wrap -> show_word_wrap:   boolean  "Wrap words if there is not enough horizontal space"
+ * Space|SpaceTextEditor.tab_width -> tab_width:   int  "Number of spaces to display tabs with"
+ * Space|SpaceTextEditor.text -> text:   pointer  "Text displayed and edited in this space"
+ * Space|SpaceTextEditor.find_all -> use_find_all:   boolean  "Search in all text datablocks, instead of only the active one"
+ * Space|SpaceTextEditor.find_wrap -> use_find_wrap:   boolean  "Search again from the start of the file when reaching the end"
+ * Space|SpaceTextEditor.live_edit -> use_live_edit:   boolean  "Run python while editing"
+ * Space|SpaceTextEditor.overwrite -> use_overwrite:   boolean  "Overwrite characters when typing rather than inserting them"
+ * Space|SpaceTimeline.cache_cloth -> cache_cloth:   boolean  "Show the active objects cloth point cache"
+ * Space|SpaceTimeline.cache_particles -> cache_particles:   boolean  "Show the active objects particle point cache"
+ * Space|SpaceTimeline.cache_smoke -> cache_smoke:   boolean  "Show the active objects smoke cache"
+ * Space|SpaceTimeline.cache_softbody -> cache_softbody:   boolean  "Show the active objects softbody point cache"
+ * Space|SpaceTimeline.show_cache -> show_cache:   boolean  "Show the status of cached frames in the timeline"
+ * Space|SpaceTimeline.show_cframe_indicator -> show_frame_indicator:   boolean  "Show frame number beside the current frame indicator line"
+ * Space|SpaceTimeline.only_selected -> show_only_selected:   boolean  "Show keyframes for active Object and/or its selected channels only"
+ * Space|SpaceTimeline.play_all_3d -> use_play_3d_editors:   boolean  "NO DESCRIPTION"
+ * Space|SpaceTimeline.play_anim -> use_play_animation_editors:   boolean  "NO DESCRIPTION"
+ * Space|SpaceTimeline.play_image -> use_play_image_editors:   boolean  "NO DESCRIPTION"
+ * Space|SpaceTimeline.play_nodes -> use_play_node_editors:   boolean  "NO DESCRIPTION"
+ * Space|SpaceTimeline.play_buttons -> use_play_properties_editors:   boolean  "NO DESCRIPTION"
+ * Space|SpaceTimeline.play_sequencer -> use_play_sequence_editors:   boolean  "NO DESCRIPTION"
+ * Space|SpaceTimeline.play_top_left -> use_play_top_left_3d_editor:   boolean  "NO DESCRIPTION"
+ * Space|SpaceUserPreferences.filter -> filter_text:   string  "Search term for filtering in the UI"
+ * Space|SpaceView3D.background_images -> background_images:   collection,  "(read-only)    List of background images"
+ * Space|SpaceView3D.camera -> camera:   pointer  "Active camera used in this view (when unlocked from the scenes active camera)"
+ * Space|SpaceView3D.clip_end -> clip_end:   float  "3D View far clipping distance"
+ * Space|SpaceView3D.clip_start -> clip_start:   float  "3D View near clipping distance"
+ * Space|SpaceView3D.current_orientation -> current_orientation:   pointer,  "(read-only)    Current Transformation orientation"
+ * Space|SpaceView3D.cursor_location -> cursor_location:   float[3]  "3D cursor location for this view (dependent on local view setting)"
+ * Space|SpaceView3D.grid_lines -> grid_lines:   int  "The number of grid lines to display in perspective view"
+ * Space|SpaceView3D.grid_spacing -> grid_spacing:   float  "The distance between 3D View grid lines"
+ * Space|SpaceView3D.grid_subdivisions -> grid_subdivisions:   int  "The number of subdivisions between grid lines"
+ * Space|SpaceView3D.layers -> layers:   boolean[20]  "Layers visible in this 3D View"
+ * Space|SpaceView3D.used_layers -> layers_used:   boolean[20],  "(read-only)    Layers that contain something"
+ * Space|SpaceView3D.lens -> lens:   float  "Lens angle (mm) in perspective view"
+ * Space|SpaceView3D.local_view -> local_view:   pointer,  "(read-only)    Display an isolated sub-set of objects, apart from the scene visibility"
+ * Space|SpaceView3D.lock_bone -> lock_bone:   string  "3D View center is locked to this bones position"
+ * Space|SpaceView3D.lock_camera_and_layers -> lock_camera_and_layers:   boolean  "Use the scenes active camera and layers in this view, rather than local layers"
+ * Space|SpaceView3D.lock_object -> lock_object:   pointer  "3D View center is locked to this objects position"
+ * Space|SpaceView3D.pivot_point -> pivot_point:   enum  "Pivot center for rotation/scaling"
+ * Space|SpaceView3D.region_3d -> region_3d:   pointer,  "(read-only)    3D region in this space, in case of quad view the camera region"
+ * Space|SpaceView3D.region_quadview -> region_quadview:   pointer,  "(read-only)    3D region that defines the quad view settings"
+ * Space|SpaceView3D.all_object_origins -> show_all_objects_origin:   boolean  "Show the object origin center dot for all (selected and unselected) objects"
+ * Space|SpaceView3D.display_x_axis -> show_axis_x:   boolean  "Show the X axis line in perspective view"
+ * Space|SpaceView3D.display_y_axis -> show_axis_y:   boolean  "Show the Y axis line in perspective view"
+ * Space|SpaceView3D.display_z_axis -> show_axis_z:   boolean  "Show the Z axis line in perspective view"
+ * Space|SpaceView3D.display_background_images -> show_background_images:   boolean  "Display reference images behind objects in the 3D View"
+ * Space|SpaceView3D.display_floor -> show_floor:   boolean  "Show the ground plane grid in perspective view"
+ * Space|SpaceView3D.display_render_override -> show_only_render:   boolean  "Display only objects which will be rendered"
+ * Space|SpaceView3D.outline_selected -> show_outline_selected:   boolean  "Show an outline highlight around selected objects in non-wireframe views"
+ * Space|SpaceView3D.relationship_lines -> show_relationship_lines:   boolean  "Show dashed lines indicating parent or constraint relationships"
+ * Space|SpaceView3D.textured_solid -> show_textured_solid:   boolean  "Display face-assigned textures in solid view"
+ * Space|SpaceView3D.transform_orientation -> transform_orientation:   enum  "Transformation orientation"
+ * Space|SpaceView3D.manipulator -> use_manipulator:   boolean  "Use a 3D manipulator widget for controlling transforms"
+ * Space|SpaceView3D.manipulator_rotate -> use_manipulator_rotate:   boolean  "Use the manipulator for rotation transformations"
+ * Space|SpaceView3D.manipulator_scale -> use_manipulator_scale:   boolean  "Use the manipulator for scale transformations"
+ * Space|SpaceView3D.manipulator_translate -> use_manipulator_translate:   boolean  "Use the manipulator for movement transformations"
+ * Space|SpaceView3D.occlude_geometry -> use_occlude_geometry:   boolean  "Limit selection to visible (clipped with depth buffer)"
+ * Space|SpaceView3D.pivot_point_align -> use_pivot_point_align:   boolean  "Manipulate object centers only"
+ * Space|SpaceView3D.viewport_shading -> viewport_shade:   enum  "Method to display/shade objects in the 3D View"
+ * Spline.bezier_points -> bezier_points:   collection,  "(read-only)    Collection of points for bezier curves only"
+ * Spline.character_index -> character_index:   int,  "(read-only)    Location of this character in the text data (only for text curves)"
+ * Spline.hide -> hide:   boolean  "Hide this curve in editmode"
+ * Spline.material_index -> material_index:   int  "NO DESCRIPTION"
+ * Spline.order_u -> order_u:   int  "Nurbs order in the U direction (For splines and surfaces), Higher values let points influence a greater area"
+ * Spline.order_v -> order_v:   int  "Nurbs order in the V direction (For surfaces only), Higher values let points influence a greater area"
+ * Spline.point_count_u -> point_count_u:   int,  "(read-only)    Total number points for the curve or surface in the U direction"
+ * Spline.point_count_v -> point_count_v:   int,  "(read-only)    Total number points for the surface on the V direction"
+ * Spline.points -> points:   collection,  "(read-only)    Collection of points that make up this poly or nurbs spline"
+ * Spline.radius_interpolation -> radius_interpolation:   enum  "The type of radius interpolation for Bezier curves"
+ * Spline.resolution_u -> resolution_u:   int  "Curve or Surface subdivisions per segment"
+ * Spline.resolution_v -> resolution_v:   int  "Surface subdivisions per segment"
+ * Spline.tilt_interpolation -> tilt_interpolation:   enum  "The type of tilt interpolation for 3D, Bezier curves"
+ * Spline.type -> type:   enum  "The interpolation type for this curve element"
+ * Spline.bezier_u -> use_bezier_u:   boolean  "Make this nurbs curve or surface act like a bezier spline in the U direction (Order U must be 3 or 4, Cyclic U must be disabled)"
+ * Spline.bezier_v -> use_bezier_v:   boolean  "Make this nurbs surface act like a bezier spline in the V direction (Order V must be 3 or 4, Cyclic V must be disabled)"
+ * Spline.cyclic_u -> use_cyclic_u:   boolean  "Make this curve or surface a closed loop in the U direction"
+ * Spline.cyclic_v -> use_cyclic_v:   boolean  "Make this surface a closed loop in the V direction"
+ * Spline.endpoint_u -> use_endpoint_u:   boolean  "Make this nurbs curve or surface meet the endpoints in the U direction (Cyclic U must be disabled)"
+ * Spline.endpoint_v -> use_endpoint_v:   boolean  "Make this nurbs surface meet the endpoints in the V direction (Cyclic V must be disabled)"
+ * Spline.smooth -> use_smooth:   boolean  "Smooth the normals of the surface or beveled curve"
+ * SplinePoint.co -> co:   float[4]  "Point coordinates"
+ * SplinePoint.hide -> hide:   boolean  "Visibility status"
+ * SplinePoint.radius -> radius:   float,  "(read-only)    Radius for bevelling"
+ * SplinePoint.select -> select:   boolean  "Selection status"
+ * SplinePoint.tilt -> tilt:   float  "Tilt in 3D View"
+ * SplinePoint.weight -> weight:   float  "Nurbs weight"
+ * SplinePoint.weight_softbody -> weight_softbody:   float  "Softbody goal weight"
+ * Struct.base -> base:   pointer,  "(read-only)    Struct definition this is derived from"
+ * Struct.description -> description:   string,  "(read-only)    Description of the Structs purpose"
+ * Struct.functions -> functions:   collection,  "(read-only)"
+ * Struct.identifier -> identifier:   string,  "(read-only)    Unique name used in the code and scripting"
+ * Struct.name -> name:   string,  "(read-only)    Human readable name"
+ * Struct.name_property -> name_property:   pointer,  "(read-only)    Property that gives the name of the struct"
+ * Struct.nested -> nested:   pointer,  "(read-only)    Struct in which this struct is always nested, and to which it logically belongs"
+ * Struct.properties -> properties:   collection,  "(read-only)    Properties in the struct"
+ * TexMapping.location -> location:   float[3]  "NO DESCRIPTION"
+ * TexMapping.maximum -> max:   float[3]  "Maximum value for clipping"
+ * TexMapping.minimum -> min:   float[3]  "Minimum value for clipping"
+ * TexMapping.rotation -> rotation:   float[3]  "NO DESCRIPTION"
+ * TexMapping.scale -> scale:   float[3]  "NO DESCRIPTION"
+ * TexMapping.has_maximum -> use_max:   boolean  "Whether to use maximum clipping value"
+ * TexMapping.has_minimum -> use_min:   boolean  "Whether to use minimum clipping value"
+ * TextBox.height -> height:   float  "NO DESCRIPTION"
+ * TextBox.width -> width:   float  "NO DESCRIPTION"
+ * TextBox.x -> x:   float  "NO DESCRIPTION"
+ * TextBox.y -> y:   float  "NO DESCRIPTION"
+ * TextCharacterFormat.bold -> use_bold:   boolean  "NO DESCRIPTION"
+ * TextCharacterFormat.italic -> use_italic:   boolean  "NO DESCRIPTION"
+ * TextCharacterFormat.use_small_caps -> use_small_caps:   boolean  "NO DESCRIPTION"
+ * TextCharacterFormat.underline -> use_underline:   boolean  "NO DESCRIPTION"
+ * TextLine.body -> body:   string  "Text in the line"
+ * TextMarker.end -> character_index_end:   int,  "(read-only)    Start position of the marker in the line"
+ * TextMarker.start -> character_index_start:   int,  "(read-only)    Start position of the marker in the line"
+ * TextMarker.color -> color:   float[4]  "Color to display the marker with"
+ * TextMarker.group -> group:   int,  "(read-only)"
+ * TextMarker.temporary -> is_temporary:   boolean,  "(read-only)    Marker is temporary"
+ * TextMarker.line -> line:   int,  "(read-only)    Line in which the marker is located"
+ * TextMarker.edit_all -> use_edit_all:   boolean,  "(read-only)    Edit all markers of the same group as one"
+ * TextureSlot.blend_type -> blend_type:   enum  "NO DESCRIPTION"
+ * TextureSlot.color -> color:   float[3]  "The default color for textures that dont return RGB"
+ * TextureSlot.default_value -> default_value:   float  "Value to use for Ref, Spec, Amb, Emit, Alpha, RayMir, TransLu and Hard"
+ * TextureSlot.negate -> invert:   boolean  "Inverts the values of the texture to reverse its effect"
+ * TextureSlot.name -> name:   string,  "(read-only)    Texture slot name"
+ * TextureSlot.offset -> offset:   float[3]  "Fine tunes texture mapping X, Y and Z locations"
+ * TextureSlot.output_node -> output_node:   enum  "Which output node to use, for node-based textures"
+ * TextureSlot.size -> scale:   float[3]  "Sets scaling for the textures X, Y and Z sizes"
+ * TextureSlot.texture -> texture:   pointer  "Texture datablock used by this texture slot"
+ * TextureSlot.rgb_to_intensity -> use_rgb_to_intensity:   boolean  "Converts texture RGB values to intensity (gray) values"
+ * TextureSlot.stencil -> use_stencil:   boolean  "Use this texture as a blending value on the next texture"
+ * TextureSlot|BrushTextureSlot.angle -> angle:   float  "Defines brush texture rotation"
+ * TextureSlot|BrushTextureSlot.map_mode -> map_mode:   enum  "NO DESCRIPTION"
+ * TextureSlot|LampTextureSlot.color_factor -> color_factor:   float  "Amount texture affects color values"
+ * TextureSlot|LampTextureSlot.object -> object:   pointer  "Object to use for mapping with Object texture coordinates"
+ * TextureSlot|LampTextureSlot.shadow_factor -> shadow_factor:   float  "Amount texture affects shadow"
+ * TextureSlot|LampTextureSlot.texture_coordinates -> texture_coords:   enum  "NO DESCRIPTION"
+ * TextureSlot|LampTextureSlot.map_color -> use_map_color:   boolean  "Lets the texture affect the basic color of the lamp"
+ * TextureSlot|LampTextureSlot.map_shadow -> use_map_shadow:   boolean  "Lets the texture affect the shadow color of the lamp"
+ * TextureSlot|MaterialTextureSlot.alpha_factor -> alpha_factor:   float  "Amount texture affects alpha"
+ * TextureSlot|MaterialTextureSlot.ambient_factor -> ambient_factor:   float  "Amount texture affects ambient"
+ * TextureSlot|MaterialTextureSlot.coloremission_factor -> color_emission_factor:   float  "Amount texture affects emission color"
+ * TextureSlot|MaterialTextureSlot.density_factor -> density_factor:   float  "Amount texture affects density"
+ * TextureSlot|MaterialTextureSlot.colordiff_factor -> diffuse_color_factor:   float  "Amount texture affects diffuse color"
+ * TextureSlot|MaterialTextureSlot.diffuse_factor -> diffuse_factor:   float  "Amount texture affects diffuse reflectivity"
+ * TextureSlot|MaterialTextureSlot.displacement_factor -> displacement_factor:   float  "Amount texture displaces the surface"
+ * TextureSlot|MaterialTextureSlot.emission_factor -> emission_factor:   float  "Amount texture affects emission"
+ * TextureSlot|MaterialTextureSlot.emit_factor -> emit_factor:   float  "Amount texture affects emission"
+ * TextureSlot|MaterialTextureSlot.hardness_factor -> hard_factor:   float  "Amount texture affects hardness"
+ * TextureSlot|MaterialTextureSlot.mapping -> mapping:   enum  "NO DESCRIPTION"
+ * TextureSlot|MaterialTextureSlot.x_mapping -> mapping_x:   enum  "NO DESCRIPTION"
+ * TextureSlot|MaterialTextureSlot.y_mapping -> mapping_y:   enum  "NO DESCRIPTION"
+ * TextureSlot|MaterialTextureSlot.z_mapping -> mapping_z:   enum  "NO DESCRIPTION"
+ * TextureSlot|MaterialTextureSlot.mirror_factor -> mirror_factor:   float  "Amount texture affects mirror color"
+ * TextureSlot|MaterialTextureSlot.normal_factor -> normal_factor:   float  "Amount texture affects normal values"
+ * TextureSlot|MaterialTextureSlot.normal_map_space -> normal_map_space:   enum  "NO DESCRIPTION"
+ * TextureSlot|MaterialTextureSlot.object -> object:   pointer  "Object to use for mapping with Object texture coordinates"
+ * TextureSlot|MaterialTextureSlot.raymir_factor -> raymir_factor:   float  "Amount texture affects ray mirror"
+ * TextureSlot|MaterialTextureSlot.colorreflection_factor -> reflection_color_factor:   float  "Amount texture affects color of out-scattered light"
+ * TextureSlot|MaterialTextureSlot.reflection_factor -> reflection_factor:   float  "Amount texture affects brightness of out-scattered light"
+ * TextureSlot|MaterialTextureSlot.scattering_factor -> scattering_factor:   float  "Amount texture affects scattering"
+ * TextureSlot|MaterialTextureSlot.colorspec_factor -> specular_color_factor:   float  "Amount texture affects specular color"
+ * TextureSlot|MaterialTextureSlot.specular_factor -> specular_factor:   float  "Amount texture affects specular reflectivity"
+ * TextureSlot|MaterialTextureSlot.texture_coordinates -> texture_coords:   enum  "NO DESCRIPTION"
+ * TextureSlot|MaterialTextureSlot.translucency_factor -> translucency_factor:   float  "Amount texture affects translucency"
+ * TextureSlot|MaterialTextureSlot.colortransmission_factor -> transmission_color_factor:   float  "Amount texture affects result color after light has been scattered/absorbed"
+ * TextureSlot|MaterialTextureSlot.enabled -> use:   boolean  "Enable this material texture slot"
+ * TextureSlot|MaterialTextureSlot.from_dupli -> use_from_dupli:   boolean  "Duplis instanced from verts, faces or particles, inherit texture coordinate from their parent"
+ * TextureSlot|MaterialTextureSlot.from_original -> use_from_original:   boolean  "Duplis derive their object coordinates from the original objects transformation"
+ * TextureSlot|MaterialTextureSlot.map_alpha -> use_map_alpha:   boolean  "Causes the texture to affect the alpha value"
+ * TextureSlot|MaterialTextureSlot.map_ambient -> use_map_ambient:   boolean  "Causes the texture to affect the value of ambient"
+ * TextureSlot|MaterialTextureSlot.map_colordiff -> use_map_color_diff:   boolean  "Causes the texture to affect basic color of the material"
+ * TextureSlot|MaterialTextureSlot.map_coloremission -> use_map_color_emission:   boolean  "Causes the texture to affect the color of emission"
+ * TextureSlot|MaterialTextureSlot.map_colorreflection -> use_map_color_reflection:   boolean  "Causes the texture to affect the color of scattered light"
+ * TextureSlot|MaterialTextureSlot.map_colorspec -> use_map_color_spec:   boolean  "Causes the texture to affect the specularity color"
+ * TextureSlot|MaterialTextureSlot.map_colortransmission -> use_map_color_transmission:   boolean  "Causes the texture to affect the result color after other light has been scattered/absorbed"
+ * TextureSlot|MaterialTextureSlot.map_density -> use_map_density:   boolean  "Causes the texture to affect the volumes density"
+ * TextureSlot|MaterialTextureSlot.map_diffuse -> use_map_diffuse:   boolean  "Causes the texture to affect the value of the materials diffuse reflectivity"
+ * TextureSlot|MaterialTextureSlot.map_displacement -> use_map_displacement:   boolean  "Let the texture displace the surface"
+ * TextureSlot|MaterialTextureSlot.map_emission -> use_map_emission:   boolean  "Causes the texture to affect the volumes emission"
+ * TextureSlot|MaterialTextureSlot.map_emit -> use_map_emit:   boolean  "Causes the texture to affect the emit value"
+ * TextureSlot|MaterialTextureSlot.map_hardness -> use_map_hardness:   boolean  "Causes the texture to affect the hardness value"
+ * TextureSlot|MaterialTextureSlot.map_mirror -> use_map_mirror:   boolean  "Causes the texture to affect the mirror color"
+ * TextureSlot|MaterialTextureSlot.map_normal -> use_map_normal:   boolean  "Causes the texture to affect the rendered normal"
+ * TextureSlot|MaterialTextureSlot.map_raymir -> use_map_raymir:   boolean  "Causes the texture to affect the ray-mirror value"
+ * TextureSlot|MaterialTextureSlot.map_reflection -> use_map_reflect:   boolean  "Causes the texture to affect the reflected lights brightness"
+ * TextureSlot|MaterialTextureSlot.map_scattering -> use_map_scatter:   boolean  "Causes the texture to affect the volumes scattering"
+ * TextureSlot|MaterialTextureSlot.map_specular -> use_map_specular:   boolean  "Causes the texture to affect the value of specular reflectivity"
+ * TextureSlot|MaterialTextureSlot.map_translucency -> use_map_translucency:   boolean  "Causes the texture to affect the translucency value"
+ * TextureSlot|MaterialTextureSlot.map_warp -> use_map_warp:   boolean  "Let the texture warp texture coordinates of next channels"
+NEGATE * TextureSlot|MaterialTextureSlot.new_bump -> use_old_bump:   boolean  "Use new, corrected bump mapping code (backwards compatibility option)"
+ * TextureSlot|MaterialTextureSlot.uv_layer -> uv_layer:   string  "UV layer to use for mapping with UV texture coordinates"
+ * TextureSlot|MaterialTextureSlot.warp_factor -> warp_factor:   float  "Amount texture affects texture coordinates of next channels"
+ * TextureSlot|WorldTextureSlot.blend_factor -> blend_factor:   float  "Amount texture affects color progression of the background"
+ * TextureSlot|WorldTextureSlot.horizon_factor -> horizon_factor:   float  "Amount texture affects color of the horizon"
+ * TextureSlot|WorldTextureSlot.object -> object:   pointer  "Object to use for mapping with Object texture coordinates"
+ * TextureSlot|WorldTextureSlot.texture_coordinates -> texture_coords:   enum  "Texture coordinates used to map the texture onto the background"
+ * TextureSlot|WorldTextureSlot.map_blend -> use_map_blend:   boolean  "Affect the color progression of the background"
+ * TextureSlot|WorldTextureSlot.map_horizon -> use_map_horizon:   boolean  "Affect the color of the horizon"
+ * TextureSlot|WorldTextureSlot.map_zenith_down -> use_map_zenith_down:   boolean  "Affect the color of the zenith below"
+ * TextureSlot|WorldTextureSlot.map_zenith_up -> use_map_zenith_up:   boolean  "Affect the color of the zenith above"
+ * TextureSlot|WorldTextureSlot.zenith_down_factor -> zenith_down_factor:   float  "Amount texture affects color of the zenith below"
+ * TextureSlot|WorldTextureSlot.zenith_up_factor -> zenith_up_factor:   float  "Amount texture affects color of the zenith above"
+ * Theme.bone_color_sets -> bone_color_sets:   collection,  "(read-only)"
+ * Theme.console -> console:   pointer,  "(read-only)"
+ * Theme.dopesheet_editor -> dopesheet_editor:   pointer,  "(read-only)"
+ * Theme.file_browser -> file_browser:   pointer,  "(read-only)"
+ * Theme.graph_editor -> graph_editor:   pointer,  "(read-only)"
+ * Theme.image_editor -> image_editor:   pointer,  "(read-only)"
+ * Theme.info -> info:   pointer,  "(read-only)"
+ * Theme.logic_editor -> logic_editor:   pointer,  "(read-only)"
+ * Theme.name -> name:   string  "Name of the theme"
+ * Theme.nla_editor -> nla_editor:   pointer,  "(read-only)"
+ * Theme.node_editor -> node_editor:   pointer,  "(read-only)"
+ * Theme.outliner -> outliner:   pointer,  "(read-only)"
+ * Theme.properties -> properties:   pointer,  "(read-only)"
+ * Theme.sequence_editor -> sequence_editor:   pointer,  "(read-only)"
+ * Theme.text_editor -> text_editor:   pointer,  "(read-only)"
+ * Theme.theme_area -> theme_area:   enum  "NO DESCRIPTION"
+ * Theme.timeline -> timeline:   pointer,  "(read-only)"
+ * Theme.user_interface -> user_interface:   pointer,  "(read-only)"
+ * Theme.user_preferences -> user_preferences:   pointer,  "(read-only)"
+ * Theme.view_3d -> view_3d:   pointer,  "(read-only)"
+ * ThemeAudioWindow.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.grid -> grid:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeAudioWindow.window_sliders -> window_sliders:   float[3]  "NO DESCRIPTION"
+ * ThemeBoneColorSet.active -> active:   float[3]  "Color used for active bones"
+ * ThemeBoneColorSet.normal -> normal:   float[3]  "Color used for the surface of bones"
+ * ThemeBoneColorSet.select -> select:   float[3]  "Color used for selected bones"
+ * ThemeBoneColorSet.colored_constraints -> show_colored_constraints:   boolean  "Allow the use of colors indicating constraints/keyed status"
+ * ThemeConsole.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.cursor -> cursor:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.line_error -> line_error:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.line_info -> line_info:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.line_input -> line_input:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.line_output -> line_output:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeConsole.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.active_channels_group -> active_channels_group:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.channel_group -> channel_group:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.channels -> channels:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.channels_selected -> channels_selected:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.dopesheet_channel -> dopesheet_channel:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.dopesheet_subchannel -> dopesheet_subchannel:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.grid -> grid:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.list -> list:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.list_text -> list_text:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.list_text_hi -> list_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.list_title -> list_title:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.long_key -> long_key:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.long_key_selected -> long_key_selected:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.value_sliders -> value_sliders:   float[3]  "NO DESCRIPTION"
+ * ThemeDopeSheet.view_sliders -> view_sliders:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.active_file -> active_file:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.active_file_text -> active_file_text:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.list -> list:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.list_text -> list_text:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.list_text_hi -> list_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.list_title -> list_title:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.scroll_handle -> scroll_handle:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.scrollbar -> scrollbar:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.selected_file -> selected_file:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.tiles -> tiles:   float[3]  "NO DESCRIPTION"
+ * ThemeFileBrowser.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeFontStyle.font_kerning_style -> font_kerning_style:   enum  "Which style to use for font kerning"
+ * ThemeFontStyle.points -> points:   int  "NO DESCRIPTION"
+ * ThemeFontStyle.shadow -> shadow:   int  "Shadow size in pixels (0, 3 and 5 supported)"
+ * ThemeFontStyle.shadx -> shadow_offset_x:   int  "Shadow offset in pixels"
+ * ThemeFontStyle.shady -> shadow_offset_y:   int  "Shadow offset in pixels"
+ * ThemeFontStyle.shadowalpha -> shadowalpha:   float  "NO DESCRIPTION"
+ * ThemeFontStyle.shadowcolor -> shadowcolor:   float  "Shadow color in grey value"
+ * ThemeGraphEditor.active_channels_group -> active_channels_group:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.channel_group -> channel_group:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.channels_region -> channels_region:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.dopesheet_channel -> dopesheet_channel:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.dopesheet_subchannel -> dopesheet_subchannel:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.grid -> grid:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_align -> handle_align:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_auto -> handle_auto:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_free -> handle_free:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_sel_align -> handle_sel_align:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_sel_auto -> handle_sel_auto:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_sel_free -> handle_sel_free:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_sel_vect -> handle_sel_vect:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_vect -> handle_vect:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_vertex -> handle_vertex:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_vertex_select -> handle_vertex_select:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.handle_vertex_size -> handle_vertex_size:   int  "NO DESCRIPTION"
+ * ThemeGraphEditor.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.lastsel_point -> lastsel_point:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.list -> list:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.list_text -> list_text:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.list_text_hi -> list_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.list_title -> list_title:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.panel -> panel:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.vertex -> vertex:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.vertex_select -> vertex_select:   float[3]  "NO DESCRIPTION"
+ * ThemeGraphEditor.vertex_size -> vertex_size:   int  "NO DESCRIPTION"
+ * ThemeGraphEditor.window_sliders -> window_sliders:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.editmesh_active -> editmesh_active:   float[4]  "NO DESCRIPTION"
+ * ThemeImageEditor.face -> face:   float[4]  "NO DESCRIPTION"
+ * ThemeImageEditor.face_dot -> face_dot:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.face_select -> face_select:   float[4]  "NO DESCRIPTION"
+ * ThemeImageEditor.facedot_size -> facedot_size:   int  "NO DESCRIPTION"
+ * ThemeImageEditor.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.scope_back -> scope_back:   float[4]  "NO DESCRIPTION"
+ * ThemeImageEditor.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.vertex -> vertex:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.vertex_select -> vertex_select:   float[3]  "NO DESCRIPTION"
+ * ThemeImageEditor.vertex_size -> vertex_size:   int  "NO DESCRIPTION"
+ * ThemeInfo.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeInfo.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeInfo.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeInfo.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeInfo.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeInfo.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeInfo.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeInfo.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeInfo.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeInfo.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeInfo.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.panel -> panel:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeLogicEditor.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.bars -> bars:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.bars_selected -> bars_selected:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.grid -> grid:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.list -> list:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.list_text -> list_text:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.list_text_hi -> list_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.list_title -> list_title:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.strips -> strips:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.strips_selected -> strips_selected:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeNLAEditor.view_sliders -> view_sliders:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.converter_node -> converter_node:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.group_node -> group_node:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.in_out_node -> in_out_node:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.list -> list:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.list_text -> list_text:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.list_text_hi -> list_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.list_title -> list_title:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.node_backdrop -> node_backdrop:   float[4]  "NO DESCRIPTION"
+ * ThemeNodeEditor.operator_node -> operator_node:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.selected_text -> selected_text:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.wires -> wire:   float[3]  "NO DESCRIPTION"
+ * ThemeNodeEditor.wire_select -> wire_select:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeOutliner.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.panel -> panel:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeProperties.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.audio_strip -> audio_strip:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.draw_action -> draw_action:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.effect_strip -> effect_strip:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.grid -> grid:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.image_strip -> image_strip:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.keyframe -> keyframe:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.meta_strip -> meta_strip:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.movie_strip -> movie_strip:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.plugin_strip -> plugin_strip:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.scene_strip -> scene_strip:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.transition_strip -> transition_strip:   float[3]  "NO DESCRIPTION"
+ * ThemeSequenceEditor.window_sliders -> window_sliders:   float[3]  "NO DESCRIPTION"
+ * ThemeStyle.grouplabel -> group_label:   pointer,  "(read-only)"
+ * ThemeStyle.paneltitle -> panel_title:   pointer,  "(read-only)"
+ * ThemeStyle.panelzoom -> panelzoom:   float  "Default zoom level for panel areas"
+ * ThemeStyle.widget -> widget:   pointer,  "(read-only)"
+ * ThemeStyle.widgetlabel -> widget_label:   pointer,  "(read-only)"
+ * ThemeTextEditor.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.cursor -> cursor:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.line_numbers_background -> line_numbers_background:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.scroll_bar -> scroll_bar:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.selected_text -> selected_text:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.syntax_builtin -> syntax_builtin:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.syntax_comment -> syntax_comment:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.syntax_numbers -> syntax_numbers:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.syntax_special -> syntax_special:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.syntax_string -> syntax_string:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeTextEditor.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.grid -> grid:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeTimeline.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeUserInterface.icon_file -> icon_file:   string  "NO DESCRIPTION"
+ * ThemeUserInterface.wcol_box -> wcol_box:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_list_item -> wcol_list_item:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_menu -> wcol_menu:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_menu_back -> wcol_menu_back:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_menu_item -> wcol_menu_item:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_num -> wcol_num:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_numslider -> wcol_numslider:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_option -> wcol_option:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_progress -> wcol_progress:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_pulldown -> wcol_pulldown:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_radio -> wcol_radio:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_regular -> wcol_regular:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_scroll -> wcol_scroll:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_state -> wcol_state:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_text -> wcol_text:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_toggle -> wcol_toggle:   pointer,  "(read-only)"
+ * ThemeUserInterface.wcol_tool -> wcol_tool:   pointer,  "(read-only)"
+ * ThemeUserPreferences.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeUserPreferences.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeUserPreferences.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeUserPreferences.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeUserPreferences.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeUserPreferences.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeUserPreferences.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeUserPreferences.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeUserPreferences.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeUserPreferences.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeUserPreferences.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.act_spline -> act_spline:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.back -> back:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.bone_pose -> bone_pose:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.bone_solid -> bone_solid:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.button -> button:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.button_text -> button_text:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.button_title -> button_title:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.edge_crease -> edge_crease:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.edge_facesel -> edge_facesel:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.edge_seam -> edge_seam:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.edge_select -> edge_select:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.edge_sharp -> edge_sharp:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.editmesh_active -> editmesh_active:   float[4]  "NO DESCRIPTION"
+ * ThemeView3D.face -> face:   float[4]  "NO DESCRIPTION"
+ * ThemeView3D.face_dot -> face_dot:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.face_select -> face_select:   float[4]  "NO DESCRIPTION"
+ * ThemeView3D.facedot_size -> facedot_size:   int  "NO DESCRIPTION"
+ * ThemeView3D.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.grid -> grid:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.handle_align -> handle_align:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.handle_auto -> handle_auto:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.handle_free -> handle_free:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.handle_sel_align -> handle_sel_align:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.handle_sel_auto -> handle_sel_auto:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.handle_sel_free -> handle_sel_free:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.handle_sel_vect -> handle_sel_vect:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.handle_vect -> handle_vect:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.header -> header:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.header_text -> header_text:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.lamp -> lamp:   float[4]  "NO DESCRIPTION"
+ * ThemeView3D.lastsel_point -> lastsel_point:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.normal -> normal:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.nurb_sel_uline -> nurb_sel_uline:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.nurb_sel_vline -> nurb_sel_vline:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.nurb_uline -> nurb_uline:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.nurb_vline -> nurb_vline:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.object_active -> object_active:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.object_grouped -> object_grouped:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.object_grouped_active -> object_grouped_active:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.object_selected -> object_selected:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.panel -> panel:   float[4]  "NO DESCRIPTION"
+ * ThemeView3D.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.title -> title:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.transform -> transform:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.vertex -> vertex:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.vertex_normal -> vertex_normal:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.vertex_select -> vertex_select:   float[3]  "NO DESCRIPTION"
+ * ThemeView3D.vertex_size -> vertex_size:   int  "NO DESCRIPTION"
+ * ThemeView3D.wire -> wire:   float[3]  "NO DESCRIPTION"
+ * ThemeWidgetColors.inner -> inner:   float[4]  "NO DESCRIPTION"
+ * ThemeWidgetColors.inner_sel -> inner_sel:   float[4]  "NO DESCRIPTION"
+ * ThemeWidgetColors.item -> item:   float[4]  "NO DESCRIPTION"
+ * ThemeWidgetColors.outline -> outline:   float[3]  "NO DESCRIPTION"
+ * ThemeWidgetColors.shadedown -> shadedown:   int  "NO DESCRIPTION"
+ * ThemeWidgetColors.shadetop -> shadetop:   int  "NO DESCRIPTION"
+ * ThemeWidgetColors.shaded -> show_shaded:   boolean  "NO DESCRIPTION"
+ * ThemeWidgetColors.text -> text:   float[3]  "NO DESCRIPTION"
+ * ThemeWidgetColors.text_sel -> text_sel:   float[3]  "NO DESCRIPTION"
+ * ThemeWidgetStateColors.blend -> blend:   float  "NO DESCRIPTION"
+ * ThemeWidgetStateColors.inner_anim -> inner_anim:   float[3]  "NO DESCRIPTION"
+ * ThemeWidgetStateColors.inner_anim_sel -> inner_anim_sel:   float[3]  "NO DESCRIPTION"
+ * ThemeWidgetStateColors.inner_driven -> inner_driven:   float[3]  "NO DESCRIPTION"
+ * ThemeWidgetStateColors.inner_driven_sel -> inner_driven_sel:   float[3]  "NO DESCRIPTION"
+ * ThemeWidgetStateColors.inner_key -> inner_key:   float[3]  "NO DESCRIPTION"
+ * ThemeWidgetStateColors.inner_key_sel -> inner_key_sel:   float[3]  "NO DESCRIPTION"
+ * TimelineMarker.camera -> camera:   pointer  "Camera this timeline sets to active"
+ * TimelineMarker.frame -> frame:   int  "The frame on which the timeline marker appears"
+ * TimelineMarker.name -> name:   string  "NO DESCRIPTION"
+ * TimelineMarker.select -> select:   boolean  "Marker selection state"
+ * ToolSettings.autokey_mode -> auto_keying_mode:   enum  "Mode of automatic keyframe insertion for Objects and Bones"
+ * ToolSettings.edge_path_mode -> edge_path_mode:   enum  "The edge flag to tag when selecting the shortest path"
+ * ToolSettings.etch_adaptive_limit -> etch_adaptive_limit:   float  "Number of bones in the subdivided stroke"
+ * ToolSettings.etch_convert_mode -> etch_convert_mode:   enum  "Method used to convert stroke to bones"
+ * ToolSettings.etch_length_limit -> etch_length_limit:   float  "Number of bones in the subdivided stroke"
+ * ToolSettings.etch_number -> etch_number:   string  "DOC BROKEN"
+ * ToolSettings.etch_roll_mode -> etch_roll_mode:   enum  "Method used to adjust the roll of bones when retargeting"
+ * ToolSettings.etch_side -> etch_side:   string  "DOC BROKEN"
+ * ToolSettings.etch_subdivision_number -> etch_subdivision_number:   int  "Number of bones in the subdivided stroke"
+ * ToolSettings.etch_template -> etch_template:   pointer  "Template armature that will be retargeted to the stroke"
+ * ToolSettings.image_paint -> image_paint:   pointer,  "(read-only)"
+ * ToolSettings.mesh_selection_mode -> mesh_select_mode:   boolean[3]  "Which mesh elements selection works on"
+ * ToolSettings.normal_size -> normal_size:   float  "Display size for normals in the 3D view"
+ * ToolSettings.particle_edit -> particle_edit:   pointer,  "(read-only)"
+ * ToolSettings.proportional_editing -> proportional_edit:   enum  "Proportional editing mode"
+ * ToolSettings.proportional_editing_falloff -> proportional_edit_falloff:   enum  "Falloff type for proportional editing mode"
+ * ToolSettings.sculpt -> sculpt:   pointer,  "(read-only)"
+ * ToolSettings.sculpt_paint_use_unified_size -> sculpt_paint_use_unified_size:   boolean  "Instead of per brush radius, the radius is shared across brushes"
+ * ToolSettings.sculpt_paint_use_unified_strength -> sculpt_paint_use_unified_strength:   boolean  "Instead of per brush strength, the strength is shared across brushes"
+ * ToolSettings.uv_local_view -> show_uv_local_view:   boolean  "Draw only faces with the currently displayed image assigned"
+ * ToolSettings.snap_element -> snap_element:   enum  "Type of element to snap to"
+ * ToolSettings.snap_target -> snap_target:   enum  "Which part to snap onto the target"
+ * ToolSettings.auto_normalize -> use_auto_normalize:   boolean  "Ensure all bone-deforming vertex groups add up to 1.0 while weight painting"
+ * ToolSettings.bone_sketching -> use_bone_sketching:   boolean  "DOC BROKEN"
+ * ToolSettings.etch_autoname -> use_etch_autoname:   boolean  "DOC BROKEN"
+ * ToolSettings.etch_overdraw -> use_etch_overdraw:   boolean  "DOC BROKEN"
+ * ToolSettings.etch_quick -> use_etch_quick:   boolean  "DOC BROKEN"
+ * ToolSettings.use_auto_keying -> use_keyframe_insert_auto:   boolean  "Automatic keyframe insertion for Objects and Bones"
+ * ToolSettings.automerge_editing -> use_mesh_automerge:   boolean  "Automatically merge vertices moved to the same location"
+ * ToolSettings.proportional_editing_objects -> use_proportional_edit_objects:   boolean  "Proportional editing object mode"
+ * ToolSettings.record_with_nla -> use_record_with_nla:   boolean  "Add a new NLA Track + Strip for every loop/pass made over the animation to allow non-destructive tweaking"
+ * ToolSettings.snap -> use_snap:   boolean  "Snap during transform"
+ * ToolSettings.snap_align_rotation -> use_snap_align_rotation:   boolean  "Align rotation with the snapping target"
+ * ToolSettings.snap_peel_object -> use_snap_peel_object:   boolean  "Consider objects as whole when finding volume center"
+ * ToolSettings.snap_project -> use_snap_project:   boolean  "Project vertices on the surface of other objects"
+ * ToolSettings.uv_sync_selection -> use_uv_select_sync:   boolean  "Keep UV and edit mode mesh selection in sync"
+ * ToolSettings.uv_selection_mode -> uv_select_mode:   enum  "UV selection and display mode"
+ * ToolSettings.vertex_group_weight -> vertex_group_weight:   float  "Weight to assign in vertex groups"
+ * ToolSettings.vertex_paint -> vertex_paint:   pointer,  "(read-only)"
+ * ToolSettings.weight_paint -> weight_paint:   pointer,  "(read-only)"
+ * TransformOrientation.matrix -> matrix:   float[9]  "NO DESCRIPTION"
+ * TransformOrientation.name -> name:   string  "NO DESCRIPTION"
+ * UILayout.alignment -> alignment:   enum  "NO DESCRIPTION"
+ * UILayout.operator_context -> operator_context:   enum  "NO DESCRIPTION"
+ * UILayout.scale_x -> scale_x:   float  "Scale factor along the X for items in this (sub)layout."
+ * UILayout.scale_y -> scale_y:   float  "Scale factor along the Y for items in this (sub)layout."
+ * UILayout.active -> show_active:   boolean  "NO DESCRIPTION"
+ * UILayout.enabled -> show_enabled:   boolean  "When false, this (sub)layout is greyed out."
+ * UVProjector.object -> object:   pointer  "Object to use as projector transform"
+ * UnitSettings.rotation_units -> rotation_units:   enum  "Unit to use for displaying/editing rotation values"
+ * UnitSettings.scale_length -> scale_length:   float  "Scale to use when converting between blender units and dimensions"
+ * UnitSettings.system -> system:   enum  "The unit system to use for button display"
+ * UnitSettings.use_separate -> use_separate:   boolean  "Display units in pairs"
+ * UserPreferences.active_section -> active_section:   enum  "Active section of the user preferences shown in the user interface"
+ * UserPreferences.addons -> addons:   collection,  "(read-only)"
+ * UserPreferences.edit -> edit:   pointer,  "(read-only)    Settings for interacting with Blender data"
+ * UserPreferences.filepaths -> filepaths:   pointer,  "(read-only)    Default paths for external files"
+ * UserPreferences.inputs -> inputs:   pointer,  "(read-only)    Settings for input devices"
+ * UserPreferences.system -> system:   pointer,  "(read-only)    Graphics driver and operating system settings"
+ * UserPreferences.themes -> themes:   collection,  "(read-only)"
+ * UserPreferences.uistyles -> ui_styles:   collection,  "(read-only)"
+ * UserPreferences.view -> view:   pointer,  "(read-only)    Preferences related to viewing data"
+ * UserPreferencesEdit.auto_keying_mode -> auto_keying_mode:   enum  "Mode of automatic keyframe insertion for Objects and Bones"
+ * UserPreferencesEdit.grease_pencil_eraser_radius -> grease_pencil_eraser_radius:   int  "Radius of eraser brush"
+ * UserPreferencesEdit.grease_pencil_euclidean_distance -> grease_pencil_euclidean_distance:   int  "Distance moved by mouse when drawing stroke (in pixels) to include"
+ * UserPreferencesEdit.grease_pencil_manhattan_distance -> grease_pencil_manhattan_distance:   int  "Pixels moved by mouse per axis when drawing stroke"
+ * UserPreferencesEdit.keyframe_new_handle_type -> keyframe_new_handle_type:   enum  "NO DESCRIPTION"
+ * UserPreferencesEdit.keyframe_new_interpolation_type -> keyframe_new_interpolation_type:   enum  "NO DESCRIPTION"
+ * UserPreferencesEdit.material_link -> material_link:   enum  "Toggle whether the material is linked to object data or the object block"
+ * UserPreferencesEdit.object_align -> object_align:   enum  "When adding objects from a 3D View menu, either align them to that views direction or the world coordinates"
+ * UserPreferencesEdit.sculpt_paint_overlay_col -> sculpt_paint_overlay_color:   float[3]  "Color of texture overlay"
+ * UserPreferencesEdit.undo_memory_limit -> undo_memory_limit:   int  "Maximum memory usage in megabytes (0 means unlimited)"
+ * UserPreferencesEdit.undo_steps -> undo_steps:   int  "Number of undo steps available (smaller values conserve memory)"
+ * UserPreferencesEdit.use_auto_keying -> use_auto_keying:   boolean  "Automatic keyframe insertion for Objects and Bones"
+ * UserPreferencesEdit.drag_immediately -> use_drag_immediately:   boolean  "Moving things with a mouse drag confirms when releasing the button"
+ * UserPreferencesEdit.duplicate_action -> use_duplicate_action:   boolean  "Causes actions to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_armature -> use_duplicate_armature:   boolean  "Causes armature data to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_curve -> use_duplicate_curve:   boolean  "Causes curve data to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_fcurve -> use_duplicate_fcurve:   boolean  "Causes F-curve data to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_lamp -> use_duplicate_lamp:   boolean  "Causes lamp data to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_material -> use_duplicate_material:   boolean  "Causes material data to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_mesh -> use_duplicate_mesh:   boolean  "Causes mesh data to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_metaball -> use_duplicate_metaball:   boolean  "Causes metaball data to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_particle -> use_duplicate_particle:   boolean  "Causes particle systems to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_surface -> use_duplicate_surface:   boolean  "Causes surface data to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_text -> use_duplicate_text:   boolean  "Causes text data to be duplicated with the object"
+ * UserPreferencesEdit.duplicate_texture -> use_duplicate_texture:   boolean  "Causes texture data to be duplicated with the object"
+ * UserPreferencesEdit.enter_edit_mode -> use_enter_edit_mode:   boolean  "Enter Edit Mode automatically after adding a new object"
+ * UserPreferencesEdit.global_undo -> use_global_undo:   boolean  "Global undo works by keeping a full copy of the file itself in memory, so takes extra memory"
+ * UserPreferencesEdit.grease_pencil_simplify_stroke -> use_grease_pencil_simplify_stroke:   boolean  "Simplify the final stroke"
+ * UserPreferencesEdit.grease_pencil_smooth_stroke -> use_grease_pencil_smooth_stroke:   boolean  "Smooth the final stroke"
+ * UserPreferencesEdit.insertkey_xyz_to_rgb -> use_insertkey_xyz_to_rgb:   boolean  "Color for newly added transformation F-Curves (Location, Rotation, Scale) and also Color is based on the transform axis"
+ * UserPreferencesEdit.auto_keyframe_insert_available -> use_keyframe_insert_available:   boolean  "Automatic keyframe insertion in available curves"
+ * UserPreferencesEdit.auto_keyframe_insert_keyingset -> use_keyframe_insert_keyingset:   boolean  "Automatic keyframe insertion using active Keying Set"
+ * UserPreferencesEdit.keyframe_insert_needed -> use_keyframe_insert_needed:   boolean  "Keyframe insertion only when keyframe needed"
+ * UserPreferencesEdit.use_negative_frames -> use_negative_frames:   boolean  "Current frame number can be manually set to a negative value"
+ * UserPreferencesEdit.use_visual_keying -> use_visual_keying:   boolean  "Use Visual keying automatically for constrained objects"
+ * UserPreferencesFilePaths.animation_player -> animation_player:   string  "Path to a custom animation/frame sequence player"
+ * UserPreferencesFilePaths.animation_player_preset -> animation_player_preset:   enum  "Preset configs for external animation players"
+ * UserPreferencesFilePaths.auto_save_time -> auto_save_time:   int  "The time (in minutes) to wait between automatic temporary saves"
+ * UserPreferencesFilePaths.fonts_directory -> font_directory:   string  "The default directory to search for loading fonts"
+ * UserPreferencesFilePaths.image_editor -> image_editor:   string  "Path to an image editor"
+ * UserPreferencesFilePaths.recent_files -> recent_files:   int  "Maximum number of recently opened files to remember"
+ * UserPreferencesFilePaths.render_output_directory -> render_output_directory:   string  "The default directory for rendering output"
+ * UserPreferencesFilePaths.save_version -> save_version:   int  "The number of old versions to maintain in the current directory, when manually saving"
+ * UserPreferencesFilePaths.python_scripts_directory -> script_directory:   string  "The default directory to search for Python scripts (resets python module search path: sys.path)"
+ * UserPreferencesFilePaths.sequence_plugin_directory -> sequence_plugin_directory:   string  "The default directory to search for sequence plugins"
+ * UserPreferencesFilePaths.hide_dot_files_datablocks -> show_hidden_files_datablocks:   boolean  "Hide files/datablocks that start with a dot(.*)"
+ * UserPreferencesFilePaths.sounds_directory -> sound_directory:   string  "The default directory to search for sounds"
+ * UserPreferencesFilePaths.temporary_directory -> temporary_directory:   string  "The directory for storing temporary save files"
+ * UserPreferencesFilePaths.textures_directory -> texture_directory:   string  "The default directory to search for textures"
+ * UserPreferencesFilePaths.texture_plugin_directory -> texture_plugin_directory:   string  "The default directory to search for texture plugins"
+ * UserPreferencesFilePaths.auto_save_temporary_files -> use_auto_save_temporary_files:   boolean  "Automatic saving of temporary files"
+ * UserPreferencesFilePaths.compress_file -> use_file_compression:   boolean  "Enable file compression when saving .blend files"
+ * UserPreferencesFilePaths.filter_file_extensions -> use_filter_files:   boolean  "Display only files with extensions in the image select window"
+ * UserPreferencesFilePaths.load_ui -> use_load_ui:   boolean  "Load user interface setup when loading .blend files"
+ * UserPreferencesFilePaths.use_relative_paths -> use_relative_paths:   boolean  "Default relative path option for the file selector"
+ * UserPreferencesFilePaths.save_preview_images -> use_save_preview_images:   boolean  "Enables automatic saving of preview images in the .blend file"
+ * UserPreferencesInput.edited_keymaps -> edited_keymaps:   collection,  "(read-only)"
+ * UserPreferencesInput.invert_zoom_direction -> invert_mouse_wheel_zoom:   boolean  "Invert the axis of mouse movement for zooming"
+ * UserPreferencesInput.wheel_invert_zoom -> invert_zoom_wheel:   boolean  "Swap the Mouse Wheel zoom direction"
+ * UserPreferencesInput.double_click_time -> mouse_double_click_time:   int  "The time (in ms) for a double click"
+ * UserPreferencesInput.ndof_pan_speed -> ndof_pan_speed:   int  "The overall panning speed of an NDOF device, as percent of standard"
+ * UserPreferencesInput.ndof_rotate_speed -> ndof_rotate_speed:   int  "The overall rotation speed of an NDOF device, as percent of standard"
+ * UserPreferencesInput.select_mouse -> select_mouse:   enum  "The mouse button used for selection"
+ * UserPreferencesInput.emulate_numpad -> use_emulate_numpad:   boolean  "Causes the 1 to 0 keys to act as the numpad (useful for laptops)"
+ * UserPreferencesInput.continuous_mouse -> use_mouse_continuous:   boolean  "Allow moving the mouse outside the view on some manipulations (transform, ui control drag)"
+ * UserPreferencesInput.emulate_3_button_mouse -> use_mouse_emulate_3_button:   boolean  "Emulates Middle Mouse with Alt+LeftMouse (doesnt work with Left Mouse Select option)"
+ * UserPreferencesInput.use_middle_mouse_paste -> use_mouse_mmb_paste:   boolean  "In text window, paste with middle mouse button instead of panning"
+ * UserPreferencesInput.view_rotation -> view_rotate_method:   enum  "Rotation style in the viewport"
+ * UserPreferencesInput.zoom_axis -> view_zoom_axis:   enum  "Axis of mouse movement to zoom in or out on"
+ * UserPreferencesInput.zoom_style -> view_zoom_method:   enum  "Which style to use for viewport scaling"
+ * UserPreferencesInput.wheel_scroll_lines -> wheel_scroll_lines:   int  "The number of lines scrolled at a time with the mouse wheel"
+ * UserPreferencesSystem.audio_channels -> audio_channels:   enum  "Sets the audio channel count"
+ * UserPreferencesSystem.audio_device -> audio_device:   enum  "Sets the audio output device"
+ * UserPreferencesSystem.audio_mixing_buffer -> audio_mixing_buffer:   enum  "Sets the number of samples used by the audio mixing buffer"
+ * UserPreferencesSystem.audio_sample_format -> audio_sample_format:   enum  "Sets the audio sample format"
+ * UserPreferencesSystem.audio_sample_rate -> audio_sample_rate:   enum  "Sets the audio sample rate"
+ * UserPreferencesSystem.color_picker_type -> color_picker_type:   enum  "Different styles of displaying the color picker widget"
+ * UserPreferencesSystem.dpi -> dpi:   int  "Font size and resolution for display"
+ * UserPreferencesSystem.frame_server_port -> frame_server_port:   int  "Frameserver Port for Frameserver Rendering"
+ * UserPreferencesSystem.clip_alpha -> gl_clip_alpha:   float  "Clip alpha below this threshold in the 3D textured view"
+ * UserPreferencesSystem.gl_texture_limit -> gl_texture_limit:   enum  "Limit the texture size to save graphics memory"
+ * UserPreferencesSystem.language -> language:   enum  "Language use for translation"
+ * UserPreferencesSystem.memory_cache_limit -> memory_cache_limit:   int  "Memory cache limit in sequencer (megabytes)"
+ * UserPreferencesSystem.prefetch_frames -> prefetch_frames:   int  "Number of frames to render ahead during playback"
+ * UserPreferencesSystem.screencast_fps -> screencast_fps:   int  "Frame rate for the screencast to be played back"
+ * UserPreferencesSystem.screencast_wait_time -> screencast_wait_time:   int  "Time in milliseconds between each frame recorded for screencast"
+ * UserPreferencesSystem.scrollback -> scrollback:   int  "Maximum number of lines to store for the console buffer"
+ * UserPreferencesSystem.solid_lights -> solid_lights:   collection,  "(read-only)    Lights user to display objects in solid draw mode"
+ * UserPreferencesSystem.texture_collection_rate -> texture_collection_rate:   int  "Number of seconds between each run of the GL texture garbage collector"
+ * UserPreferencesSystem.texture_time_out -> texture_time_out:   int  "Time since last access of a GL texture in seconds after which it is freed. (Set to 0 to keep textures allocated.)"
+ * UserPreferencesSystem.use_antialiasing -> use_antialiasing:   boolean  "Use anti-aliasing for the 3D view (may impact redraw performance)"
+ * UserPreferencesSystem.international_fonts -> use_international_fonts:   boolean  "Use international fonts"
+ * UserPreferencesSystem.use_mipmaps -> use_mipmaps:   boolean  "Scale textures for the 3D View (looks nicer but uses more memory and slows image reloading)"
+ * UserPreferencesSystem.enable_all_codecs -> use_preview_images:   boolean  "Enables automatic saving of preview images in the .blend file (Windows only)"
+ * UserPreferencesSystem.auto_execute_scripts -> use_scripts_auto_execute:   boolean  "Allow any .blend file to run scripts automatically (unsafe with blend files from an untrusted source)"
+ * UserPreferencesSystem.tabs_as_spaces -> use_tabs_as_spaces:   boolean  "Automatically converts all new tabs into spaces for new and loaded text files"
+ * UserPreferencesSystem.use_textured_fonts -> use_textured_fonts:   boolean  "Use textures for drawing international fonts"
+ * UserPreferencesSystem.translate_buttons -> use_translate_buttons:   boolean  "Translate button labels"
+ * UserPreferencesSystem.translate_toolbox -> use_translate_toolbox:   boolean  "Translate toolbox menu"
+ * UserPreferencesSystem.translate_tooltips -> use_translate_tooltips:   boolean  "Translate Tooltips"
+ * UserPreferencesSystem.use_vbos -> use_vertex_buffer_objects:   boolean  "Use Vertex Buffer Objects (or Vertex Arrays, if unsupported) for viewport rendering"
+ * UserPreferencesSystem.use_weight_color_range -> use_weight_color_range:   boolean  "Enable color range used for weight visualization in weight painting mode"
+ * UserPreferencesSystem.weight_color_range -> weight_color_range:   pointer,  "(read-only)    Color range used for weight visualization in weight painting mode"
+ * UserPreferencesSystem.window_draw_method -> window_draw_method:   enum  "Drawing method used by the window manager"
+ * UserPreferencesView.manipulator_handle_size -> manipulator_handle_size:   int  "Size of widget handles as percentage of widget radius"
+ * UserPreferencesView.manipulator_hotspot -> manipulator_hotspot:   int  "Hotspot in pixels for clicking widget handles"
+ * UserPreferencesView.manipulator_size -> manipulator_size:   int  "Diameter of widget, in 10 pixel units"
+ * UserPreferencesView.mini_axis_brightness -> mini_axis_brightness:   int  "The brightness of the icon"
+ * UserPreferencesView.mini_axis_size -> mini_axis_size:   int  "The axis icons size"
+ * UserPreferencesView.object_origin_size -> object_origin_size:   int  "Diameter in Pixels for Object/Lamp origin display"
+ * UserPreferencesView.open_left_mouse_delay -> open_left_mouse_delay:   int  "Time in 1/10 seconds to hold the Left Mouse Button before opening the toolbox"
+ * UserPreferencesView.open_right_mouse_delay -> open_right_mouse_delay:   int  "Time in 1/10 seconds to hold the Right Mouse Button before opening the toolbox"
+ * UserPreferencesView.open_sublevel_delay -> open_sublevel_delay:   int  "Time delay in 1/10 seconds before automatically opening sub level menus"
+ * UserPreferencesView.open_toplevel_delay -> open_toplevel_delay:   int  "Time delay in 1/10 seconds before automatically opening top level menus"
+ * UserPreferencesView.rotation_angle -> rotation_angle:   int  "The rotation step for numerical pad keys (2 4 6 8)"
+ * UserPreferencesView.use_column_layout -> show_column_layout:   boolean  "Use a column layout for toolbox"
+ * UserPreferencesView.use_large_cursors -> show_large_cursors:   boolean  "Use large mouse cursors when available"
+ * UserPreferencesView.use_manipulator -> show_manipulator:   boolean  "Use 3D transform manipulator"
+ * UserPreferencesView.show_mini_axis -> show_mini_axis:   boolean  "Show a small rotating 3D axis in the bottom left corner of the 3D View"
+ * UserPreferencesView.display_object_info -> show_object_info:   boolean  "Display objects name and frame number in 3D view"
+ * UserPreferencesView.show_playback_fps -> show_playback_fps:   boolean  "Show the frames per second screen refresh rate, while animation is played back"
+ * UserPreferencesView.show_splash -> show_splash:   boolean  "Display splash screen on startup"
+ * UserPreferencesView.tooltips -> show_tooltips:   boolean  "Display tooltips"
+ * UserPreferencesView.show_view_name -> show_view_name:   boolean  "Show the name of the views direction in each 3D View"
+ * UserPreferencesView.smooth_view -> smooth_view:   int  "The time to animate the view in milliseconds, zero to disable"
+ * UserPreferencesView.timecode_style -> timecode_style:   enum  "Format of Time Codes displayed when not displaying timing in terms of frames"
+ * UserPreferencesView.auto_perspective -> use_auto_perspective:   boolean  "Automatically switch between orthographic and perspective when changing from top/front/side views"
+ * UserPreferencesView.directional_menus -> use_directional_menus:   boolean  "Otherwise menus, etc will always be top to bottom, left to right, no matter opening direction"
+ * UserPreferencesView.global_pivot -> use_global_pivot:   boolean  "Lock the same rotation/scaling pivot in all 3D Views"
+ * UserPreferencesView.global_scene -> use_global_scene:   boolean  "Forces the current Scene to be displayed in all Screens"
+ * UserPreferencesView.auto_depth -> use_mouse_auto_depth:   boolean  "Use the depth under the mouse to improve view pan/rotate/zoom functionality"
+ * UserPreferencesView.open_mouse_over -> use_mouse_over_open:   boolean  "Open menu buttons and pulldowns automatically when the mouse is hovering"
+ * UserPreferencesView.rotate_around_selection -> use_rotate_around_active:   boolean  "Use selection as the pivot point"
+ * UserPreferencesView.zoom_to_mouse -> use_zoom_to_mouse:   boolean  "Zoom in towards the mouse pointers position in the 3D view, rather than the 2D window center"
+ * UserPreferencesView.view2d_grid_minimum_spacing -> view2d_grid_spacing_min:   int  "Minimum number of pixels between each gridline in 2D Viewports"
+ * UserSolidLight.diffuse_color -> diffuse_color:   float[3]  "The diffuse color of the OpenGL light"
+ * UserSolidLight.direction -> direction:   float[3]  "The direction that the OpenGL light is shining"
+ * UserSolidLight.specular_color -> specular_color:   float[3]  "The color of the lights specular highlight"
+ * UserSolidLight.enabled -> use:   boolean  "Enable this OpenGL light in solid draw mode"
+ * ValueNodeSocket.default_value -> default_value:   float[1]  "Default value of the socket when no link is attached"
+ * ValueNodeSocket.name -> name:   string,  "(read-only)    Socket name"
+ * VectorNodeSocket.default_value -> default_value:   float[3]  "Default value of the socket when no link is attached"
+ * VectorNodeSocket.name -> name:   string,  "(read-only)    Socket name"
+ * VertexGroup.index -> index:   int,  "(read-only)    Index number of the vertex group"
+ * VertexGroup.name -> name:   string  "Vertex group name"
+ * VertexGroupElement.group -> group:   int,  "(read-only)"
+ * VertexGroupElement.weight -> weight:   float  "Vertex Weight"
+ * VoxelData.domain_object -> domain_object:   pointer  "Object used as the smoke simulation domain"
+ * VoxelData.extension -> extension:   enum  "Sets how the texture is extrapolated past its original bounds"
+ * VoxelData.file_format -> file_format:   enum  "Format of the source data set to render"
+ * VoxelData.source_path -> filepath:   string  "The external source data file to use"
+ * VoxelData.intensity -> intensity:   float  "Multiplier for intensity values"
+ * VoxelData.interpolation -> interpolation:   enum  "Method to interpolate/smooth values between voxel cells"
+ * VoxelData.resolution -> resolution:   int[3]  "Resolution of the voxel grid"
+ * VoxelData.smoke_data_type -> smoke_data_type:   enum  "Simulation value to be used as a texture"
+ * VoxelData.still_frame_number -> still_frame:   int  "The frame number to always use"
+ * VoxelData.still -> use_still_frame:   boolean  "Always render a still frame from the voxel data sequence"
+ * Window.screen -> screen:   pointer  "Active screen showing in the window"
+ * WorldLighting.adapt_to_speed -> adapt_to_speed:   float  "Use the speed vector pass to reduce AO samples in fast moving pixels. Higher values result in more aggressive sample reduction. Requires Vec pass enabled (for Raytrace Adaptive QMC)"
+ * WorldLighting.ao_blend_mode -> ao_blend_type:   enum  "Defines how AO mixes with material shading"
+ * WorldLighting.ao_factor -> ao_factor:   float  "Factor for ambient occlusion blending"
+ * WorldLighting.bias -> bias:   float  "Bias (in radians) to prevent smoothed faces from showing banding (for Raytrace Constant Jittered)"
+ * WorldLighting.correction -> correction:   float  "Ad-hoc correction for over-occlusion due to the approximation (for Approximate)"
+ * WorldLighting.distance -> distance:   float  "Length of rays, defines how far away other faces give occlusion effect"
+ * WorldLighting.environment_color -> environment_color:   enum  "Defines where the color of the environment light comes from"
+ * WorldLighting.environment_energy -> environment_energy:   float  "Defines the strength of environment light"
+ * WorldLighting.error_tolerance -> error_threshold:   float  "Low values are slower and higher quality (for Approximate)"
+ * WorldLighting.falloff_strength -> falloff_strength:   float  "Distance attenuation factor, the higher, the shorter the shadows"
+ * WorldLighting.gather_method -> gather_method:   enum  "NO DESCRIPTION"
+ * WorldLighting.indirect_bounces -> indirect_bounces:   int  "Number of indirect diffuse light bounces to use for approximate ambient occlusion"
+ * WorldLighting.indirect_factor -> indirect_factor:   float  "Factor for how much surrounding objects contribute to light"
+ * WorldLighting.passes -> passes:   int  "Number of preprocessing passes to reduce overocclusion (for approximate ambient occlusion)"
+ * WorldLighting.sample_method -> sample_method:   enum  "Method for generating shadow samples (for Raytrace)"
+ * WorldLighting.samples -> samples:   int  "Amount of ray samples. Higher values give smoother results and longer rendering times"
+ * WorldLighting.threshold -> threshold:   float  "Samples below this threshold will be considered fully shadowed/unshadowed and skipped (for Raytrace Adaptive QMC)"
+ * WorldLighting.use_ambient_occlusion -> use_ambient_occlusian:   boolean  "Use Ambient Occlusion to add shadowing based on distance between objects"
+ * WorldLighting.pixel_cache -> use_cache:   boolean  "Cache AO results in pixels and interpolate over neighbouring pixels for speedup (for Approximate)"
+ * WorldLighting.use_environment_lighting -> use_environment_light:   boolean  "Add light coming from the environment"
+ * WorldLighting.falloff -> use_falloff:   boolean  "NO DESCRIPTION"
+ * WorldLighting.use_indirect_lighting -> use_indirect_light:   boolean  "Add indirect light bouncing of surrounding objects"
+ * WorldMistSettings.depth -> depth:   float  "The distance over which the mist effect fades in"
+ * WorldMistSettings.falloff -> falloff:   enum  "Type of transition used to fade mist"
+ * WorldMistSettings.height -> height:   float  "Control how much mist density decreases with height"
+ * WorldMistSettings.intensity -> intensity:   float  "Intensity of the mist effect"
+ * WorldMistSettings.start -> start:   float  "Starting distance of the mist, measured from the camera"
+ * WorldMistSettings.use_mist -> use_mist:   boolean  "Occlude objects with the environment color as they are further away"
+ * WorldStarsSettings.average_separation -> average_separation:   float  "Average distance between any two stars"
+ * WorldStarsSettings.color_randomization -> color_random:   float  "Randomize star colors"
+ * WorldStarsSettings.min_distance -> distance_min:   float  "Minimum distance to the camera for stars"
+ * WorldStarsSettings.size -> size:   float  "Average screen dimension of stars"
+ * WorldStarsSettings.use_stars -> use_stars:   boolean  "Enable starfield generation[650925 refs]"
