/* SPDX-FileCopyrightText: 2023 Blender Authors
 *
 * SPDX-License-Identifier: GPL-2.0-or-later */

/**
 * This pass scans the tile mask generated by the classify step and output indirect dispatch args.
 *
 * Dispatched as one thread for each trace resolution tile.
 */

#pragma BLENDER_REQUIRE(gpu_shader_utildefines_lib.glsl)
#pragma BLENDER_REQUIRE(gpu_shader_math_vector_lib.glsl)
#pragma BLENDER_REQUIRE(gpu_shader_codegen_lib.glsl)
#pragma BLENDER_REQUIRE(eevee_gbuffer_lib.glsl)

void main()
{
  int resolution_scale = uniform_buf.raytrace.resolution_scale;
  ivec2 tile = ivec2(gl_GlobalInvocationID.xy);

  /* True if an adjacent tile is tracing and will need this tile data for denoising. */
  bool tile_is_sampled = false;
  /* True if this tile is shooting and tracing rays. */
  bool tile_is_tracing = false;
  /* Could be optimized if that becomes an issue. */
  for (int x_tile = -1; x_tile <= 1; x_tile++) {
    for (int y_tile = -1; y_tile <= 1; y_tile++) {
      ivec2 tile_adj = tile + ivec2(x_tile, y_tile);
      for (int x = 0; x < resolution_scale; x++) {
        for (int y = 0; y < resolution_scale; y++) {
          ivec2 full_res_tile = tile_adj * resolution_scale + ivec2(x, y);
          if (any(greaterThanEqual(full_res_tile, imageSize(tile_mask_img)))) {
            continue;
          }
          bool denoise_tile_is_used = imageLoad(tile_mask_img, full_res_tile).r != 0u;
          if (denoise_tile_is_used) {
            if (x_tile == 0 && y_tile == 0) {
              /* Dispatch full resolution denoise tile. */
              uint tile_index = atomicAdd(denoise_dispatch_buf.num_groups_x, 1u);
              denoise_tiles_buf[tile_index] = packUvec2x16(uvec2(full_res_tile));
              tile_is_tracing = true;
            }
            else {
              /* This denoise tile will sample the target tracing tile. Make sure it is cleared. */
              tile_is_sampled = true;
            }
          }
        }
      }
    }
  }

  /* TODO(fclem): we might want to dispatch another type of shader only for clearing. */
  if (tile_is_tracing || tile_is_sampled) {
    /* Dispatch trace resolution tracing tile. */
    uint tile_index = atomicAdd(ray_dispatch_buf.num_groups_x, 1u);
    ray_tiles_buf[tile_index] = packUvec2x16(uvec2(tile));
  }
}
