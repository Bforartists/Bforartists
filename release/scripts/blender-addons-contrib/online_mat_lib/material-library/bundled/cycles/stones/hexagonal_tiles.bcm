<?xml version="1.0" encoding="UTF-8"?>
<material view_color="rgb(0.80000, 0.80000, 0.80000)" sample_lamp="True">
	<nodes>
		<node type="OUTPUT_MATERIAL" loc="17, 420" />
		<node type="TEX_COORD" dupli="False" loc="-885, 347" />
		<node type="SCRIPT" mode="INTERNAL" script="0" vector="Vector(0.0, 0.0, 0.0)" diffuseamt="0.70000" specularamt="0.10000" roughness="0.19999" specularcolor="rgba(1.0, 1.0, 1.0, 1.0)" tilecolor="rgba(0.55000, 0.04777, 0.06694, 1.0)" mortarcolor="rgba(0.12053, 0.13075, 0.39999, 1.0)" tileradius="0.20000" mortarwidth="0.01999" tilevary="1.0" scuffing="0.70000" scufffrequency="4.0" scuffcolor="rgba(0.05000, 0.05000, 0.05000, 1.0)" stains="0.60000" stainfrequency="2.0" loc="-269, 467" />
		<node type="MAPPING" translation="Vector(0.0, 0.0, 0.0)" rotation="Vector(0.0, 0.0, 0.0)" scale="Vector(10.0, 10.0, 10.0)" use_min="False" use_max="False" vector="Vector(0.0, 0.0, 0.0)" loc="-626, 392" />
	</nodes>
	<links>
		<link to="0" input="0" from="2" output="0" />
		<link to="2" input="0" from="3" output="0" />
		<link to="3" input="0" from="1" output="2" />
	</links>
	<scripts>
		<script name="LGHexTile.osl" id="0">
/*<br /> * hextile.sl -- surface shader for hexagonal tiles in st space<br /> *<br /> * DESCRIPTION<br /> *       This surface shader operates in s-t space and gives a pattern of<br /> *    hexagonal tiles, similar to that found as floor patterns in public<br /> *    places and such.<br /> *       The basic pattern is a hexagonal tiling, with a little bit of<br /> *    color variation from tile to tile.  On top of that is some staining<br /> *    (presumably due to water or something), which darkens the tile or<br /> *    mortar underneath it.  Finally, there is Scuffing due to people's<br /> *    shoes, which really only affects the tile part not the mortar part.<br /> *<br /> *<br /> * PARAMTERS<br /> *    DiffuseAmt, SpecularAmt, Roughness, SpecularColor - work just like plastic<br /> *    TileColor - the color of the tiles<br /> *    MortarColor - the color of the mortar (space between the tiles)<br /> *    TileRadius - the &quot;radius&quot; (in s-t units) of a single tile<br /> *    MortarWidth - the width of the mortar (in s-t units)<br /> *    TileVary - the color variance from tile to tile<br /> *<br /> * ANTIALIASING<br /> *    Some rudimentary antialiasing is performed on the borders between<br /> *    tile and mortar.<br /> *<br /> * HINTS &amp; APPLICATIONS<br /> *    If all of the default parameters are used, the tiles look just like<br /> *    the floors in the public areas of the Washington DC subway system.<br /> *<br /> * AUTHOR: written by Larry Gritz, 1994<br /> *<br /> * HISTORY:<br /> *    15 Feb 1994 -- written by lg<br /> *       Dec 2012 -- converted/hacked to OSL by varkenvarken<br /> *    17 Dec 2012 -- rename inputs by SAmbler<br /> *<br /> * last modified 15 Feb 94 by Larry Gritz<br /> */<br /><br />shader<br />LGHexTile (<br />    point Vector = P,<br />    float DiffuseAmt = .5,<br />    float SpecularAmt = .2,<br />    float Roughness = .1,<br />    color SpecularColor = 1,<br />    color TileColor = color(.55,0,0),<br />    color MortarColor = color(.5,.5,.5),<br />    float TileRadius = 0.2,<br />    float MortarWidth = 0.02,<br />    float TileVary = 0.15,<br />    float Scuffing = 0.5,<br />    float ScuffFrequency = 4,<br />    color ScuffColor = color (.05,.05,.05),<br />    float Stains = 0.4,<br />    float StainFrequency = 2,<br />    output closure color BSDF = diffuse(N)<br />)<br />{<br />    #define snoise(x) (2*noise(x)-1)<br />    #define snoise2(x,y) (2*noise((x),(y))-1)<br />    #define MINFILTERWIDTH 1.0e-7<br />    #define M_SQRT3 1.7320508 /* sqrt(3) */<br />    <br />    point Nf;<br />    color Ct, Ctile;<br />    float tilewidth;<br />    float ss, tt;<br />    float ttile, stile;<br />    float x, y;<br />    float mortar;<br />    float swidth, twidth, sfuzz, tfuzz, fuzzmax;<br />    float mw2, mw2srt3;<br />    float tileindex;<br />    float stain, scuff;<br />    float ks;<br /><br />    float s = Vector[0];<br />    float t = Vector[1];<br /><br />    swidth = abs(Dx(s)) + abs(Dy(s));<br />    twidth = abs(Dx(t)) + abs(Dy(t));<br />    sfuzz = 0.5 * swidth;<br />    tfuzz = 0.5 * twidth;<br />    fuzzmax = max(sfuzz, tfuzz);<br />    Nf = N;<br /><br />    tilewidth = TileRadius * M_SQRT3;<br />    tt = mod (t, 1.5*TileRadius);<br />    ttile = floor(t/(1.5*TileRadius));<br />    if (mod(ttile/2, 1) == 0.5)<br />       ss = s + tilewidth/2;<br />    else ss = s;<br />    stile = floor(ss / tilewidth);<br />    ss = mod(ss, tilewidth);<br />    mortar = 0;<br />    mw2 = MortarWidth/2;<br />    if (tt &lt; TileRadius) {<br />      mortar =  1 - (smoothstep(mw2,mw2+sfuzz,ss) *<br />             (1 - smoothstep(tilewidth-mw2-sfuzz,tilewidth-mw2,ss)));<br />    }<br />    else {<br />      x = tilewidth/2 - abs(ss - tilewidth/2);<br />      y = M_SQRT3 * (tt - TileRadius);<br />      if (y &gt; x) {<br />      if (mod (ttile/2, 1) == 0.5)<br />          stile -= 1;<br />      ttile += 1;<br />      if (ss &gt; tilewidth/2)<br />          stile += 1;<br />    }<br /><br />        mw2srt3 = M_SQRT3*mw2;<br />        mortar = (smoothstep(x-mw2srt3-tfuzz, x-mw2srt3, y) *<br />            (1 - smoothstep(x+mw2srt3, x+mw2srt3+tfuzz, y)));<br />    }<br /><br />    tileindex = stile+41*ttile;<br />    Ctile = TileColor * (1 + TileVary * snoise(tileindex+0.5));<br /><br />    stain = Stains * smoothstep (.5,1, noise(s*StainFrequency,t*StainFrequency));<br /><br />    scuff = Scuffing * smoothstep (.6,1, noise(t*ScuffFrequency-90.26,s*ScuffFrequency+123.82));<br /><br />    ks = SpecularAmt * (1-scuff/2);<br />    Ct = (1-stain) * mix(mix(Ctile, ScuffColor, scuff), MortarColor, mortar);<br /><br />    Nf = normalize(N);<br />    BSDF = Ct*DiffuseAmt*diffuse(Nf);<br />    BSDF += SpecularColor*ks*microfacet_beckmann(Nf,Roughness);<br />}<br /><br />
		</script>
	</scripts>
</material>